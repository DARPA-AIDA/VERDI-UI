{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/Claims.vue?vue&type=style&index=0&id=1b040994&lang=scss&scoped=true&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/Claims.vue","mtime":1640207172535},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/css-loader/dist/cjs.js","mtime":1641411773021},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1641411774047},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/postcss-loader/src/index.js","mtime":1641411773350},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/sass-loader/dist/cjs.js","mtime":1641411772200},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5sb2FkaW5nLXNlY3Rpb24gewogICAgbWFyZ2luOiA0OHB4IDA7Cn0KCi5sb2FkaW5nLW1lc3NhZ2UtY2xlYXIgewogICAgQGluY2x1ZGUgZmxleC1yb3ctbm93cmFwOwogICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7CiAgICBoZWlnaHQ6IDYwcHg7CiAgICBwYWRkaW5nOiAxNnB4Owp9CgouaW5jaWRlbnQtc3BhY2U6bm90KDpmaXJzdC1jaGlsZCkgewogICAgbWFyZ2luOiA2MHB4IDAgMzJweDsKfQoKLmluY2lkZW50LXRpdGxlIHsKICAgIGZvbnQtc2l6ZTogMThweDsKICAgIEBleHRlbmQgLmJvbGQtdGV4dDsKICAgIHdpZHRoOiAxMDAlOwogICAgY29sb3I6ICR0aGVtZS10ZWFsLXRleHQ7CiAgICBsaW5lLWhlaWdodDogMzJweDsKICAgIGZvbnQtc3R5bGU6IGl0YWxpYzsKfQoK"},{"version":3,"sources":["Claims.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2gBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Claims.vue","sourceRoot":"src/views/analyze","sourcesContent":["<!--\n  - Copyright 2019 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n-->\n\n<template>\n    <div class=\"page-content\">\n        <div class=\"kb-details\">\n            <div class=\"kb-description-wrapper\">\n                <div v-if=\"searchType !== SEARCHTYPES.multi\" class=\"kb-heading\">Claims</div>\n                <div v-if=\"claimsTopic\"><span class=\"kb-labels\">Topic: </span><span>{{claimsTopic}}</span></div>\n            </div>\n        </div>\n        <div v-if=\"loading===true\" class=\"loading-section\">\n            <v-progress-linear indeterminate></v-progress-linear>\n            <div class=\"loading-message-clear\">{{statusMessage}}</div>\n        </div>\n        <div v-else>\n            <div v-if=\"statusMessage === NODATAMESSAGE\"  class=\"loading-message-clear\">{{statusMessage}}</div>\n            <div v-else-if=\"incidents && Object.keys(incidents).length > 0\">\n                <div v-for=\"(incident, incidentIndex) in Object.keys(incidents)\" :key=\"incidentIndex\" class=\"incident-space\">\n                    <div class=\"element-list-header\">\n                        <div class=\"page-header-left incident-title\">{{incident}}</div>\n                        <div class=\"page-header-right\">\n                            <div class=\"button-icon\" @click=\"toggleIncidentSection(incidentIndex)\">\n                                <InfoTooltip :ref=\"getTooltipId(incidentIndex)\" :message=\"toggleIncidents[getTooltipId(incidentIndex)].message\" :icon=\"toggleIncidents[getTooltipId(incidentIndex)].icon\" :iconStyle=\"'teal-large'\"></InfoTooltip>\n                            </div>\n                        </div>\n                    </div>\n                    <div v-for=\"(type, typeIndex) in incidents[incident]\" :key=\"typeIndex\" :class=\"typeIndex > 0 && !toggleIncidents[getTooltipId(incidentIndex)].closed ? 'section-space' : ''\">\n                        <DataTable\n                                :data=\"sinData[incident][type]\"\n                                :sort=\"sort\"\n                                :loading=\"Object.keys(sinData[incident][type]).length === 0\"\n                                :paging=\"paging\"\n                                :tableConfiguration=\"buildTableConfiguration(type)\"\n                                :statusMessage=\"statusMessage\"\n                                :hideData=\"toggleIncidents[getTooltipId(incidentIndex)].closed\"\n                                :hideFooter=true\n                                @currentItems=\"updateItems($event)\"\n                        ></DataTable>\n                    </div>\n                </div>\n            </div>\n            <div v-else>\n                <div v-for=\"(type, index) in types\" :key=\"index\" :class=\"index > 0 ? 'section-space' : ''\">\n                    <DataTable\n                            :data=\"sinData[type]\"\n                            :sort=\"sort\"\n                            :loading=\"Object.keys(sinData[type]).length === 0\"\n                            :paging=\"paging\"\n                            :tableConfiguration=\"buildTableConfiguration(type)\"\n                            :statusMessage=\"statusMessage\"\n                            :hideFooter=true\n                            @currentItems=\"updateItems($event)\"\n                    ></DataTable>\n                </div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import DataTable from '@/components/DataTable';\n    import { mapMutations, mapState, mapActions} from 'vuex';\n    import API from '../../api';\n    import CategoryTypes from '@/assets/data/types.json';\n    import InfoTooltip from '@/components/InfoTooltip';\n    import {\n        TABLESELECTIONS,\n        TABLEFIELDMAPPING,\n        DATATYPES,\n        LOADINGMESSAGE,\n        NODATAMESSAGE,\n        SEARCHTYPES,\n        getSinArgumentHeadline,\n        SecondaryExpand,\n        formatSinsClaims,\n        sortCaseInsensitive,\n        getType,\n        getRole,\n        getEntityName,\n        getIncidentName,\n        getEntityIdentifiers,\n        getTemplate,\n        getTemplatePredicate,\n        getTypesFromQuery,\n        getTransformedType,\n        getLastSubType,\n        sponsorTypes,\n        TableSettings,\n        HeaderConfig\n    } from '../../utils';\n\n    const currentRequests = new Map();\n    export default {\n        name: 'Claims',\n        props: {\n            searchType: {\n                type: String,\n                default: SEARCHTYPES.single,\n                required: false\n            },\n            claimSearchSinId: {\n                type: String,\n                default: null,\n                required: false\n            },\n            claimSearchFilters: {\n                type: Array,\n                default: null,\n                required: false\n            },\n        },\n        components: {DataTable, InfoTooltip},\n        data: () => ({\n            sort: {[TABLESELECTIONS.sortBy]: TABLEFIELDMAPPING.statement, [TABLESELECTIONS.sortDesc]: false},\n            paging: {[TABLESELECTIONS.itemsPerPage]:'All'},\n            statusMessage: '',\n            claims: {},\n            memberTypes: [],\n            incidentTypes: {},\n            SIN: {},\n            loading: false,\n            toggleTables: {}\n        }),\n        created() {\n            this.TABLEFIELDMAPPING = TABLEFIELDMAPPING;\n            this.DATATYPES = DATATYPES;\n            this.loading  = true;\n            this.statusMessage = LOADINGMESSAGE;\n            this.NODATAMESSAGE = NODATAMESSAGE;\n            this.SEARCHTYPES = SEARCHTYPES;\n        },\n        mounted() {\n            this.updateHypothesisSelection({});\n        },\n        computed: {\n            ...mapState(['defaultHypothesisDataSource', 'hypothesisSelection','currentDataSource', 'sinSelection', 'term', 'dataSourceList']),\n            types() {\n                return this.memberTypes.length > 0 ? this.memberTypes : null;\n            },\n            incidents() {\n                return this.incidentTypes;\n            },\n            sinData() {\n                return Object.keys(this.claims).length > 0 ? this.claims : null;\n            },\n            sinId() {\n                return this.sinSelection[TABLEFIELDMAPPING.sinList] ? this.sinSelection[TABLEFIELDMAPPING.sinList][0] : this.claimsSearchSinId ? this.claimsSearchSinId : '';\n            },\n            claimsTopic() {\n                if(this.sinId && this.searchType === SEARCHTYPES.single || this.searchType === SEARCHTYPES.multi) {\n                     this.setClaims();\n                 }\n                return this.term && this.term.input ? this.term.input : '';\n            },\n            toggleIncidents() {\n                return Object.keys(this.toggleTables).length > 0 ? this.toggleTables : null;\n            }\n        },\n        methods: {\n            ...mapMutations(['updateHypothesisSelection']),\n            ...mapActions(['updateCurrentDataSource']),\n            buildTableConfiguration(type) {\n                return {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.id, true, type, '', false, false, false, false, false, 'statement', false, true),\n                    primaryHeaders: [\n                        new HeaderConfig('Statement', 'start', true, TABLEFIELDMAPPING.statement),\n                        new HeaderConfig('Event Type', 'start', true, TABLEFIELDMAPPING.clusterType),\n                        new HeaderConfig('Date', 'start', true, TABLEFIELDMAPPING.dates),\n                        new HeaderConfig('', 'center', false, 'data-table-expand')\n                    ],\n                    secondaryHeaders: {\n                        expanded: new SecondaryExpand('', TABLEFIELDMAPPING.documentList,\n                            [\n                                new HeaderConfig('Entity', 'start', false, TABLEFIELDMAPPING.headline),\n                                new HeaderConfig('Supporting Document', 'start', false, TABLEFIELDMAPPING.docId),\n                                new HeaderConfig('Document Title', 'start', false, TABLEFIELDMAPPING.docTitle)\n                            ]\n                        )\n                    }\n                };\n            },\n            toggleIncidentSection(index) {\n                const toggleId = this.getTooltipId(index);\n                if(this.$refs[toggleId].length > 0) {\n                    const el = this.$refs[toggleId][0];\n                    if(this.toggleTables.hasOwnProperty(toggleId)) {\n                        if(el.icon === 'mdi-chevron-down') {\n                            this.toggleTables[toggleId].message = 'Open Section';\n                            this.toggleTables[toggleId].icon = 'mdi-chevron-up';\n                        }\n                        else {\n                            this.toggleTables[toggleId].message = 'Close Section';\n                            this.toggleTables[toggleId].icon = 'mdi-chevron-down';\n                        }\n                        this.toggleTables[toggleId].closed = !this.toggleTables[toggleId].closed;\n                    }\n                }\n            },\n            updateItems(currentItems) {\n                const toPopulate = currentItems.filter(item => item[TABLEFIELDMAPPING.documentList].length === 0 &&\n                    !currentRequests.has(item[TABLEFIELDMAPPING.prototypeUri]));\n\n                for (const item of toPopulate) {\n                    const prototype = item[TABLEFIELDMAPPING.prototypeUri];\n                    const roles = [...new Set(item[TABLEFIELDMAPPING.entityList].flatMap(entity => entity[TABLEFIELDMAPPING.roleUri]))];\n                    const hypothesisUri = item[TABLEFIELDMAPPING.hypothesisList][0];\n                    const graph = !this.claimSearchSinId ? this.currentDataSource : '';\n                    const promise = API.getSinDocuments(prototype, graph, hypothesisUri, roles);\n\n\n                    currentRequests.set(prototype, promise);\n                    promise.then(docs => {\n                        const formattedDocs = new Map();\n                        if(Object.keys(docs.data).length > 0) {\n                            for (const object of docs.data) {\n                                const docList = object[TABLEFIELDMAPPING.documentList];\n                                let argumentString = '';\n                                if(object.queryObject.toLowerCase().includes(DATATYPES.entityType.id)) {\n                                    const argument = item[TABLEFIELDMAPPING.entityList].find(entity => entity[TABLEFIELDMAPPING.prototypeUri] === object.queryObject);\n                                    const argumentIdentifier = argument && this.getEntityIdentifiers([argument]);\n                                    argumentString = argumentIdentifier && Object.values(argumentIdentifier)[0][0];\n                                }\n                                else {\n                                    argumentString = getTemplatePredicate(item[TABLEFIELDMAPPING.clusterType]);\n                                }\n\n                                for(const doc of docList) {\n                                    if(!formattedDocs.has(doc) && argumentString) {\n                                        formattedDocs.set(doc, {[TABLEFIELDMAPPING.docId]: doc.id, [TABLEFIELDMAPPING.docTitle]: doc.title, [TABLEFIELDMAPPING.headline]: [argumentString]});\n                                    }\n                                    else if(argumentString) {\n                                        formattedDocs.get(doc)[TABLEFIELDMAPPING.headline].push(argumentString);\n                                    }\n                                }\n                            }\n                        }\n\n                        //loop through to turn the items in the supported document headline array into a single string\n                        for(const fd of formattedDocs.values()) {\n                            fd[TABLEFIELDMAPPING.headline] = this.getQuotedStrings(fd[TABLEFIELDMAPPING.headline]);\n                        }\n\n                        //adds documents to the current position in the claims data\n                        item[TABLEFIELDMAPPING.documentList] = [...formattedDocs.values()];\n                        currentRequests.delete(prototype);\n                    });\n                }\n            },\n            setClaims() {\n                this.$emit('completedSearch', false);\n                if(this.sinId && this.sinId !== 'undefined' || this.searchType === SEARCHTYPES.multi) {\n                    const types = getTypesFromQuery(this.term && this.term.input || '');\n                    let filters = [];\n                    if (types) {\n                        types.push(...sponsorTypes);\n                        for (const type of types) {\n                            filters.push({['eventType'] : type});\n                        }\n                    }\n\n                    const sinDataSource = this.replaceDataSourceSinId();\n                    if(this.dataSourceList.includes(sinDataSource)) {\n                        this.updateCurrentDataSource(sinDataSource);\n                    }\n\n                    const dataSource = this.currentDataSource ? this.currentDataSource : this.defaultHypothesisDataSource;\n                    let queryFilters = {['graph'] : dataSource};\n                    if(filters.length > 0) {\n                        queryFilters['filters'] = filters;\n                    }\n                    this.loading = true;\n                    this.statusMessage = LOADINGMESSAGE;\n                    if(!this.claimSearchSinId && this.searchType === SEARCHTYPES.single) {\n                        API.getSinQueryResults(this.sinId, queryFilters).then(response => {\n                            const sinData = response.data;\n                            if (Object.keys(sinData).length > 0 && sinData.hypotheses) {\n                                this.SIN = sinData;\n                                this.getFormattedData(sinData);\n                            }\n                            else {\n                                this.statusMessage = this.NODATAMESSAGE;\n                                this.loading = false;\n                                this.$emit('completedSearch', true);\n                            }\n                        }).catch((error) => {\n                            console.warn(error)\n                        });\n                    }\n                    else if(!this.claimSearchSinId && this.searchType === SEARCHTYPES.multi) {\n                        //updates the claims data and member types\n                        let formattedData = {};\n                        let toggleData = {};\n                        this.claims = {};\n                        this.incidentTypes = {};\n\n                        const claimFilters = this.claimSearchFilters.length > 0 ? {['filters']:this.claimSearchFilters} : {};\n                        API.getAllSinQueryResults(claimFilters).then(response => {\n                            const sinEvents = response.data;\n                            if (Object.keys(sinEvents).length > 0) {\n                                //Map events based on sin and then event type\n                                for (const event of sinEvents) {\n                                    const sinTitle = getIncidentName(event[TABLEFIELDMAPPING.sinId]);\n                                    const eventType = event[TABLEFIELDMAPPING.clusterType];\n                                    if (!Object.keys(formattedData).includes(sinTitle)) {\n                                        formattedData[sinTitle] = {};\n                                    }\n\n                                    if (!Object.keys(formattedData[sinTitle]).length) {\n                                        formattedData[sinTitle] = {[eventType] : {}};\n                                    }\n                                    else if(!Object.keys(formattedData[sinTitle]).includes(eventType)) {\n                                        formattedData[sinTitle][eventType] = {};\n                                    }\n\n                                    //Before adding the event, format roles\n                                    for (const entity of event[TABLEFIELDMAPPING.entityList]) {\n                                        entity[TABLEFIELDMAPPING.roles] = sortCaseInsensitive([...new Set(entity[TABLEFIELDMAPPING.roleUri].flatMap(getRole))])\n                                    }\n                                    event[TABLEFIELDMAPPING.hypothesisList] = [event.hypothesis];\n                                    event[TABLEFIELDMAPPING.category] = event[TABLEFIELDMAPPING.clusterCategory];\n\n                                    let date = null;\n                                    if(event.date) {\n                                        date = event.date.toString();\n                                        event[TABLEFIELDMAPPING.dates] = event.date;\n                                    }\n\n                                    const key = event[TABLEFIELDMAPPING.statement] + event[TABLEFIELDMAPPING.clusterType] +  date;\n                                    event[TABLEFIELDMAPPING.id] = key;\n\n                                    //deduplicate\n                                    if(!formattedData[sinTitle][eventType].hasOwnProperty(key)) {\n                                        formattedData[sinTitle][eventType][key] = event;\n                                    }\n                                }\n\n                                //remove keys from event object\n                                for(let sin in formattedData) {\n                                    if(formattedData.hasOwnProperty(sin)) {\n                                        for(let eventType in formattedData[sin]) {\n                                            if(formattedData[sin].hasOwnProperty(eventType)) {\n                                                formattedData[sin][eventType] = Object.values(formattedData[sin][eventType]);\n                                            }\n                                        }\n                                    }\n                                }\n\n                                this.claims = formattedData;\n\n                                for(const [incident, types] of Object.entries(this.claims)) {\n                                    this.incidentTypes[incident] = Object.keys(types).sort();\n                                }\n                                for(let i=0; i <Object.keys(this.incidentTypes).length; i++) {\n                                    toggleData[this.getTooltipId(i)] = {message : 'Close Section', icon : 'mdi-chevron-down', closed : false};\n                                }\n                                this.toggleTables = toggleData;\n\n                                this.loading = false;\n                                this.$emit('completedSearch', true);\n                            }\n                            else {\n                                this.statusMessage = this.NODATAMESSAGE;\n                                this.loading = false;\n                                this.$emit('completedSearch', true);\n                            }\n\n                        }).catch((error) => {\n                            console.warn(error)\n                        });\n                    }\n                    else {\n                        const claimFilters = this.claimSearchFilters.length > 0 ? {['filters']:this.claimSearchFilters} : {};\n                        API.getSinQueryResults(this.claimSearchSinId, claimFilters).then(response => {\n                            const sinData = response.data;\n                            if (Object.keys(sinData).length > 0 && sinData.hypotheses) {\n                                this.SIN = sinData;\n                                this.getFormattedData(sinData);\n                            } else {\n                                this.statusMessage = this.NODATAMESSAGE;\n                                this.loading = false;\n                                this.$emit('completedSearch', true);\n                            }\n                        }).catch((error) => {\n                            console.warn(error)\n                        });\n                    }\n                }\n                else {\n                    this.statusMessage = this.NODATAMESSAGE;\n                    this.loading = false;\n                    this.$emit('completedSearch', true);\n                }\n            },\n            addSponsored(sponsored, member) {\n                const events = member.roles.find(role => role.role.includes('_ActorOrEvent'));\n                let sponsorRoles = member.roles.find(role => role.role.includes('_Sponsor'));\n                if (events && sponsorRoles) {\n                    const sponsors = new Set();\n                    for (const sponsor of sponsorRoles.arguments)  {\n                        sponsor[TABLEFIELDMAPPING.headline] = getSinArgumentHeadline(sponsor);\n                        const name = getEntityName(sponsor);\n                        if (name) {\n                            sponsors.add(name);\n                        }\n                    }\n                    if (sponsors.size) {\n                        for (const event of events.arguments) {\n                            let sponsoredEvent = sponsored[event.id];\n                            if (!sponsoredEvent) {\n                                sponsoredEvent = sponsored[event.id] = [];\n                            }\n                            sponsoredEvent.push(...sponsors);\n                        }\n                    }\n                }\n            },\n            getTooltipId(id) {\n                return 'incidentTooltip' + id;\n            },\n            getFormattedData(sin) {\n                const members = new Map();\n                for (const hypObject of sin.hypotheses || []) {\n                    const sponsored = {};\n                    for (const member of hypObject.members) {\n                        const category = getType(member[TABLEFIELDMAPPING.category]).toLowerCase();\n                        const type = getType(member.type);\n                        if (category === DATATYPES.relationType.id && member.roles.length === 2 && type.includes('Sponsorship')) {\n                            this.addSponsored(sponsored, member);\n                        }\n\n                        //if there are no arguments then there is no need to show the member\n                        if (category === DATATYPES.eventType.id && member.roles.length > 0) {\n                            let formattedMember = {\n                                node: member.node,\n                                prototype: member.prototype,\n                                category: category,\n                                type: type,\n                                roles: [...new Map(member.roles.map(role => [role, role])).values()].sort(),\n                                hypotheses: [hypObject.hypothesis],\n                                dates: member.dates\n                            };\n\n                            formattedMember = formatSinsClaims(formattedMember, DATATYPES.eventType.id, type);\n                            const identifiers = getEntityIdentifiers(formattedMember[TABLEFIELDMAPPING.entityList]);\n                            const sponsor = sponsored[member.node];\n                            formattedMember[TABLEFIELDMAPPING.statement] = getTemplate(type, identifiers) + (sponsor ? ' (sponsor: ' + sponsor + ')' : '');\n\n                            const formattedType = getTransformedType(getLastSubType(type), CategoryTypes.eventTypeMapping);\n                            if (!members.has(formattedType)) {\n                                members.set(formattedType, []);\n                            }\n                            members.get(formattedType).push(formattedMember);\n                        }\n                    }\n                }\n\n                // create object of type->[members]\n                const membersReduce = {};\n                members.forEach((values, key) => {\n                    // iterate over values and add them to membersReduce[key]\n                    const deduped = new Map();\n                    const addMember = member => {\n                        const date = member.date ? member.date.toString() : null;\n                        const key = member.statement + member.type;\n                        if (!deduped.has(key)) {\n                            deduped.set(key, new Map());\n                        } else if (!date) {\n                            // drop duplicates without date\n                            return;\n                        }\n                        member.id = key + date;\n                        // only keep track of one member per date\n                        deduped.get(key).set(date, member);\n                    };\n                    const noDates = [];\n                    for (const member of values) {\n                        if (!member.date) {\n                            noDates.push(member);\n                        } else {\n                            addMember(member);\n                        }\n                    }\n                    noDates.forEach(addMember);\n                    membersReduce[key] = [];\n                    deduped.forEach(value => membersReduce[key].push(...value.values()));\n                });\n\n                this.loading = false;\n                this.$emit('completedSearch', true);\n\n                //updates the claims data and member types\n                this.claims = membersReduce;\n                this.memberTypes = Object.keys(membersReduce).sort();\n            },\n            replaceDataSourceSinId() {\n                let truncateSource = this.currentDataSource.split('/');\n                //e.g. [https:, , www.nextcentury.com, TA3, E201, GAIA-20210203, GAIA-20210119, GAIA-20210119]\n                truncateSource.splice(4, 1, this.sinId);\n                return truncateSource.join('/');\n            },\n            getQuotedStrings(values) {\n                return '\"' + [...new Set(values)].join('\", \"') + '\"';\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .loading-section {\n        margin: 48px 0;\n    }\n\n    .loading-message-clear {\n        @include flex-row-nowrap;\n        justify-content: center;\n        height: 60px;\n        padding: 16px;\n    }\n\n    .incident-space:not(:first-child) {\n        margin: 60px 0 32px;\n    }\n\n    .incident-title {\n        font-size: 18px;\n        @extend .bold-text;\n        width: 100%;\n        color: $theme-teal-text;\n        line-height: 32px;\n        font-style: italic;\n    }\n\n</style>\n"]}]}