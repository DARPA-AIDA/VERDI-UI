{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/IncidentDetail.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/IncidentDetail.vue","mtime":1640207172536},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/babel-loader/lib/index.js","mtime":1641411773354},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBEYXRhVGFibGUgZnJvbSAnQC9jb21wb25lbnRzL0RhdGFUYWJsZSc7CmltcG9ydCBTZWxlY3REcm9wZG93biBmcm9tICdAL2NvbXBvbmVudHMvU2VsZWN0RHJvcGRvd24nOwppbXBvcnQgUXVlcnlTdWJtaXNzaW9uTWl4aW4gZnJvbSAnQC9taXhpbnMvUXVlcnlTdWJtaXNzaW9uTWl4aW4nOwppbXBvcnQgeyBtYXBNdXRhdGlvbnMsIG1hcFN0YXRlfSBmcm9tICd2dWV4JzsKaW1wb3J0IHsKICAgIFRBQkxFU0VMRUNUSU9OUywKICAgIFRBQkxFRklFTERNQVBQSU5HLAogICAgREFUQVRZUEVTLAogICAgTE9BRElOR01FU1NBR0UsCiAgICBOT0RBVEFNRVNTQUdFLAogICAgSU5DSURFTlRNQVBQSU5HLAogICAgU0VMRUNURElTUExBWSwKICAgIFBBUkFNRVRFUk5BTUVTLAogICAgSk9JTlNUUklORywKICAgIGdldEluY2lkZW50TmFtZSwKICAgIGdldEluY2lkZW50SWQsCiAgICBUYWJsZVNldHRpbmdzLAogICAgSGVhZGVyQ29uZmlnCn0gZnJvbSAnLi4vLi4vdXRpbHMnOwoKZXhwb3J0IGRlZmF1bHQgewogICAgbmFtZTogJ0luY2lkZW50RGV0YWlsJywKICAgIG1peGluczogW1F1ZXJ5U3VibWlzc2lvbk1peGluXSwKICAgIGNvbXBvbmVudHM6IHtEYXRhVGFibGUsIFNlbGVjdERyb3Bkb3dufSwKICAgIGRhdGE6ICgpID0+ICh7CiAgICAgICAgc29ydDoge1tUQUJMRVNFTEVDVElPTlMuc29ydEJ5XTogVEFCTEVGSUVMRE1BUFBJTkcuaWQsIFtUQUJMRVNFTEVDVElPTlMuc29ydERlc2NdOiBmYWxzZX0sCiAgICAgICAgcGFnaW5nOiB7W1RBQkxFU0VMRUNUSU9OUy5pdGVtc1BlclBhZ2VdOidBbGwnfSwKICAgICAgICBzdGF0dXNNZXNzYWdlOiAnJywKICAgICAgICBzaW5DbHVzdGVyc0J5U2luSWQgOiB7fSwKICAgICAgICBzdW1tYXJ5SXRlbXNCeVNpbklkOiBbXSwKICAgICAgICBzdW1tYXJ5VHlwZXM6IFtdLAogICAgICAgIHNpbklkOiBudWxsLAogICAgICAgIHNlbGVjdERpc3BsYXk6IFNFTEVDVERJU1BMQVkuaW5wdXQsCiAgICAgICAgU0lOOiB7fSwKICAgICAgICByZXN1bHRzQW5jaG9yOiAnZXZlbnRfYW5jaG9yXycsCiAgICAgICAgdG9wQW5jaG9yOiAnc3VtbWFyeV9hbmNob3InLAogICAgICAgIHNjcm9sbFBvc2l0aW9uOiAwLAogICAgICAgIGN1cnJlbnRQb3NpdGlvbjogbnVsbAogICAgfSksCiAgICBjcmVhdGVkKCkgewogICAgICAgIHRoaXMuVEFCTEVGSUVMRE1BUFBJTkcgPSBUQUJMRUZJRUxETUFQUElORzsKICAgICAgICB0aGlzLkRBVEFUWVBFUyA9IERBVEFUWVBFUzsKICAgICAgICB0aGlzLnN0YXR1c01lc3NhZ2UgPSBMT0FESU5HTUVTU0FHRTsKICAgICAgICB0aGlzLlBBUkFNRVRFUk5BTUVTID0gUEFSQU1FVEVSTkFNRVM7CiAgICB9LAogICAgbW91bnRlZCgpIHsKICAgICAgICB0aGlzLnVwZGF0ZUh5cG90aGVzaXNTZWxlY3Rpb24oe30pOwogICAgICAgIHRoaXMuc2luSWQgPSBJTkNJREVOVE1BUFBJTkdbMF0uaWQ7CgogICAgICAgIGlmKE9iamVjdC5rZXlzKHRoaXMua25vd2xlZGdlQmFzZSkubGVuZ3RoID09PSAwIHx8ICF0aGlzLmtub3dsZWRnZUJhc2VbREFUQVRZUEVTLnNpbi5pZF0pIHsKICAgICAgICAgICAgdGhpcy5sb2FkU0lORGF0YShEQVRBVFlQRVMuc2luLmlkKTsKICAgICAgICB9CgogICAgICAgIHdpbmRvdy5vbnNjcm9sbCA9ICgpID0+IHRoaXMuYWN0aXZhdGVTY3JvbGxBcnJvdygpOwogICAgfSwKICAgIGNvbXB1dGVkOiB7CiAgICAgICAgLi4ubWFwU3RhdGUoWydkZWZhdWx0SHlwb3RoZXNpc0RhdGFTb3VyY2UnLCAnaHlwb3RoZXNpc1NlbGVjdGlvbicsJ2N1cnJlbnREYXRhU291cmNlJywgJ2tub3dsZWRnZUJhc2UnXSksCiAgICAgICAgc3VtbWFyeURhdGEoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1bW1hcnlJdGVtc0J5U2luSWQubGVuZ3RoID4gMCAgPyB0aGlzLnN1bW1hcnlJdGVtc0J5U2luSWQgOiB0aGlzLmdldERldGFpbERhdGEoKTsKICAgICAgICB9LAogICAgICAgIHR5cGVzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5zdW1tYXJ5VHlwZXM7CiAgICAgICAgfSwKICAgICAgICBzaW5EYXRhKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5zaW5DbHVzdGVyc0J5U2luSWQ7CiAgICAgICAgfSwKICAgICAgICBzaW5JZHMoKSB7CiAgICAgICAgICAgIHJldHVybiBJTkNJREVOVE1BUFBJTkcubWFwKHYgPT4gdi52YWx1ZSk7CiAgICAgICAgfQogICAgfSwKICAgIG1ldGhvZHM6IHsKICAgICAgICAuLi5tYXBNdXRhdGlvbnMoWyd1cGRhdGVIeXBvdGhlc2lzU2VsZWN0aW9uJ10pLAogICAgICAgIGJ1aWxkU3VtYW1yeVRhYmxlKCkgewogICAgICAgICAgICBsZXQgdGFibGVNYXBwaW5ncyA9IHsKICAgICAgICAgICAgICAgIHRhYmxlU2V0dGluZ3M6IG5ldyBUYWJsZVNldHRpbmdzKFRBQkxFRklFTERNQVBQSU5HLmlkLCBmYWxzZSwgJ0NsYWltcyBTdW1tYXJ5JywgJycsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2hlYWRsaW5lJywgZmFsc2UpLAogICAgICAgICAgICAgICAgcHJpbWFyeUhlYWRlcnM6IFsKICAgICAgICAgICAgICAgICAgICBuZXcgSGVhZGVyQ29uZmlnKCcnLCAnY2VudGVyJywgZmFsc2UsICdkYXRhLXRhYmxlLWFuY2hvcicpLAogICAgICAgICAgICAgICAgICAgIG5ldyBIZWFkZXJDb25maWcoJ0V2ZW50cycsICdzdGFydCcsIHRydWUsIFRBQkxFRklFTERNQVBQSU5HLmhlYWRsaW5lLCB0cnVlLCBmYWxzZSksCiAgICAgICAgICAgICAgICAgICAgbmV3IEhlYWRlckNvbmZpZygnJywgJ3N0YXJ0JywgdHJ1ZSwgVEFCTEVGSUVMRE1BUFBJTkcubm9kZUNvdW50LCB0cnVlLCBmYWxzZSksCiAgICAgICAgICAgICAgICAgICAgbmV3IEhlYWRlckNvbmZpZygnJywgJ3N0YXJ0JywgdHJ1ZSwgVEFCTEVGSUVMRE1BUFBJTkcuZW50aXR5Q291bnQsIHRydWUsIGZhbHNlKSwKICAgICAgICAgICAgICAgICAgICBuZXcgSGVhZGVyQ29uZmlnKCcnLCAnc3RhcnQnLCB0cnVlLCBUQUJMRUZJRUxETUFQUElORy5pZCwgdHJ1ZSwgZmFsc2UpCiAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgIH07CgogICAgICAgICAgICByZXR1cm4gdGFibGVNYXBwaW5nczsKICAgICAgICB9LAogICAgICAgIGJ1aWxkVGFibGVDb25maWd1cmF0aW9uKHR5cGUpIHsKICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLnNpbkRhdGFbdHlwZV1bMF1bVEFCTEVGSUVMRE1BUFBJTkcuc2luVGl0bGVdOwogICAgICAgICAgICBsZXQgcm9sZUhlYWRlcnMgPSBuZXcgTWFwKCk7CiAgICAgICAgICAgIGxldCB0YWJsZU1hcHBpbmdzID0gewogICAgICAgICAgICAgICAgdGFibGVTZXR0aW5nczogbmV3IFRhYmxlU2V0dGluZ3MoVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmksIGZhbHNlLCB0eXBlLnNwbGl0KEpPSU5TVFJJTkcpWzBdLCBjYXRlZ29yeSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUsICdoZWFkbGluZScsIGZhbHNlKSwKICAgICAgICAgICAgICAgIHByaW1hcnlIZWFkZXJzOiBbCiAgICAgICAgICAgICAgICAgICAgbmV3IEhlYWRlckNvbmZpZygnQ2xhaW0nLCAnc3RhcnQnLCB0cnVlLCBUQUJMRUZJRUxETUFQUElORy5oZWFkbGluZSwgZmFsc2UsIGZhbHNlKSwKICAgICAgICAgICAgICAgICAgICBuZXcgSGVhZGVyQ29uZmlnKCdFdmVudCBTdGF0ZW1lbnQnLCAnc3RhcnQnLCB0cnVlLCBUQUJMRUZJRUxETUFQUElORy5zdGF0ZW1lbnQsIGZhbHNlLCB0cnVlKQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICB9OwoKICAgICAgICAgICAgZm9yIChjb25zdCBoeXBvdGhlc2lzIG9mIHRoaXMuc2luRGF0YVt0eXBlXSkgewogICAgICAgICAgICAgICAgcm9sZUhlYWRlcnMgPSBuZXcgTWFwKFsuLi5yb2xlSGVhZGVycywgLi4ubmV3IE1hcChoeXBvdGhlc2lzW1RBQkxFRklFTERNQVBQSU5HLnJvbGVzXS5tYXAocm9sZSA9PgogICAgICAgICAgICAgICAgICAgIFtyb2xlLCBuZXcgSGVhZGVyQ29uZmlnKHJvbGUsICdzdGFydCcsIHRydWUsIHJvbGUsIGZhbHNlLCB0cnVlKV0KICAgICAgICAgICAgICAgICkpXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy9zb3J0IHJvbGUgaGVhZGVycwogICAgICAgICAgICByb2xlSGVhZGVycyA9IG5ldyBNYXAoWy4uLnJvbGVIZWFkZXJzXS5zb3J0KCkpOwoKICAgICAgICAgICAgLy9BZGQgZGF0ZSB0byByb2xlcyBpbiBvcmRlciB0byBjb21wYXJlCiAgICAgICAgICAgIHJvbGVIZWFkZXJzLnNldChUQUJMRUZJRUxETUFQUElORy5kYXRlcywgbmV3IEhlYWRlckNvbmZpZygnRGF0ZScsICdzdGFydCcsIHRydWUsIFRBQkxFRklFTERNQVBQSU5HLmRhdGVzLCBmYWxzZSwgdHJ1ZSkpOwoKICAgICAgICAgICAgLy9jb21iaW5lIGV4aXN0aW5nIHByaW1hcnkgaGVhZGVycyB3aXRoIHJvbGUgYW5kIG1hdGNoIHBlcmNlbnRhZ2UgaGVhZGVycwogICAgICAgICAgICB0YWJsZU1hcHBpbmdzLnByaW1hcnlIZWFkZXJzID0gWwogICAgICAgICAgICAgICAgLi4uWy4uLnRhYmxlTWFwcGluZ3MucHJpbWFyeUhlYWRlcnMsIC4uLm5ldyBTZXQoWy4uLnJvbGVIZWFkZXJzLnZhbHVlcygpXSldLAogICAgICAgICAgICAgICAgLi4uW25ldyBIZWFkZXJDb25maWcoJ01hdGNoICUnLCAnZW5kJywgdHJ1ZSwgVEFCTEVGSUVMRE1BUFBJTkcucGVyY2VudGFnZSwgdHJ1ZSwgZmFsc2UpXQogICAgICAgICAgICBdOwoKICAgICAgICAgICAgcmV0dXJuIHRhYmxlTWFwcGluZ3M7CiAgICAgICAgfSwKICAgICAgICBsaW5rVG9FdmFsRG9jU2VhcmNoICgpIHsKICAgICAgICAgICAgd2luZG93Lm9wZW4oJ2h0dHBzOi8vYmxhY2tib3gudmVyZGkubmV4dGNlbnR1cnkuY29tLycsICdfYmxhbmsnKTsKICAgICAgICB9LAogICAgICAgIGxpbmtUb0luY2lkZW50U2VhcmNoICgpIHsKICAgICAgICAgICAgdGhpcy4kcm91dGVyLnB1c2goJy9ldmFsJyk7CiAgICAgICAgfSwKICAgICAgICBhY3RpdmF0ZVNjcm9sbEFycm93KCkgewogICAgICAgICAgICBpZih0aGlzLiRyZWZzW3RoaXMudG9wQW5jaG9yXSkgewogICAgICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLiRyZWZzW3RoaXMudG9wQW5jaG9yXS4kZWw7CiAgICAgICAgICAgICAgICBjb25zdCBzaG93UG9zaXRpb24gPSAxMDA7CiAgICAgICAgICAgICAgICBpZiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPiBzaG93UG9zaXRpb24gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA+IHNob3dQb3NpdGlvbikgewogICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2Nyb2xsVG9FdmVudERldGFpbHMobG9jYXRpb24pIHsKICAgICAgICAgICAgaWYodGhpcy4kcmVmc1t0aGlzLnJlc3VsdHNBbmNob3IgKyBsb2NhdGlvbl0ubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5zY3JvbGxZOwogICAgICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLiRyZWZzW3RoaXMucmVzdWx0c0FuY2hvciArIGxvY2F0aW9uXVswXS4kZWw7CiAgICAgICAgICAgICAgICBjb25zdCB5T2Zmc2V0ID0gLTEwMDsKICAgICAgICAgICAgICAgIGlmIChlbCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgKyB5T2Zmc2V0OwogICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh7dG9wOiB5fSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2Nyb2xsVG9FdmVudFN1bW1hcnkoKSB7CiAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudFBvc2l0aW9uICE9PSB0aGlzLnNjcm9sbFBvc2l0aW9uKSB7CiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbiA9IHdpbmRvdy5zY3JvbGxZOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRQb3NpdGlvbiA9PT0gdGhpcy5zY3JvbGxQb3NpdGlvbikgewogICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IDA7CiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbiA9IG51bGw7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh7IHRvcDogdGhpcy5zY3JvbGxQb3NpdGlvbiB9KTsKICAgICAgICB9LAogICAgICAgIGdldFJlZklkKHR5cGUpIHsKICAgICAgICAgICAgY29uc3QgdGFibGVJZCA9IHRoaXMuc2luQ2x1c3RlcnNCeVNpbklkW3R5cGVdWzBdW1RBQkxFRklFTERNQVBQSU5HLmNsdXN0ZXJMaXN0XVswXVtUQUJMRUZJRUxETUFQUElORy5jbHVzdGVyVXJpXTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c0FuY2hvciArIHRhYmxlSWQ7CiAgICAgICAgfSwKICAgICAgICBnZXREZXRhaWxEYXRhKCkgewogICAgICAgICAgICBpZih0aGlzLmtub3dsZWRnZUJhc2VbREFUQVRZUEVTLnNpbi5pZF0pIHsKICAgICAgICAgICAgICAgIGNvbnN0IHNpbkNsdXN0ZXJzID0gdGhpcy5rbm93bGVkZ2VCYXNlW0RBVEFUWVBFUy5zaW4uaWRdOwogICAgICAgICAgICAgICAgaWYgKHNpbkNsdXN0ZXJzW0RBVEFUWVBFUy5ldmVudFR5cGUuaWRdKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaW5DbHVzdGVyc0J5U2luSWQgPSBzaW5DbHVzdGVyc1tEQVRBVFlQRVMuZXZlbnRUeXBlLmlkXVt0aGlzLnNpbklkXTsKICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlUeXBlcyA9IE9iamVjdC5rZXlzKHRoaXMuc2luQ2x1c3RlcnNCeVNpbklkKS5zb3J0KCk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKHNpbkNsdXN0ZXJzW0RBVEFUWVBFUy5zdW1tYXJ5LmlkXSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyeUl0ZW1zQnlTaW5JZCA9IHNpbkNsdXN0ZXJzW0RBVEFUWVBFUy5zdW1tYXJ5LmlkXS5maWx0ZXIoaXRlbSA9PiBpdGVtLnNpbiA9PT0gdGhpcy5zaW5JZCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VtbWFyeUl0ZW1zQnlTaW5JZDsKICAgICAgICB9LAogICAgICAgIHVwZGF0ZVNlbGVjdGVkU2luSWQoaW5wdXQpIHsKICAgICAgICAgICAgdGhpcy5zaW5JZCA9IGdldEluY2lkZW50SWQoaW5wdXQudGFyZ2V0LnZhbHVlKTsKICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJEYXRhQnlTaW5JZCgpOwogICAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIGZpbHRlckRhdGFCeVNpbklkKCkgewogICAgICAgICAgICBjb25zdCBzaW5EYXRhID0gdGhpcy5rbm93bGVkZ2VCYXNlW0RBVEFUWVBFUy5zaW4uaWRdOwogICAgICAgICAgICBjb25zdCBzaW5DbHVzdGVycyA9IHNpbkRhdGFbREFUQVRZUEVTLmV2ZW50VHlwZS5pZF07CiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzaW5DbHVzdGVycykuaW5jbHVkZXModGhpcy5zaW5JZCkpIHsKICAgICAgICAgICAgICAgIHRoaXMuc2luQ2x1c3RlcnNCeVNpbklkID0gc2luQ2x1c3RlcnNbdGhpcy5zaW5JZF07CiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlJdGVtc0J5U2luSWQgPSBzaW5EYXRhW0RBVEFUWVBFUy5zdW1tYXJ5LmlkXS5maWx0ZXIoaXRlbSA9PiBpdGVtLnNpbiA9PT0gdGhpcy5zaW5JZCk7CiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlUeXBlcyA9IE9iamVjdC5rZXlzKHRoaXMuc2luQ2x1c3RlcnNCeVNpbklkKS5zb3J0KCk7CiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c01lc3NhZ2UgPSBMT0FESU5HTUVTU0FHRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMuc2luQ2x1c3RlcnNCeVNpbklkID0ge307CiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlJdGVtc0J5U2luSWQgPSBbXTsKICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyeVR5cGVzID0gW107CiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c01lc3NhZ2UgPSBOT0RBVEFNRVNTQUdFICsgJyBmb3IgSW5jaWRlbnQ6ICcgKyBnZXRJbmNpZGVudE5hbWUodGhpcy5zaW5JZCk7CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHVwZGF0ZUZvbnRzQW5kQmFja2dyb3VuZHMoaHlwb3RoZXNpcywgdHlwZSwgaWQsIGNvbXBhcmVPbikgewogICAgICAgICAgICBoeXBvdGhlc2lzW1RBQkxFRklFTERNQVBQSU5HLmNvbXBhcmVdID0gY29tcGFyZU9uOwogICAgICAgICAgICBoeXBvdGhlc2lzW1RBQkxFRklFTERNQVBQSU5HLmhpZ2hsaWdodF0gPSBjb21wYXJlT247CgogICAgICAgICAgICBpZiAoIWNvbXBhcmVPbikgewogICAgICAgICAgICAgICAgdGhpcy5yZXNldENvbG9yVGV4dEFuZFBlcmNlbnRhZ2UodHlwZSk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGh5cG90aGVzaXNbVEFCTEVGSUVMRE1BUFBJTkcucGVyY2VudGFnZV0gPSAxMDA7CgogICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBlbnRpdGllcyBvZiByZWZlcmVuY2UgaHlwb3RoZXNpcwogICAgICAgICAgICBjb25zdCByZWZlcmVuY2VFbnRpdGllcyA9IG5ldyBTZXQodGhpcy5nZXRFbnRpdGllcyhoeXBvdGhlc2lzKSk7CiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZVN0cmluZ3MgPSBuZXcgU2V0KHRoaXMuZ2V0RW50aXR5U3RyaW5ncyhoeXBvdGhlc2lzKSk7CiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZURhdGVzID0gbmV3IFNldChoeXBvdGhlc2lzW1RBQkxFRklFTERNQVBQSU5HLmRhdGVzXSk7CgogICAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgb3RoZXIgaHlwb3RoZXNlcyBhbmQgc2V0IGNvbG9yVGV4dCBmb3IgZmFsc2UgcG9zaXRpdmVzCiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVIeXBvdGhlc2VzID0gdGhpcy5zaW5EYXRhW3R5cGVdLmZpbHRlcihoID0+IGhbVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldICE9PSBpZCk7CiAgICAgICAgICAgIGZvcihjb25zdCBjb21wYXJpc29uIG9mIGNvbXBhcmVIeXBvdGhlc2VzKSB7CiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlRW50aXRpZXMgPSBuZXcgU2V0KHRoaXMuZ2V0RW50aXRpZXMoY29tcGFyaXNvbikpOwogICAgICAgICAgICAgICAgY29uc3QgY29tcGFyZVN0cmluZ3MgPSBuZXcgU2V0KHRoaXMuZ2V0RW50aXR5U3RyaW5ncyhjb21wYXJpc29uKSk7CiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlRGF0ZXMgPSBuZXcgU2V0KGNvbXBhcmlzb25bVEFCTEVGSUVMRE1BUFBJTkcuZGF0ZXNdKTsKICAgICAgICAgICAgICAgIGNvbnN0IGFsbEVudGl0aWVzID0gbmV3IFNldChbLi4ucmVmZXJlbmNlRW50aXRpZXMsIC4uLmNvbXBhcmVFbnRpdGllc10pOwogICAgICAgICAgICAgICAgY29uc3QgYWxsRGF0ZXMgPSBuZXcgU2V0KFsuLi5yZWZlcmVuY2VEYXRlcywgLi4uY29tcGFyZURhdGVzXSk7CgogICAgICAgICAgICAgICAgbGV0IGZhbHNlUG9zaXRpdmUgPSAwOwogICAgICAgICAgICAgICAgbGV0IGZhbHNlTmVnYXRpdmUgPSAwOwogICAgICAgICAgICAgICAgbGV0IHRydWVQb3NpdGl2ZSA9IDA7CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRlc3RFbnRpdHkgb2YgYWxsRW50aXRpZXMpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcodGVzdEVudGl0eSk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5SZWYgPSByZWZlcmVuY2VTdHJpbmdzLmhhcyh0ZXN0U3RyaW5nKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBpbkNvbXAgPSBjb21wYXJlU3RyaW5ncy5oYXModGVzdFN0cmluZyk7CgogICAgICAgICAgICAgICAgICAgIGlmIChpblJlZiAhPT0gaW5Db21wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpblJlZikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VOZWdhdGl2ZSsrOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VQb3NpdGl2ZSsrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdEVudGl0eVtUQUJMRUZJRUxETUFQUElORy5jb2xvclRleHRdID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IAogICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIHRydWUgcG9zaXRpdmUKICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVBvc2l0aXZlKys7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGxldCBkYXRlc0NvbXBhcmVkID0gbmV3IE1hcCgpOwogICAgICAgICAgICAgICAgWy4uLmFsbERhdGVzXS5tYXAoZCA9PiBkYXRlc0NvbXBhcmVkLnNldChkLCBkKSk7CgogICAgICAgICAgICAgICAgZm9yKGNvbnN0IHRlc3REYXRlIG9mIGFsbERhdGVzKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5SZWYgPSByZWZlcmVuY2VEYXRlcy5oYXModGVzdERhdGUpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGluQ29tcCA9IGNvbXBhcmVEYXRlcy5oYXModGVzdERhdGUpOwoKICAgICAgICAgICAgICAgICAgICBpZiAoaW5SZWYgIT09IGluQ29tcCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5SZWYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb25seSBleGlzdHMgaW4gdGhlIHNlbGVjdGVkIGh5cG90aGVzaXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlTmVnYXRpdmUrKzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzQ29tcGFyZWQuZGVsZXRlKHRlc3REYXRlKTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb25seSBleGlzdHMgaW4gdGhlIGNvbXBhcmVkIGh5cG90aGVzaXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlUG9zaXRpdmUrKzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzQ29tcGFyZWQuc2V0KHRlc3REYXRlLCB7W1RBQkxFRklFTERNQVBQSU5HLmNvbG9yVGV4dF0gOiB0cnVlLCB0ZXh0IDogdGVzdERhdGV9KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgZXhpc3RzIGluIGJvdGggdGhlIHNlbGVjdGVkIGFuZCBjb21wYXJlZCBoeXBvdGhlc2lzCiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVQb3NpdGl2ZSsrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBjb25zdCBkYXRlcyA9IFsuLi5kYXRlc0NvbXBhcmVkLnZhbHVlcygpXTsKICAgICAgICAgICAgICAgIGlmKGRhdGVzLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uW1RBQkxFRklFTERNQVBQSU5HLmRhdGVzXSA9IGRhdGVzOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGNvbnN0IGYgPSAgdHJ1ZVBvc2l0aXZlIC8gKHRydWVQb3NpdGl2ZSArIC41ICogKGZhbHNlUG9zaXRpdmUgKyBmYWxzZU5lZ2F0aXZlKSk7CiAgICAgICAgICAgICAgICBjb21wYXJpc29uW1RBQkxFRklFTERNQVBQSU5HLnBlcmNlbnRhZ2VdID0gTWF0aC5jZWlsKGYgKiAxMDApOwogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICByZXNldENvbG9yVGV4dEFuZFBlcmNlbnRhZ2UodHlwZSkgewogICAgICAgICAgICBmb3IgKGNvbnN0IGggb2YgdGhpcy5zaW5EYXRhW3R5cGVdKSB7CiAgICAgICAgICAgICAgICBkZWxldGUgaFtUQUJMRUZJRUxETUFQUElORy5wZXJjZW50YWdlXTsKICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZ2V0RW50aXRpZXMoaCkpIHsKICAgICAgICAgICAgICAgICAgICBlbnRpdHlbVEFCTEVGSUVMRE1BUFBJTkcuY29sb3JUZXh0XSA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaFtUQUJMRUZJRUxETUFQUElORy5kYXRlc10gPSBoW1RBQkxFRklFTERNQVBQSU5HLmRhdGVzXS5tYXAoZCA9PiBkLmhhc093blByb3BlcnR5KFRBQkxFRklFTERNQVBQSU5HLmNvbG9yVGV4dCkgPyBkLnRleHQgOiBkKTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZ2V0U3RyaW5nKGUpIHsKICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBlW1RBQkxFRklFTERNQVBQSU5HLnJlc29sdmVkVHlwZV0gPyBlW1RBQkxFRklFTERNQVBQSU5HLnJlc29sdmVkVHlwZV0gOiBlW1RBQkxFRklFTERNQVBQSU5HLnR5cGVzXS5qb2luKCcsJyk7CiAgICAgICAgICAgIHJldHVybiBlW1RBQkxFRklFTERNQVBQSU5HLnJvbGVzXVswXSArICcgLSAnICsgZVtUQUJMRUZJRUxETUFQUElORy5oZWFkbGluZV0gKyAnIC0gJyArIHR5cGVzOwogICAgICAgIH0sCiAgICAgICAgZ2V0RW50aXR5U3RyaW5ncyhoeXBvdGhlc2lzKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVudGl0aWVzKGh5cG90aGVzaXMpLm1hcCh0aGlzLmdldFN0cmluZyk7CiAgICAgICAgfSwKICAgICAgICBnZXRFbnRpdGllcyhoeXBvdGhlc2lzKSB7CiAgICAgICAgICAgIHJldHVybiBoeXBvdGhlc2lzW1RBQkxFRklFTERNQVBQSU5HLmNsdXN0ZXJMaXN0XS5mbGF0TWFwKGMgPT4gY1tUQUJMRUZJRUxETUFQUElORy5lbnRpdHlMaXN0XSk7CiAgICAgICAgfSwKICAgICAgICB1cGRhdGVJdGVtc0ZvckNvbXBhcmlzb24ocm93KSB7CiAgICAgICAgICAgIGxldCBzZWxlY3RlZEh5cG90aGVzaXMgPSB7fTsKICAgICAgICAgICAgbGV0IHJlbW92ZVN0eWxpbmcgPSByb3cuaXRlbVtUQUJMRUZJRUxETUFQUElORy5jb21wYXJlXSA9PT0gdHJ1ZSAmJgogICAgICAgICAgICAgICAgcm93Lml0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldID09PSB0aGlzLmh5cG90aGVzaXNTZWxlY3Rpb25bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldOwogICAgICAgICAgICBmb3IoY29uc3QgY2x1c3RlclR5cGUgaW4gdGhpcy5zaW5EYXRhKSB7CiAgICAgICAgICAgICAgICBpZih0aGlzLnNpbkRhdGEuaGFzT3duUHJvcGVydHkoY2x1c3RlclR5cGUpKSB7CiAgICAgICAgICAgICAgICAgICAgLy9UdXJuIG9mZiBjb21wYXJpc29uIGhpZ2hsaWdodGluZyBmb3IgcHJldmlvdXNseSBzZWxlY3RlZCBoeXBvdGhlc2lzCiAgICAgICAgICAgICAgICAgICAgaWYoT2JqZWN0LmtleXModGhpcy5oeXBvdGhlc2lzU2VsZWN0aW9uKS5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c0h5cG90aGVzaXMgPSB0aGlzLnNpbkRhdGFbY2x1c3RlclR5cGVdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZChoID0+IGhbVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldID09PSB0aGlzLmh5cG90aGVzaXNTZWxlY3Rpb25bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJldmlvdXNIeXBvdGhlc2lzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZvbnRzQW5kQmFja2dyb3VuZHMocHJldmlvdXNIeXBvdGhlc2lzLCBjbHVzdGVyVHlwZSwgdGhpcy5oeXBvdGhlc2lzU2VsZWN0aW9uW1RBQkxFRklFTERNQVBQSU5HLmlkVXJpXSwgZmFsc2UpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBpZighcmVtb3ZlU3R5bGluZykgewogICAgICAgICAgICAgICAgICAgICAgICAvL1R1cm4gb24gY29tcGFyaXNvbiBoaWdobGlnaHRpbmcgZm9yIGN1cnJlbnRseSBzZWxlY3RlZCBoeXBvdGhlc2lzIGFuZCBzYXZlIHRvIHRoZSBzdG9yZQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgaHlwb3RoZXNpcyA9IHRoaXMuc2luRGF0YVtjbHVzdGVyVHlwZV0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKGggPT4gaFtUQUJMRUZJRUxETUFQUElORy5pZFVyaV0gPT09IHJvdy5pdGVtW1RBQkxFRklFTERNQVBQSU5HLmlkVXJpXSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeXBvdGhlc2lzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZvbnRzQW5kQmFja2dyb3VuZHMoaHlwb3RoZXNpcywgY2x1c3RlclR5cGUsIHJvdy5pdGVtW1RBQkxFRklFTERNQVBQSU5HLmlkVXJpXSwgdHJ1ZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsdXN0ZXJUeXBlID09PSByb3cudHlwZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSHlwb3RoZXNpcyA9IGh5cG90aGVzaXM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy51cGRhdGVIeXBvdGhlc2lzU2VsZWN0aW9uKHJlbW92ZVN0eWxpbmcgPyB7fSA6IHNlbGVjdGVkSHlwb3RoZXNpcyk7CiAgICAgICAgfQogICAgfQp9Cg=="},{"version":3,"sources":["IncidentDetail.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"IncidentDetail.vue","sourceRoot":"src/views/eval","sourcesContent":["<!--\n  - Copyright 2019 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n-->\n\n<template>\n    <div>\n        <v-icon :ref=\"topAnchor\"\n                @click=\"scrollToEventSummary()\"\n                title=\"return to Event Summary\"\n                class=\"scroll-top-icon dark-icon-button\"\n        >\n            mdi-arrow-up-bold\n        </v-icon>\n        <div class=\"page-content\">\n            <div class=\"element-list-header\">\n                <div class=\"primary-page-header-left\">Incident Details</div>\n                <div class=\"page-header-right\">\n                    <button id=\"compare_button\" class=\"dark-app-button\" @click=\"linkToIncidentSearch()\">\n                        <v-icon class=\"button-icon\">mdi-compare</v-icon>\n                        Incident Search\n                    </button>\n                    <button id=\"doc_button\" class=\"dark-app-button\" @click=\"linkToEvalDocSearch()\">\n                        <v-icon class=\"button-icon\">mdi-file-document-box-search-outline</v-icon>\n                        Document Search\n                    </button>\n                </div>\n            </div>\n            <div class=\"page-header-element-space\">\n                <SelectDropdown\n                        :options=\"sinIds\"\n                        :selectDisplay=\"selectDisplay\"\n                        :selectedOption=\"sinId\"\n                        @selectDropdownChange=\"updateSelectedSinId($event)\">\n                </SelectDropdown>\n            </div>\n            <div v-if=\"loading===true\" class=\"loading-section\">\n                <v-progress-linear indeterminate></v-progress-linear>\n                <div class=\"loading-message-clear\">{{statusMessage}}</div>\n            </div>\n            <div v-else>\n                <div class=\"section-space\" v-if=\"summaryData\">\n                    <DataTable\n                        :data=\"summaryData\"\n                        :sort=\"sort\"\n                        :loading=\"summaryData === 0\"\n                        :paging=\"paging\"\n                        :tableConfiguration=\"buildSumamryTable()\"\n                        :statusMessage=\"statusMessage\"\n                        :hideFooter=true\n                        :hideHeader=true\n                        @anchorScroll=\"scrollToEventDetails($event)\"\n                    ></DataTable>\n                </div>\n                <div class=\"section-space loading-section\" v-else>\n                    <div class=\"loading-message-clear\">{{statusMessage}}</div>\n                </div>\n                <div v-for=\"(type, index) in types\" :key=\"index\" :class=\"index > 0 ? 'section-space' : ''\">\n                    <DataTable\n                        :ref=\"getRefId(type)\"\n                        :data=\"sinData[type]\"\n                        :sort=\"sort\"\n                        :loading=\"sinData[type] && Object.keys(sinData[type]).length === 0\"\n                        :paging=\"paging\"\n                        :tableConfiguration=\"buildTableConfiguration(type)\"\n                        :statusMessage=\"statusMessage\"\n                        @activateCompare=\"updateItemsForComparison($event)\"\n                        :hideFooter=true\n                        :hideHeader=true\n                    ></DataTable>\n                </div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import DataTable from '@/components/DataTable';\n    import SelectDropdown from '@/components/SelectDropdown';\n    import QuerySubmissionMixin from '@/mixins/QuerySubmissionMixin';\n    import { mapMutations, mapState} from 'vuex';\n    import {\n        TABLESELECTIONS,\n        TABLEFIELDMAPPING,\n        DATATYPES,\n        LOADINGMESSAGE,\n        NODATAMESSAGE,\n        INCIDENTMAPPING,\n        SELECTDISPLAY,\n        PARAMETERNAMES,\n        JOINSTRING,\n        getIncidentName,\n        getIncidentId,\n        TableSettings,\n        HeaderConfig\n    } from '../../utils';\n\n    export default {\n        name: 'IncidentDetail',\n        mixins: [QuerySubmissionMixin],\n        components: {DataTable, SelectDropdown},\n        data: () => ({\n            sort: {[TABLESELECTIONS.sortBy]: TABLEFIELDMAPPING.id, [TABLESELECTIONS.sortDesc]: false},\n            paging: {[TABLESELECTIONS.itemsPerPage]:'All'},\n            statusMessage: '',\n            sinClustersBySinId : {},\n            summaryItemsBySinId: [],\n            summaryTypes: [],\n            sinId: null,\n            selectDisplay: SELECTDISPLAY.input,\n            SIN: {},\n            resultsAnchor: 'event_anchor_',\n            topAnchor: 'summary_anchor',\n            scrollPosition: 0,\n            currentPosition: null\n        }),\n        created() {\n            this.TABLEFIELDMAPPING = TABLEFIELDMAPPING;\n            this.DATATYPES = DATATYPES;\n            this.statusMessage = LOADINGMESSAGE;\n            this.PARAMETERNAMES = PARAMETERNAMES;\n        },\n        mounted() {\n            this.updateHypothesisSelection({});\n            this.sinId = INCIDENTMAPPING[0].id;\n\n            if(Object.keys(this.knowledgeBase).length === 0 || !this.knowledgeBase[DATATYPES.sin.id]) {\n                this.loadSINData(DATATYPES.sin.id);\n            }\n\n            window.onscroll = () => this.activateScrollArrow();\n        },\n        computed: {\n            ...mapState(['defaultHypothesisDataSource', 'hypothesisSelection','currentDataSource', 'knowledgeBase']),\n            summaryData() {\n                return this.summaryItemsBySinId.length > 0  ? this.summaryItemsBySinId : this.getDetailData();\n            },\n            types() {\n                return this.summaryTypes;\n            },\n            sinData() {\n                return this.sinClustersBySinId;\n            },\n            sinIds() {\n                return INCIDENTMAPPING.map(v => v.value);\n            }\n        },\n        methods: {\n            ...mapMutations(['updateHypothesisSelection']),\n            buildSumamryTable() {\n                let tableMappings = {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.id, false, 'Claims Summary', '', false, false, false, false, false, 'headline', false),\n                    primaryHeaders: [\n                        new HeaderConfig('', 'center', false, 'data-table-anchor'),\n                        new HeaderConfig('Events', 'start', true, TABLEFIELDMAPPING.headline, true, false),\n                        new HeaderConfig('', 'start', true, TABLEFIELDMAPPING.nodeCount, true, false),\n                        new HeaderConfig('', 'start', true, TABLEFIELDMAPPING.entityCount, true, false),\n                        new HeaderConfig('', 'start', true, TABLEFIELDMAPPING.id, true, false)\n                    ]\n                };\n\n                return tableMappings;\n            },\n            buildTableConfiguration(type) {\n                const category = this.sinData[type][0][TABLEFIELDMAPPING.sinTitle];\n                let roleHeaders = new Map();\n                let tableMappings = {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.idUri, false, type.split(JOINSTRING)[0], category, false, false, false, false, true, 'headline', false),\n                    primaryHeaders: [\n                        new HeaderConfig('Claim', 'start', true, TABLEFIELDMAPPING.headline, false, false),\n                        new HeaderConfig('Event Statement', 'start', true, TABLEFIELDMAPPING.statement, false, true)\n                    ]\n                };\n\n                for (const hypothesis of this.sinData[type]) {\n                    roleHeaders = new Map([...roleHeaders, ...new Map(hypothesis[TABLEFIELDMAPPING.roles].map(role =>\n                        [role, new HeaderConfig(role, 'start', true, role, false, true)]\n                    ))]);\n                }\n                //sort role headers\n                roleHeaders = new Map([...roleHeaders].sort());\n\n                //Add date to roles in order to compare\n                roleHeaders.set(TABLEFIELDMAPPING.dates, new HeaderConfig('Date', 'start', true, TABLEFIELDMAPPING.dates, false, true));\n\n                //combine existing primary headers with role and match percentage headers\n                tableMappings.primaryHeaders = [\n                    ...[...tableMappings.primaryHeaders, ...new Set([...roleHeaders.values()])],\n                    ...[new HeaderConfig('Match %', 'end', true, TABLEFIELDMAPPING.percentage, true, false)]\n                ];\n\n                return tableMappings;\n            },\n            linkToEvalDocSearch () {\n                window.open('https://blackbox.verdi.nextcentury.com/', '_blank');\n            },\n            linkToIncidentSearch () {\n                this.$router.push('/eval');\n            },\n            activateScrollArrow() {\n                if(this.$refs[this.topAnchor]) {\n                    const el = this.$refs[this.topAnchor].$el;\n                    const showPosition = 100;\n                    if (el) {\n                        if (document.body.scrollTop > showPosition || document.documentElement.scrollTop > showPosition) {\n                            el.style.display = 'block';\n                        } else {\n                            el.style.display = 'none';\n                        }\n                    }\n                }\n            },\n            scrollToEventDetails(location) {\n                if(this.$refs[this.resultsAnchor + location].length > 0) {\n                    this.scrollPosition = window.scrollY;\n                    const el = this.$refs[this.resultsAnchor + location][0].$el;\n                    const yOffset = -100;\n                    if (el) {\n                        const y = el.getBoundingClientRect().top + window.pageYOffset + yOffset;\n                        window.scrollTo({top: y})\n                    }\n                }\n            },\n            scrollToEventSummary() {\n                if(this.currentPosition !== this.scrollPosition) {\n                    this.currentPosition = window.scrollY;\n                }\n\n                if(this.currentPosition === this.scrollPosition) {\n                    this.scrollPosition = 0;\n                    this.currentPosition = null;\n                }\n\n                window.scrollTo({ top: this.scrollPosition });\n            },\n            getRefId(type) {\n                const tableId = this.sinClustersBySinId[type][0][TABLEFIELDMAPPING.clusterList][0][TABLEFIELDMAPPING.clusterUri];\n                return this.resultsAnchor + tableId;\n            },\n            getDetailData() {\n                if(this.knowledgeBase[DATATYPES.sin.id]) {\n                    const sinClusters = this.knowledgeBase[DATATYPES.sin.id];\n                    if (sinClusters[DATATYPES.eventType.id]) {\n                        this.sinClustersBySinId = sinClusters[DATATYPES.eventType.id][this.sinId];\n                        this.summaryTypes = Object.keys(this.sinClustersBySinId).sort();\n                    }\n\n                    if (sinClusters[DATATYPES.summary.id]) {\n                        this.summaryItemsBySinId = sinClusters[DATATYPES.summary.id].filter(item => item.sin === this.sinId);\n                    }\n                }\n                return this.summaryItemsBySinId;\n            },\n            updateSelectedSinId(input) {\n                this.sinId = getIncidentId(input.target.value);\n                this.$nextTick(() => {\n                    this.filterDataBySinId();\n                });\n            },\n            filterDataBySinId() {\n                const sinData = this.knowledgeBase[DATATYPES.sin.id];\n                const sinClusters = sinData[DATATYPES.eventType.id];\n                if (Object.keys(sinClusters).includes(this.sinId)) {\n                    this.sinClustersBySinId = sinClusters[this.sinId];\n                    this.summaryItemsBySinId = sinData[DATATYPES.summary.id].filter(item => item.sin === this.sinId);\n                    this.summaryTypes = Object.keys(this.sinClustersBySinId).sort();\n                    this.statusMessage = LOADINGMESSAGE;\n                }\n                else {\n                    this.sinClustersBySinId = {};\n                    this.summaryItemsBySinId = [];\n                    this.summaryTypes = [];\n                    this.statusMessage = NODATAMESSAGE + ' for Incident: ' + getIncidentName(this.sinId);\n                }\n            },\n            updateFontsAndBackgrounds(hypothesis, type, id, compareOn) {\n                hypothesis[TABLEFIELDMAPPING.compare] = compareOn;\n                hypothesis[TABLEFIELDMAPPING.highlight] = compareOn;\n\n                if (!compareOn) {\n                    this.resetColorTextAndPercentage(type);\n                    return;\n                }\n\n                hypothesis[TABLEFIELDMAPPING.percentage] = 100;\n\n                // collect the entities of reference hypothesis\n                const referenceEntities = new Set(this.getEntities(hypothesis));\n                const referenceStrings = new Set(this.getEntityStrings(hypothesis));\n                const referenceDates = new Set(hypothesis[TABLEFIELDMAPPING.dates]);\n\n                // iterate over other hypotheses and set colorText for false positives\n                const compareHypotheses = this.sinData[type].filter(h => h[TABLEFIELDMAPPING.idUri] !== id);\n                for(const comparison of compareHypotheses) {\n                    const compareEntities = new Set(this.getEntities(comparison));\n                    const compareStrings = new Set(this.getEntityStrings(comparison));\n                    const compareDates = new Set(comparison[TABLEFIELDMAPPING.dates]);\n                    const allEntities = new Set([...referenceEntities, ...compareEntities]);\n                    const allDates = new Set([...referenceDates, ...compareDates]);\n\n                    let falsePositive = 0;\n                    let falseNegative = 0;\n                    let truePositive = 0;\n                    for (const testEntity of allEntities) {\n                        const testString = this.getString(testEntity);\n                        const inRef = referenceStrings.has(testString);\n                        const inComp = compareStrings.has(testString);\n\n                        if (inRef !== inComp) {\n                            if (inRef) {\n                                falseNegative++;\n                            } else {\n                                falsePositive++;\n                                testEntity[TABLEFIELDMAPPING.colorText] = true;\n                            }\n                        } else { \n                            // must be true positive\n                            truePositive++;\n                        }\n                    }\n\n                    let datesCompared = new Map();\n                    [...allDates].map(d => datesCompared.set(d, d));\n\n                    for(const testDate of allDates) {\n                        const inRef = referenceDates.has(testDate);\n                        const inComp = compareDates.has(testDate);\n\n                        if (inRef !== inComp) {\n                            if (inRef) {\n                                //value only exists in the selected hypothesis\n                                falseNegative++;\n                                datesCompared.delete(testDate);\n                            } else {\n                                //value only exists in the compared hypothesis\n                                falsePositive++;\n                                datesCompared.set(testDate, {[TABLEFIELDMAPPING.colorText] : true, text : testDate});\n                            }\n                        } else {\n                            //value exists in both the selected and compared hypothesis\n                            truePositive++;\n                        }\n                    }\n\n                    const dates = [...datesCompared.values()];\n                    if(dates.length > 0) {\n                        comparison[TABLEFIELDMAPPING.dates] = dates;\n                    }\n\n                    const f =  truePositive / (truePositive + .5 * (falsePositive + falseNegative));\n                    comparison[TABLEFIELDMAPPING.percentage] = Math.ceil(f * 100);\n                }\n            },\n            resetColorTextAndPercentage(type) {\n                for (const h of this.sinData[type]) {\n                    delete h[TABLEFIELDMAPPING.percentage];\n                    for (const entity of this.getEntities(h)) {\n                        entity[TABLEFIELDMAPPING.colorText] = false;\n                    }\n                    h[TABLEFIELDMAPPING.dates] = h[TABLEFIELDMAPPING.dates].map(d => d.hasOwnProperty(TABLEFIELDMAPPING.colorText) ? d.text : d);\n                }\n            },\n            getString(e) {\n                const types = e[TABLEFIELDMAPPING.resolvedType] ? e[TABLEFIELDMAPPING.resolvedType] : e[TABLEFIELDMAPPING.types].join(',');\n                return e[TABLEFIELDMAPPING.roles][0] + ' - ' + e[TABLEFIELDMAPPING.headline] + ' - ' + types;\n            },\n            getEntityStrings(hypothesis) {\n                return this.getEntities(hypothesis).map(this.getString);\n            },\n            getEntities(hypothesis) {\n                return hypothesis[TABLEFIELDMAPPING.clusterList].flatMap(c => c[TABLEFIELDMAPPING.entityList]);\n            },\n            updateItemsForComparison(row) {\n                let selectedHypothesis = {};\n                let removeStyling = row.item[TABLEFIELDMAPPING.compare] === true &&\n                    row.item[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri];\n                for(const clusterType in this.sinData) {\n                    if(this.sinData.hasOwnProperty(clusterType)) {\n                        //Turn off comparison highlighting for previously selected hypothesis\n                        if(Object.keys(this.hypothesisSelection).length > 0) {\n                            let previousHypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri]);\n                            if(previousHypothesis) {\n                                this.updateFontsAndBackgrounds(previousHypothesis, clusterType, this.hypothesisSelection[TABLEFIELDMAPPING.idUri], false);\n                            }\n                        }\n\n                        if(!removeStyling) {\n                            //Turn on comparison highlighting for currently selected hypothesis and save to the store\n                            let hypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === row.item[TABLEFIELDMAPPING.idUri]);\n                            if (hypothesis) {\n                                this.updateFontsAndBackgrounds(hypothesis, clusterType, row.item[TABLEFIELDMAPPING.idUri], true);\n\n                                if (clusterType === row.type) {\n                                    selectedHypothesis = hypothesis;\n                                }\n                            }\n                        }\n                    }\n                }\n                this.updateHypothesisSelection(removeStyling ? {} : selectedHypothesis);\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .loading-section {\n        margin: 48px 0;\n    }\n\n    .loading-message-clear {\n        @include flex-row-nowrap;\n        justify-content: center;\n        height: 60px;\n        padding: 16px;\n    }\n\n    .scroll-top-icon{\n        display: none;\n        background-color: $theme-icon-color;\n        position: fixed;\n        bottom: 20px;\n        left: 1%;\n        z-index: 99;\n        font-size: 20px;\n        border: none;\n        outline: none;\n        color: white;\n        cursor: pointer;\n        padding: 10px;\n        border-radius: 4px;\n    }\n\n</style>\n\n"]}]}