{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/components/ClaimFilterController.vue?vue&type=style&index=0&lang=scss&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/components/ClaimFilterController.vue","mtime":1640207172526},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/css-loader/dist/cjs.js","mtime":1641411773021},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1641411774047},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/postcss-loader/src/index.js","mtime":1641411773350},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/sass-loader/dist/cjs.js","mtime":1641411772200},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5tdWx0aS1jbGFpbS1maWx0ZXItaW5wdXQgLnYtY2hpcCAudi1jaGlwX19jb250ZW50IHsKICAgIGRpc3BsYXk6IGlubGluZS1ibG9jayAhaW1wb3J0YW50OwogICAgb3ZlcmZsb3c6IGhpZGRlbjsKICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7CiAgICBkaXJlY3Rpb246IGx0cjsKICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzOwogICAgbGluZS1oZWlnaHQ6IDIuM2VtOwogICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsKfQo="},{"version":3,"sources":["ClaimFilterController.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ClaimFilterController.vue","sourceRoot":"src/components","sourcesContent":["<!--\n  - Copyright 2019 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n  - Created by snordt on 12/7/21\n-->\n\n<template>\n    <div class=\"full-width\">\n        <div v-for=\"(component, cIndex) in Object.keys(componentDisplay)\" :key=\"component + cIndex\">\n            <div v-if=\"component === COMPONENTNAMES.multiSelect\">\n                <div v-for=\"(data, dIndex) in componentDisplay[component]\" :key=\"dIndex\" class=\"pad-horizontally\">\n                    <div class=\"multi-claim-autocomplete-input\">\n                        <MultiSelectAutoComplete class=\"multi-claim-filter-input\"\n                                                 :items=\"data.items\"\n                                                 :required=\"data.required\"\n                                                 :placeholder=\"data.placeholder\"\n                                                 :index=\"dIndex\"\n                                                 :message=\"'No ' + data.messageString +  ' available'\"\n                                                 :showAllChips=false\n                                                 @autoCompleteSubmission=\"updateMultiSelect($event,component, data.id)\"\n                                                 @autoCompleteClear=\"updateMultiSelect($event, component, data.id)\"\n                        ></MultiSelectAutoComplete>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import MultiSelectAutoComplete from '@/components/MultiSelectAutoComplete';\n    import { COMPONENTNAMES, DATATYPES, PARAMETERNAMES, arraysMatch } from '../utils';\n    import API from '../api';\n    import { mapActions, mapGetters, mapMutations, mapState } from 'vuex';\n    import RouteParametersMixin from '@/mixins/RouteParametersMixin';\n\n    class ComponentData {\n        constructor(id, items, placeholder, messageString, required) {\n            this.id = id;\n            this.items = items;\n            this.placeholder = placeholder;\n            this.messageString = messageString;\n            this.required = required;\n        }\n    }\n\n    function initialState() {\n        return {\n            displayData: [], //MultiSelect : [{id:'', items:[], placeholder:'', messageString: '', required: ''}]\n            responseData: [],\n            filterTypes: []\n        }\n    }\n\n    export default {\n        name: 'ClaimFilterController',\n        components: {MultiSelectAutoComplete},\n        mixins: [RouteParametersMixin],\n        data: () => (initialState()),\n        created() {\n            this.COMPONENTNAMES  = COMPONENTNAMES;\n            this.DATATYPES = DATATYPES;\n        },\n        mounted() {\n            this.resetQueryForm();\n        },\n        computed: {\n            ...mapState(['filterReset', 'filters']),\n            ...mapGetters(['getFilterByType', 'getFilterKeys']),\n            componentDisplay() {\n                if(this.filterReset) {\n                    this.resetQueryForm();\n                }\n                return this.displayData;\n            }\n        },\n        methods: {\n            ...mapMutations(['updateFilterReset', 'updateFilterSubmission']),\n            ...mapActions(['updateFilters', 'removeFilter']),\n            updateMultiSelect(values, componentName, filterType) {\n                //update displayData with selected values\n                if(values.length > 0) {\n                    let selectedData = [];\n\n                    //find the data that matches the selected values\n                    for (const value of values) {\n                        selectedData = [...selectedData, ...this.responseData.filter(d => d[filterType] === value)];\n                    }\n\n                    for (const type of this.filterTypes) {\n                        //This code allows for updating the options for all other select components when one component is updated\n                        if(type !== filterType) {\n                            let filterIndex = this.displayData[componentName].findIndex(d => d.id === type);\n                            //create a deep clone of the displayData for this type and collect unique values from the selected data\n                            let selectedObject = {...this.displayData[componentName].find(d => d.id === type)};\n                            selectedObject.items = [...new Set(selectedData.map(d => d[type]))];\n\n                            //If the component items do not match the selectedData items, update the component items with the selectedData values\n                            if(!arraysMatch(this.displayData[componentName][filterIndex].items, selectedObject.items)) {\n                                this.displayData[componentName][filterIndex].items = selectedObject.items;\n                            }\n\n                            //the component items should all be valid based on the selectedData. If they are not update filters with only the valid component items\n                            const typeFilterExists = this.getFilterKeys.find(k => k === type);\n                            if(typeFilterExists) {\n                                if(!arraysMatch(this.filters[type], selectedObject.items)) {\n                                    const diffValues = this.filters[type].filter(element => !selectedObject.items.includes(element));\n                                    if(diffValues.length === 0) {\n                                        this.updateFilters({type: type, filter: selectedObject.items});\n                                    }\n                                    else {\n                                        const validValues = this.filters[type].filter(element => !diffValues.includes(element));\n                                        this.updateFilters({type: type, filter: validValues});\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            //update the filter values for the current component selections\n                            this.updateFilters({type: type, filter: values});\n                        }\n                    }\n                }\n                else {\n                    const existingFilters = this.getFilterKeys.filter(k => k !== filterType);\n                    for (const type of this.filterTypes) {\n                         if (type !== filterType) {\n                             let filterIndex = this.displayData[componentName].findIndex(d => d.id === type);\n                             //create a deep clone of the displayData for this type and collect unique values from the original data\n                             let responseObject = {...this.displayData[componentName].find(d => d.id === type)};\n                             responseObject.items = [...new Set(this.responseData.map(d => d[type]))];\n                             //If the component items do not match the original items, update the component items with the original values\n                             if (!existingFilters && !arraysMatch(this.displayData[componentName][filterIndex].items, responseObject.items)) {\n                                 this.displayData[componentName][filterIndex].items = responseObject.items;\n                             }\n                         } else if (this.getFilterByType(type) && this.getFilterByType(type).length > 0) {\n                             this.removeFilter({type: type});\n                         }\n                    }\n                }\n            },\n            resetQueryForm() {\n                //fetch the query values for all claim frames\n                Object.assign(this.$data, initialState());\n                this.filterTypes = [DATATYPES.topic.id, DATATYPES.subtopic.id];\n                this.getFilterValues();\n\n                //update the store variables in order to remove the filters\n                for (const filter of this.filterTypes) {\n                    this.removeFilter({type: filter});\n                }\n                this.updateFilterReset(false);\n                this.updateFilterSubmission(true);\n                this.updateRouteParams(PARAMETERNAMES.filter);\n            },\n            getFilterValues() {\n                //As more components get added, this code will need to change in order to support API requests for the various components.\n                const componentName = COMPONENTNAMES.multiSelect;\n                API.getClaimFrameFilterValues().then(response => {\n                    if (response.data.length > 0) {\n                        this.displayData = {[componentName] : []};\n                        this.responseData = response.data;\n                        for (const type of [DATATYPES.topic, DATATYPES.subtopic]) {\n                            //remove duplicate values by creating a new set\n                            this.displayData[componentName].push(\n                                new ComponentData(\n                                    type.id,\n                                    [...new Set(response.data.map(k => k[type.id]))],\n                                    type.display,\n                                    type.display.toLowerCase(),\n                                    false\n                                )\n                            )\n                        }\n                    }\n                    else {\n                        this.displayData = [];\n                    }\n                }).catch((error) => {\n                    console.warn(error)\n                });\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\">\n    .multi-claim-filter-input .v-chip .v-chip__content {\n        display: inline-block !important;\n        overflow: hidden;\n        white-space: nowrap;\n        direction: ltr;\n        text-overflow: ellipsis;\n        line-height: 2.3em;\n        vertical-align: middle;\n    }\n</style>\n"]}]}