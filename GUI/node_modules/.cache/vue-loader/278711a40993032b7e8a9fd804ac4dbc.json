{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/IncidentSearch.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/IncidentSearch.vue","mtime":1640207172536},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/babel-loader/lib/index.js","mtime":1641411773354},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBNdWx0aVNlbGVjdEF1dG9Db21wbGV0ZSBmcm9tICdAL2NvbXBvbmVudHMvTXVsdGlTZWxlY3RBdXRvQ29tcGxldGUnOwppbXBvcnQgQ2xhaW1zIGZyb20gJ0Avdmlld3MvYW5hbHl6ZS9DbGFpbXMnOwppbXBvcnQge21hcE11dGF0aW9uc30gZnJvbSAndnVleCc7CmltcG9ydCB7CiAgICBTRUFSQ0hUWVBFUywKICAgIElOQ0lERU5UTUFQUElORywKICAgIGdldFR5cGUsCiAgICBnZXRSb2xlLAogICAgY2xlYW5OYW1lLAogICAgc29ydENhc2VJbnNlbnNpdGl2ZQp9IGZyb20gJy4uLy4uL3V0aWxzJzsKaW1wb3J0IEFQSSBmcm9tICcuLi8uLi9hcGknOwoKLy9jb25zdCBjdXJyZW50UmVxdWVzdHMgPSBuZXcgTWFwKCk7CmNvbnN0IENMQUlNRklMVEVSUyA9IHsKICAgIGV2ZW50OiAnZXZlbnRGaWx0ZXInLAogICAgZW50aXR5OiAnZW50aXR5RmlsdGVyJywKICAgIHJvbGU6ICdyb2xlRmlsdGVyJwp9OwoKY2xhc3MgVmlldyB7CiAgICBjb25zdHJ1Y3RvciAodHlwZSwgZGlzYWJsZWQpIHsKICAgICAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDsKICAgIH0KfQoKIGNsYXNzIEZpbHRlciB7CiAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgIHRoaXMuZW50aXR5SWRzID0gW107CiAgICAgICAgIHRoaXMuZXZlbnRUeXBlcyA9IFtdOwogICAgICAgICB0aGlzLnJvbGVzID0gW107CiAgICAgfQogfQoKY2xhc3MgUXVlcnlWYWx1ZXMgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgdGhpc1tDTEFJTUZJTFRFUlMuZW50aXR5XSA9IHt9OwogICAgICAgIHRoaXNbQ0xBSU1GSUxURVJTLmV2ZW50XSA9IHt9OwogICAgICAgIHRoaXNbQ0xBSU1GSUxURVJTLnJvbGVdID0ge307CiAgICB9Cn0KCmZ1bmN0aW9uIGluaXRpYWxTdGF0ZSgpIHsKICAgIHJldHVybiB7CiAgICAgICAgY2xhaW1GaWx0ZXJzOiB7fSwKICAgICAgICBmb3JtYXR0ZWRGaWx0ZXJzOiBbXSwKICAgICAgICBxdWVyeUV2ZW50VHlwZXMgOiB7fSwKICAgICAgICBxdWVyeU5hbWVkRW50aXRpZXM6IHt9LAogICAgICAgIHF1ZXJ5Um9sZXM6IHt9LAogICAgICAgIGFsbFF1ZXJ5VmFsdWVzOiB7fSwKICAgICAgICByZXN1bHRzQW5jaG9yOiAnY2xhaW1fcmVzdWx0cycsCiAgICAgICAgdmlld3M6IHsKICAgICAgICAgICAgcmVzZXRRdWVyeTogbmV3IFZpZXcoJ3Jlc2V0UXVlcnknLCBmYWxzZSksCiAgICAgICAgICAgIGNsYWltUmVzdWx0czogbmV3IFZpZXcoJ2NsYWltUmVzdWx0cycsIHRydWUpCiAgICAgICAgfQogICAgfQp9CmV4cG9ydCBkZWZhdWx0IHsKICAgIG5hbWU6ICdJbmNpZGVudFNlYXJjaCcsCiAgICBjb21wb25lbnRzOiB7Q2xhaW1zLCBNdWx0aVNlbGVjdEF1dG9Db21wbGV0ZX0sCiAgICBkYXRhOiAoKSA9PiAoaW5pdGlhbFN0YXRlKCkpLAogICAgY3JlYXRlZCgpIHsKICAgICAgICB0aGlzLkNMQUlNRklMVEVSUyA9IENMQUlNRklMVEVSUzsKICAgICAgICB0aGlzLlNFQVJDSFRZUEVTID0gU0VBUkNIVFlQRVM7CiAgICAgICAgdGhpcy5JTkNJREVOVE1BUFBJTkcgPSBJTkNJREVOVE1BUFBJTkc7CiAgICB9LAogICAgbW91bnRlZCgpIHsKICAgICAgICB3aW5kb3cuc2Nyb2xsKHsKICAgICAgICAgICAgdG9wOiAwLAogICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCcKICAgICAgICB9KTsKICAgICAgICB0aGlzLnJlc2V0UXVlcnlGb3JtKCk7CiAgICB9LAogICAgY29tcHV0ZWQ6IHsKICAgICAgIGV2ZW50VHlwZXMoKSB7CiAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJldHR5TGFiZWxzKHRoaXMucXVlcnlFdmVudFR5cGVzKTsKICAgICAgIH0sCiAgICAgICAgbmFtZWRFbnRpdGllcygpIHsKICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcmV0dHlMYWJlbHModGhpcy5xdWVyeU5hbWVkRW50aXRpZXMpOwogICAgICAgIH0sCiAgICAgICAgcm9sZXMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByZXR0eUxhYmVscyh0aGlzLnF1ZXJ5Um9sZXMpOwogICAgICAgIH0sCiAgICAgICAgZm9ybWF0dGVkQ2xhaW1zKCkgewogICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZEZpbHRlcnM7CiAgICAgICAgfSwKICAgICAgICBzaW5JZHMoKSB7CiAgICAgICAgICAgIHJldHVybiBJTkNJREVOVE1BUFBJTkcubWFwKHYgPT4gdi5pZCk7CiAgICAgICAgfQogICAgfSwKICAgIG1ldGhvZHM6IHsKICAgICAgICAuLi5tYXBNdXRhdGlvbnMoWyd1cGRhdGVTaW5TZWxlY3Rpb24nXSksCiAgICAgICAgbGlua1RvRXZhbERvY1NlYXJjaCAoKSB7CiAgICAgICAgICAgIHdpbmRvdy5vcGVuKCdodHRwczovL2JsYWNrYm94LnZlcmRpLm5leHRjZW50dXJ5LmNvbS8nLCAnX2JsYW5rJyk7CiAgICAgICAgfSwKICAgICAgICBsaW5rVG9JbmNpZGVudERldGFpbHMgKCkgewogICAgICAgICAgICB0aGlzLiRyb3V0ZXIucHVzaCgnL2V2YWwvaW5jaWRlbnRfZGV0YWlsJyk7CiAgICAgICAgfSwKICAgICAgICBjb21wbGV0ZWRTZWFyY2godmFsdWUpIHsKICAgICAgICAgICAgdGhpcy4kcmVmcy5zZWFyY2hCdXR0b24uZGlzYWJsZWQgPSAhdmFsdWUKICAgICAgICB9LAogICAgICAgIGdldFByZXR0eUxhYmVscyhpdGVtcykgewogICAgICAgICAgICAvL3JlbW92ZSBkdXBsaWNhdGVzIGFuZCBzb3J0CiAgICAgICAgICAgcmV0dXJuICBPYmplY3Qua2V5cyhpdGVtcykgPyBzb3J0Q2FzZUluc2Vuc2l0aXZlKFsuLi5PYmplY3Qua2V5cyhpdGVtcyldKSA6IGl0ZW1zOwogICAgICAgIH0sCiAgICAgICAgc2Nyb2xsVG9SZXN1bHRzKCkgewogICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuJHJlZnNbdGhpcy5yZXN1bHRzQW5jaG9yXS4kZWw7CiAgICAgICAgICAgICAgICBpZihlbCkgewogICAgICAgICAgICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KHsgdG9wOiAncG9zaXRpb24nLCBiZWhhdmlvcjogJ3Ntb290aCcgfSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBzZXRDbGFpbUZpbHRlcnMoa2V5cywgcXVlcnlTZXQsIGZpbHRlcikgewogICAgICAgICAgICBsZXQgZmlsdGVycyA9IFtdOwogICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7CiAgICAgICAgICAgICAgICBjb25zdCBVUklzID0gdGhpc1txdWVyeVNldF1ba2V5XSA/IHRoaXNbcXVlcnlTZXRdW2tleV0gOiBbXTsKICAgICAgICAgICAgICAgIGZpbHRlcnMgPSBbLi4uZmlsdGVycywgLi4uVVJJc107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5jbGFpbUZpbHRlcnNbZmlsdGVyXSA9IFsuLi5uZXcgU2V0KGZpbHRlcnMpXTsKICAgICAgICB9LAogICAgICAgIHVwZGF0ZUV2ZW50VHlwZXModHlwZXMpIHsKICAgICAgICAgICAgdGhpcy5jbGFpbUZpbHRlcnMuZXZlbnRUeXBlcyA9IFtdOwogICAgICAgICAgICBpZih0eXBlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICB0aGlzLnNldENsYWltRmlsdGVycyh0eXBlcywgJ3F1ZXJ5RXZlbnRUeXBlcycsICdldmVudFR5cGVzJyk7CiAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHlJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5lbnRpdHlJZHMuZmxhdE1hcChlbnRpdHkgPT4gZW50aXR5LmlkcykpXTsKICAgICAgICAgICAgICAgIGNvbnN0IHJvbGVJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5yb2xlcy5mbGF0TWFwKHJvbGUgPT4gcm9sZS5pZHMpKV07CiAgICAgICAgICAgICAgICBjb25zdCBldmVudFR5cGVJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5ldmVudFR5cGVzLmZsYXRNYXAoZSA9PiBlLmlkcykpXTsKICAgICAgICAgICAgICAgIC8vdXBkYXRlIHJvbGVzIGFuZCBuYW1lcyBmb3IgdGhlIGNsYWltRmlsdGVyIGlmIHRoZXkgZG9uJ3QgaGF2ZSBzZWxlY3RlZCB2YWx1ZXMgYWxyZWFkeQogICAgICAgICAgICAgICAgaWYodGhpcy5jbGFpbUZpbHRlcnMucm9sZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRSb2xlcyhldmVudFR5cGVJZHMsIGVudGl0eUlkcyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZih0aGlzLmNsYWltRmlsdGVycy5lbnRpdHlJZHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFbnRpdHlOYW1lcyhldmVudFR5cGVJZHMsIHJvbGVJZHMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgLy9ubyB0eXBlIGZpbHRlcnMgc3VibWl0dGVkLCByZXNldCByb2xlcyBhbmQgbmFtZXMKICAgICAgICAgICAgICAgIHRoaXMuZ2V0Um9sZXMoKTsKICAgICAgICAgICAgICAgIHRoaXMuZ2V0RW50aXR5TmFtZXMoKTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgdXBkYXRlUm9sZXMocm9sZXMpIHsKICAgICAgICAgICAgdGhpcy5jbGFpbUZpbHRlcnMucm9sZXMgPSBbXTsKICAgICAgICAgICAgaWYocm9sZXMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgdGhpcy5zZXRDbGFpbUZpbHRlcnMocm9sZXMsICdxdWVyeVJvbGVzJywgJ3JvbGVzJyk7CiAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHlJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5lbnRpdHlJZHMuZmxhdE1hcChlbnRpdHkgPT4gZW50aXR5LmlkcykpXTsKICAgICAgICAgICAgICAgIGNvbnN0IHJvbGVJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5yb2xlcy5mbGF0TWFwKHJvbGUgPT4gcm9sZS5pZHMpKV07CiAgICAgICAgICAgICAgICBjb25zdCBldmVudFR5cGVJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5ldmVudFR5cGVzLmZsYXRNYXAoZSA9PiBlLmlkcykpXTsKCiAgICAgICAgICAgICAgICAvL3VwZGF0ZSBldmVudCB0eXBlcyBhbmQgbmFtZXMgZm9yIHRoZSBjbGFpbUZpbHRlciBpZiB0aGV5IGRvbid0IGhhdmUgc2VsZWN0ZWQgdmFsdWVzIGFscmVhZHkKICAgICAgICAgICAgICAgIGlmKHRoaXMuY2xhaW1GaWx0ZXJzLmV2ZW50VHlwZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFdmVudFR5cGVzKHJvbGVJZHMsIGVudGl0eUlkcyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZih0aGlzLmNsYWltRmlsdGVycy5lbnRpdHlJZHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFbnRpdHlOYW1lcyhldmVudFR5cGVJZHMsIHJvbGVJZHMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgLy9ubyB0eXBlIGZpbHRlcnMgc3VibWl0dGVkLCByZXNldCBldmVudCB0eXBlcyBhbmQgbmFtZXMKICAgICAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRUeXBlcygpOwogICAgICAgICAgICAgICAgdGhpcy5nZXRFbnRpdHlOYW1lcygpOwogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB1cGRhdGVFbnRpdHlOYW1lcyhuYW1lcykgewogICAgICAgICAgICB0aGlzLmNsYWltRmlsdGVycy5lbnRpdHlJZHMgPSBbXTsKICAgICAgICAgICAgaWYobmFtZXMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgLy9XaGVuIGV2ZW50cyBjaGFuZ2UsIGNsZWFyIGZpbHRlcnMgYW5kIGFkZCBuZXcgb25lcwogICAgICAgICAgICAgICAgdGhpcy5zZXRDbGFpbUZpbHRlcnMobmFtZXMsICdxdWVyeU5hbWVkRW50aXRpZXMnLCAnZW50aXR5SWRzJyk7CiAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHlJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5lbnRpdHlJZHMuZmxhdE1hcChlbnRpdHkgPT4gZW50aXR5LmlkcykpXTsKICAgICAgICAgICAgICAgIGNvbnN0IHJvbGVJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5yb2xlcy5mbGF0TWFwKHJvbGUgPT4gcm9sZS5pZHMpKV07CiAgICAgICAgICAgICAgICBjb25zdCBldmVudFR5cGVJZHMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5ldmVudFR5cGVzLmZsYXRNYXAoZSA9PiBlLmlkcykpXTsKCiAgICAgICAgICAgICAgICAvL3VwZGF0ZSBldmVudCB0eXBlcyBhbmQgcm9sZXMgZm9yIHRoZSBjbGFpbUZpbHRlciBpZiB0aGV5IGRvbid0IGhhdmUgc2VsZWN0ZWQgdmFsdWVzIGFscmVhZHkKICAgICAgICAgICAgICAgIGlmKHRoaXMuY2xhaW1GaWx0ZXJzLmV2ZW50VHlwZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFdmVudFR5cGVzKHJvbGVJZHMsICBlbnRpdHlJZHMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYodGhpcy5jbGFpbUZpbHRlcnMucm9sZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRSb2xlcyhldmVudFR5cGVJZHMsIGVudGl0eUlkcyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAvL25vIHR5cGUgZmlsdGVycyBzdWJtaXR0ZWQsIHJlc2V0IGV2ZW50IHR5cGVzIGFuZCByb2xlCiAgICAgICAgICAgICAgICB0aGlzLmdldEV2ZW50VHlwZXMoKTsKICAgICAgICAgICAgICAgIHRoaXMuZ2V0Um9sZXMoKTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZ2V0RXZlbnRUeXBlcyhyb2xlcyA9IFtdLCBpZHMgPSBbXSkgewogICAgICAgICAgICBjb25zdCBub0ZpbHRlcnMgPSByb2xlcy5sZW5ndGggPT09IDAgJiYgaWRzLmxlbmd0aCA9PT0gMDsKICAgICAgICAgICAgLy9ObyBuZWVkIHRvIHJlLXJ1biBBUEkgZm9yIHRoZSBvcmlnaW5hbCBxdWVyeSB2YWx1ZXMKICAgICAgICAgICAgaWYoT2JqZWN0LmtleXModGhpcy5hbGxRdWVyeVZhbHVlc1tDTEFJTUZJTFRFUlMuZXZlbnRdKS5sZW5ndGggPiAwICYmIG5vRmlsdGVycykgewogICAgICAgICAgICAgICAgdGhpcy5xdWVyeUV2ZW50VHlwZXMgPSB0aGlzLmFsbFF1ZXJ5VmFsdWVzW0NMQUlNRklMVEVSUy5ldmVudF07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBBUEkuZ2V0QWxsU2luRXZlbnRUeXBlcyhyb2xlcywgaWRzKS50aGVuKHJlc3BvbnNlID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vZXZlbnQgdHlwZSBrZXlzIGFyZSB0aGUgY2xlYW4gZXZlbnQgdHlwZXMgd2l0aCBVUkkgcmVtb3ZlZAogICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZXMgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHJlc3BvbnNlLmRhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVHlwZSA9IGdldFR5cGUodHlwZSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlSWRPYmplY3QgPSB7dHlwZTogdHJhbnNmb3JtZWRUeXBlLCBpZHM6IHR5cGV9OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVzLmhhc093blByb3BlcnR5KHRyYW5zZm9ybWVkVHlwZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1t0cmFuc2Zvcm1lZFR5cGVdID0gWy4uLnR5cGVzW3RyYW5zZm9ybWVkVHlwZV0sIHR5cGVJZE9iamVjdF07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1t0cmFuc2Zvcm1lZFR5cGVdID0gW3R5cGVJZE9iamVjdF07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBhcmUgbm8gZmlsdGVycyBhbmQgdGhlIG9yaWdpbmFsIHF1ZXJ5IHZhbHVlcyBoYXZlbid0IGJlZW4gc2V0LCBzZXQgYWxsUXVlcnlWYWx1ZXMKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vRmlsdGVycykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxRdWVyeVZhbHVlc1tDTEFJTUZJTFRFUlMuZXZlbnRdID0gdHlwZXM7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnlFdmVudFR5cGVzID0gdHlwZXM7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5RXZlbnRUeXBlcyA9IHt9OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4gewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcikKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBnZXRSb2xlcyhldmVudFR5cGVzID0gW10sIGlkcyA9IFtdKSB7CiAgICAgICAgICAgIGNvbnN0IG5vRmlsdGVycyA9IGV2ZW50VHlwZXMubGVuZ3RoID09PSAwICYmIGlkcy5sZW5ndGggPT09IDA7CiAgICAgICAgICAgIC8vTm8gbmVlZCB0byByZS1ydW4gQVBJIGZvciB0aGUgb3JpZ2luYWwgcXVlcnkgdmFsdWVzCiAgICAgICAgICAgIGlmKE9iamVjdC5rZXlzKHRoaXMuYWxsUXVlcnlWYWx1ZXNbQ0xBSU1GSUxURVJTLnJvbGVdKS5sZW5ndGggPiAwICYmIG5vRmlsdGVycykgewogICAgICAgICAgICAgICAgdGhpcy5xdWVyeVJvbGVzID0gdGhpcy5hbGxRdWVyeVZhbHVlc1tDTEFJTUZJTFRFUlMucm9sZV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBBUEkuZ2V0QWxsU2luUm9sZXMoZXZlbnRUeXBlcywgaWRzKS50aGVuKHJlc3BvbnNlID0+IHsKICAgICAgICAgICAgICAgICAgICBpZihyZXNwb25zZS5kYXRhLmxlbmd0aCA+IDAgKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vcm9sZSBVUklzIHdpbGwgYmUgZ3JvdXBlZCBieSB0aGUgdHJ1bmNhdGVkIHJvbGUgbmFtZQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgcm9sZXMgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIHJlc3BvbnNlLmRhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRydW5jUm9sZSA9IGdldFJvbGUoZCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb2xlSWRPYmplY3QgPSB7cm9sZTogdHJ1bmNSb2xlLCBpZHM6IGR9OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocm9sZXMuaGFzT3duUHJvcGVydHkodHJ1bmNSb2xlKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGVzW3RydW5jUm9sZV0gPSBbLi4ucm9sZXNbdHJ1bmNSb2xlXSwgcm9sZUlkT2JqZWN0XTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGVzW3RydW5jUm9sZV0gPSBbcm9sZUlkT2JqZWN0XTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGFyZSBubyBmaWx0ZXJzIGFuZCB0aGUgb3JpZ2luYWwgcXVlcnkgdmFsdWVzIGhhdmVuJ3QgYmVlbiBzZXQsIHNldCBhbGxRdWVyeVZhbHVlcwogICAgICAgICAgICAgICAgICAgICAgICBpZihub0ZpbHRlcnMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsUXVlcnlWYWx1ZXNbQ0xBSU1GSUxURVJTLnJvbGVdID0gcm9sZXM7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeVJvbGVzID0gcm9sZXM7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5Um9sZXMgPSB7fTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZ2V0RW50aXR5TmFtZXMoZXZlbnRUeXBlcyA9IFtdLCByb2xlcyA9IFtdKSB7CiAgICAgICAgICAgIGNvbnN0IG5vRmlsdGVycyA9IHJvbGVzLmxlbmd0aCA9PT0gMCAmJiBldmVudFR5cGVzLmxlbmd0aCA9PT0gMDsKICAgICAgICAgICAgLy9ObyBuZWVkIHRvIHJlLXJ1biBBUEkgZm9yIHRoZSBvcmlnaW5hbCBxdWVyeSB2YWx1ZXMKICAgICAgICAgICAgaWYoT2JqZWN0LmtleXModGhpcy5hbGxRdWVyeVZhbHVlc1tDTEFJTUZJTFRFUlMuZW50aXR5XSkubGVuZ3RoID4gMCAmJiBub0ZpbHRlcnMpIHsKICAgICAgICAgICAgICAgIHRoaXMucXVlcnlOYW1lZEVudGl0aWVzID0gdGhpcy5hbGxRdWVyeVZhbHVlc1tDTEFJTUZJTFRFUlMuZW50aXR5XTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIC8vZXZlbnQgdHlwZXMgYW5kIHJvbGVzIG5lZWQgdG8gYmUgY2xlYW5lZCB1cCBmb3IgdGhlIEVsYXN0aWNTZWFyY2ggQVBJCiAgICAgICAgICAgICAgICBjb25zdCBlc0V2ZW50VHlwZXMgPSBldmVudFR5cGVzLm1hcCh0ID0+IGdldFR5cGUodCkpOwogICAgICAgICAgICAgICAgY29uc3QgZXNSb2xlcyA9IHJvbGVzLm1hcChyID0+IGdldFJvbGUocikpOwogICAgICAgICAgICAgICAgQVBJLmdldEFsbFNpbk5hbWVzKGVzRXZlbnRUeXBlcywgZXNSb2xlcykudGhlbihyZXNwb25zZSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAvL25hbWUga2V5cyBhcmUgdGhlIGFjdHVhbCBuYW1lIHdoaWxlIHRoZQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZXMgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHJlc3BvbnNlLmRhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2xlYW4gbmFtZSBpbiBvcmRlciB0byBzb3J0IGZvciBtdWx0aS1zZWxlY3QgYXV0b2NvbXBsZXRlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxOYW1lID0gY2xlYW5OYW1lKG5hbWUuaWQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZUlkT2JqZWN0ID0ge25hbWU6IG5hbWUuaWQsIGlkczogbmFtZS5lbnRpdGllc307CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXMuaGFzT3duUHJvcGVydHkoY2Fub25pY2FsTmFtZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL05vIGxvbmdlciB1c2luZyBlbnRpdHlJZHMsIG5hbWVzW2Nhbm9uaWNhbE5hbWVdID0gWy4uLm5ldyBTZXQoWy4uLm5hbWVzW2Nhbm9uaWNhbE5hbWVdLCAuLi5uYW1lLmVudGl0aWVzXSldOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzW2Nhbm9uaWNhbE5hbWVdID0gWy4uLm5hbWVzW2Nhbm9uaWNhbE5hbWVdLCBuYW1lSWRPYmplY3RdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL05vIGxvbmdlciB1c2luZyBlbnRpdHlJZHMsIC0gbmFtZXNbY2Fub25pY2FsTmFtZV0gPSBuYW1lLmVudGl0aWVzOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzW2Nhbm9uaWNhbE5hbWVdID0gW25hbWVJZE9iamVjdF07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUgYXJlIG5vIGZpbHRlcnMgYW5kIHRoZSBvcmlnaW5hbCBxdWVyeSB2YWx1ZXMgaGF2ZW4ndCBiZWVuIHNldCwgc2V0IGFsbFF1ZXJ5VmFsdWVzCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub0ZpbHRlcnMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsUXVlcnlWYWx1ZXNbQ0xBSU1GSUxURVJTLmVudGl0eV0gPSBuYW1lczsKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeU5hbWVkRW50aXRpZXMgPSBuYW1lczsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnlOYW1lZEVudGl0aWVzID0ge307CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHVwZGF0ZVNlYXJjaEZvcm0odmlld1R5cGUpIHsKICAgICAgICAgICAgaWYodmlld1R5cGUgPT09IHRoaXMudmlld3MucmVzZXRRdWVyeS50eXBlKSB7CiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuJGRhdGEsIGluaXRpYWxTdGF0ZSgpKTsKICAgICAgICAgICAgICAgIHRoaXMucmVzZXRRdWVyeUZvcm0oKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmKHZpZXdUeXBlID09PSB0aGlzLnZpZXdzLmNsYWltUmVzdWx0cy50eXBlKSB7CiAgICAgICAgICAgICAgICB0aGlzLnZpZXdzW3ZpZXdUeXBlXS5kaXNhYmxlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWRGaWx0ZXJzID0gdGhpcy5mb3JtYXRDbGFpbUZpbHRlcnMoKTsKICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9SZXN1bHRzKCk7CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHJlc2V0UXVlcnlGb3JtKCkgewogICAgICAgICAgICB0aGlzLmNsYWltRmlsdGVycyA9IG5ldyBGaWx0ZXIoKTsKICAgICAgICAgICAgdGhpcy5hbGxRdWVyeVZhbHVlcyA9IG5ldyBRdWVyeVZhbHVlcygpOwoKICAgICAgICAgICAgLy9mZXRjaCB0aGUgcXVlcnkgdmFsdWVzIGZvciBhbGwgU0lOcy9JbmNpZGVudHMKICAgICAgICAgICAgdGhpcy5nZXRFdmVudFR5cGVzKCk7CiAgICAgICAgICAgIHRoaXMuZ2V0Um9sZXMoKTsKICAgICAgICAgICAgdGhpcy5nZXRFbnRpdHlOYW1lcygpOwogICAgICAgIH0sCiAgICAgICAgZm9ybWF0Q2xhaW1GaWx0ZXJzKCkgewogICAgICAgICAgICBsZXQgZm9ybWF0dGVkRmlsdGVycyA9IFtdOwogICAgICAgICAgICAvL2V2ZW50IHR5cGUgZmlsdGVycyB3ZXJlIHN1Ym1pdHRlZAogICAgICAgICAgICBpZih0aGlzLmNsYWltRmlsdGVycy5ldmVudFR5cGVzLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICAgIC8vZm9yIGVhY2ggZXZlbnQgdHlwZSBhZGQgYSBmaWx0ZXIgb2JqZWN0LiBGb3IgZWFjaCByb2xlLCBhZGQgYW4gYXJndW1lbnRzIGFycmF5IHRvIHRoZSBldmVudCBmaWx0ZXIgb2JqZWN0LiBJZiBlbnRpdHkgaWRzIGV4aXN0LCBhZGQgdGhlbSB0byB0aGUgYXJndW1lbnQgb2JqZWN0IGluIHRoZSBhcnJheQogICAgICAgICAgICAgICAgY29uc3QgZXZlbnRUeXBlcyA9IFsuLi5uZXcgU2V0KHRoaXMuY2xhaW1GaWx0ZXJzLmV2ZW50VHlwZXMuZmxhdE1hcChlID0+IGUudHlwZSkpXTsKICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnRUeXBlIG9mIGV2ZW50VHlwZXMpIHsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGFpbUZpbHRlcnMucm9sZXMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAvL0NyZWF0ZSBhcmd1bWVudHMgZm9yIGVhY2ggcm9sZSBhbmQgaWQgcGFpcgogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb2xlcyA9IFsuLi5uZXcgU2V0KHRoaXMuY2xhaW1GaWx0ZXJzLnJvbGVzLmZsYXRNYXAociA9PiByLnJvbGUpKV07CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm9sZSBvZiByb2xlcykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xhaW1GaWx0ZXJzLmVudGl0eUlkcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2luZyB0byBuYW1lcyBzaW5jZSBFUyBxdWVyeSBhY2NlcHRzIG5hbWVzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50aXR5TmFtZXMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5lbnRpdHlJZHMuZmxhdE1hcChlbnRpdHkgPT4gZW50aXR5Lm5hbWUpKV07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGVudGl0eU5hbWVzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJPYmplY3QgPSB7WydldmVudFR5cGUnXTogZXZlbnRUeXBlLCBbJ2FyZ3VtZW50cyddIDogW119OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJndW1lbnRPYmplY3QgPSB7Wydyb2xlJ10gOiByb2xlfTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRPYmplY3RbJ2lkcyddID0gW25hbWVdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJPYmplY3RbJ2FyZ3VtZW50cyddLnB1c2goYXJndW1lbnRPYmplY3QpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRGaWx0ZXJzLnB1c2goZmlsdGVyT2JqZWN0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsdGVyT2JqZWN0ID0ge1snZXZlbnRUeXBlJ106IGV2ZW50VHlwZSwgWydhcmd1bWVudHMnXSA6IFtdfTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJPYmplY3RbJ2FyZ3VtZW50cyddLnB1c2goe1sncm9sZSddIDogcm9sZX0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEZpbHRlcnMucHVzaChmaWx0ZXJPYmplY3QpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2xhaW1GaWx0ZXJzLmVudGl0eUlkcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hhbmdpbmcgdG8gbmFtZXMgc2luY2UgRVMgcXVlcnkgYWNjZXB0cyBuYW1lcwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHlOYW1lcyA9IFsuLi5uZXcgU2V0KHRoaXMuY2xhaW1GaWx0ZXJzLmVudGl0eUlkcy5mbGF0TWFwKGVudGl0eSA9PiBlbnRpdHkubmFtZSkpXTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IG5hbWUgb2YgZW50aXR5TmFtZXMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJPYmplY3QgPSB7WydldmVudFR5cGUnXTogZXZlbnRUeXBlLCBbJ2FyZ3VtZW50cyddIDogW119OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyZ3VtZW50T2JqZWN0ID0ge1snaWRzJ10gOiBbbmFtZV19OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyT2JqZWN0Wydhcmd1bWVudHMnXS5wdXNoKGFyZ3VtZW50T2JqZWN0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEZpbHRlcnMucHVzaChmaWx0ZXJPYmplY3QpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAvL29ubHkgYWRkIGV2ZW50IHR5cGUKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlZm9ybWF0ID0ge1snZXZlbnRUeXBlJ106IGV2ZW50VHlwZX07CiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEZpbHRlcnMucHVzaChyZWZvcm1hdCk7CgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICAvL3JvbGUgZmlsdGVycyB3ZXJlIHN1Ym1pdHRlZCB3aXRob3V0IGV2ZW50IHR5cGVzCiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5jbGFpbUZpbHRlcnMucm9sZXMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgLy9mb3IgZWFjaCByb2xlIGFuZCBpZCBwYWlyLCBhZGQgYW4gYXJndW1lbnQgdG8gdGhlIGFyZ3VtZW50cyBhcnJheQogICAgICAgICAgICAgICAgY29uc3Qgcm9sZXMgPSBbLi4ubmV3IFNldCh0aGlzLmNsYWltRmlsdGVycy5yb2xlcy5mbGF0TWFwKHIgPT4gci5yb2xlKSldOwogICAgICAgICAgICAgICAgZm9yIChjb25zdCByb2xlIG9mIHJvbGVzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xhaW1GaWx0ZXJzLmVudGl0eUlkcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hhbmdpbmcgdG8gbmFtZXMgc2luY2UgRVMgcXVlcnkgYWNjZXB0cyBuYW1lcwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHlOYW1lcyA9IFsuLi5uZXcgU2V0KHRoaXMuY2xhaW1GaWx0ZXJzLmVudGl0eUlkcy5mbGF0TWFwKGVudGl0eSA9PiBlbnRpdHkubmFtZSkpXTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGVudGl0eU5hbWVzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsdGVyT2JqZWN0ID0ge1snYXJndW1lbnRzJ10gOiBbXX07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJndW1lbnRPYmplY3QgPSB7Wydyb2xlJ10gOiByb2xlfTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50T2JqZWN0WydpZHMnXSA9IFtuYW1lXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlck9iamVjdFsnYXJndW1lbnRzJ10ucHVzaChhcmd1bWVudE9iamVjdCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRGaWx0ZXJzLnB1c2goZmlsdGVyT2JqZWN0KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbHRlck9iamVjdCA9IHtbJ2FyZ3VtZW50cyddIDogW119OwogICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJPYmplY3RbJ2FyZ3VtZW50cyddLnB1c2goe1sncm9sZSddIDogcm9sZX0pOwogICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRGaWx0ZXJzLnB1c2goZmlsdGVyT2JqZWN0KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy9uYW1lZCBlbnRpdHkgZmlsdGVycyB3ZXJlIHN1Ym1pdHRlZCB3aXRob3V0IGV2ZW50IHR5cGVzIG9yIHJvbGVzCiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5jbGFpbUZpbHRlcnMuZW50aXR5SWRzLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICAgIGNvbnN0IGVudGl0eU5hbWVzID0gWy4uLm5ldyBTZXQodGhpcy5jbGFpbUZpbHRlcnMuZW50aXR5SWRzLmZsYXRNYXAoZW50aXR5ID0+IGVudGl0eS5uYW1lKSldOwogICAgICAgICAgICAgICAgZm9yKGNvbnN0IG5hbWUgb2YgZW50aXR5TmFtZXMpIHsKICAgICAgICAgICAgICAgICAgICBsZXQgZmlsdGVyT2JqZWN0ID0ge1snYXJndW1lbnRzJ10gOiBbXX07CiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZ3VtZW50T2JqZWN0ID0ge1snaWRzJ10gOiBbbmFtZV19OwogICAgICAgICAgICAgICAgICAgIGZpbHRlck9iamVjdFsnYXJndW1lbnRzJ10ucHVzaChhcmd1bWVudE9iamVjdCk7CiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkRmlsdGVycy5wdXNoKGZpbHRlck9iamVjdCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ25vIGZpbHRlcnMgc3VibWl0dGVkJykKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVkRmlsdGVyczsKICAgICAgICB9CiAgICB9Cn0K"},{"version":3,"sources":["IncidentSearch.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"IncidentSearch.vue","sourceRoot":"src/views/eval","sourcesContent":["<!--\n  - Copyright 2021 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n  - Created by s.nordt on 6/23/21\n-->\n\n<template>\n    <div class=\"page-content\">\n        <div class=\"kb-details\">\n            <div class=\"kb-description-wrapper\">\n                <div class=\"element-list-header\">\n                    <div class=\"primary-page-header-left\">Incident Search</div>\n                    <div class=\"page-header-right\">\n                        <button id=\"compare_button\" class=\"dark-app-button\" @click=\"linkToIncidentDetails()\">\n                            <v-icon class=\"button-icon\">mdi-compare</v-icon>\n                            Incident Details\n                        </button>\n                        <button id=\"doc_button\" class=\"dark-app-button\" @click=\"linkToEvalDocSearch()\">\n                            <v-icon class=\"button-icon\">mdi-file-document-box-search-outline</v-icon>\n                            Document Search\n                        </button>\n                    </div>\n                </div>\n                <span class=\"element-list-header\">Begin query by adding a named entity, role, and/or an event type</span>\n                <div class=\"query-div\">\n                    <div class=\"query-field-column-wrapper\">\n                        <MultiSelectAutoComplete\n                             :items=\"namedEntities\"\n                             :required=\"false\"\n                             :placeholder=\"'Named Entities'\"\n                             :index=2\n                             :message=\"'No named entities available'\"\n                             @autoCompleteSubmission=\"updateEntityNames($event)\"\n                             @autoCompleteClear=\"updateEntityNames($event)\"\n                        ></MultiSelectAutoComplete>\n                        <MultiSelectAutoComplete\n                            :items=\"roles\"\n                            :required=\"false\"\n                            :placeholder=\"'Roles'\"\n                            :index=1\n                            :message=\"'No roles available'\"\n                            @autoCompleteSubmission=\"updateRoles($event)\"\n                            @autoCompleteClear=\"updateRoles($event)\"\n                        ></MultiSelectAutoComplete>\n                        <MultiSelectAutoComplete\n                             :items=\"eventTypes\"\n                             :required=\"false\"\n                             :placeholder=\"'Event Types'\"\n                             :index=0\n                             :message=\"'No event types available'\"\n                             @autoCompleteSubmission=\"updateEventTypes($event)\"\n                             @autoCompleteClear=\"updateEventTypes($event)\"\n                        ></MultiSelectAutoComplete>\n                    </div>\n                    <div class=\"footer-button-wrapper\">\n                        <div>\n                            <button type=\"submit\" class=\"dark-gray-submit-button\" @click.prevent=\"updateSearchForm(views.resetQuery.type)\">\n                                Reset\n                            </button>\n                            <button type=\"submit\" ref=\"searchButton\" class=\"dark-teal-submit-button\" @click.prevent=\"updateSearchForm(views.claimResults.type)\">\n                                Search\n                            </button>\n                        </div>\n                        <hr class=\"hr-fade\">\n                    </div>\n                </div>\n            </div>\n        </div>\n        <Claims :ref=\"resultsAnchor\" :searchType=\"SEARCHTYPES.multi\" :claimSearchFilters=\"formattedClaims\" @completedSearch=completedSearch($event) ></Claims>\n    </div>\n</template>\n\n<script>\n    import MultiSelectAutoComplete from '@/components/MultiSelectAutoComplete';\n    import Claims from '@/views/analyze/Claims';\n    import {mapMutations} from 'vuex';\n    import {\n        SEARCHTYPES,\n        INCIDENTMAPPING,\n        getType,\n        getRole,\n        cleanName,\n        sortCaseInsensitive\n    } from '../../utils';\n    import API from '../../api';\n\n    //const currentRequests = new Map();\n    const CLAIMFILTERS = {\n        event: 'eventFilter',\n        entity: 'entityFilter',\n        role: 'roleFilter'\n    };\n\n    class View {\n        constructor (type, disabled) {\n            this.type = type;\n            this.disabled = disabled;\n        }\n    }\n\n     class Filter {\n         constructor() {\n             this.entityIds = [];\n             this.eventTypes = [];\n             this.roles = [];\n         }\n     }\n\n    class QueryValues {\n        constructor() {\n            this[CLAIMFILTERS.entity] = {};\n            this[CLAIMFILTERS.event] = {};\n            this[CLAIMFILTERS.role] = {};\n        }\n    }\n\n    function initialState() {\n        return {\n            claimFilters: {},\n            formattedFilters: [],\n            queryEventTypes : {},\n            queryNamedEntities: {},\n            queryRoles: {},\n            allQueryValues: {},\n            resultsAnchor: 'claim_results',\n            views: {\n                resetQuery: new View('resetQuery', false),\n                claimResults: new View('claimResults', true)\n            }\n        }\n    }\n    export default {\n        name: 'IncidentSearch',\n        components: {Claims, MultiSelectAutoComplete},\n        data: () => (initialState()),\n        created() {\n            this.CLAIMFILTERS = CLAIMFILTERS;\n            this.SEARCHTYPES = SEARCHTYPES;\n            this.INCIDENTMAPPING = INCIDENTMAPPING;\n        },\n        mounted() {\n            window.scroll({\n                top: 0,\n                behavior: 'smooth'\n            });\n            this.resetQueryForm();\n        },\n        computed: {\n           eventTypes() {\n               return this.getPrettyLabels(this.queryEventTypes);\n           },\n            namedEntities() {\n               return this.getPrettyLabels(this.queryNamedEntities);\n            },\n            roles() {\n                return this.getPrettyLabels(this.queryRoles);\n            },\n            formattedClaims() {\n               return this.formattedFilters;\n            },\n            sinIds() {\n                return INCIDENTMAPPING.map(v => v.id);\n            }\n        },\n        methods: {\n            ...mapMutations(['updateSinSelection']),\n            linkToEvalDocSearch () {\n                window.open('https://blackbox.verdi.nextcentury.com/', '_blank');\n            },\n            linkToIncidentDetails () {\n                this.$router.push('/eval/incident_detail');\n            },\n            completedSearch(value) {\n                this.$refs.searchButton.disabled = !value\n            },\n            getPrettyLabels(items) {\n                //remove duplicates and sort\n               return  Object.keys(items) ? sortCaseInsensitive([...Object.keys(items)]) : items;\n            },\n            scrollToResults() {\n                this.$nextTick(() => {\n                    const el = this.$refs[this.resultsAnchor].$el;\n                    if(el) {\n                        el.scrollIntoView({ top: 'position', behavior: 'smooth' })\n                    }\n                });\n            },\n            setClaimFilters(keys, querySet, filter) {\n                let filters = [];\n                for (const key of keys) {\n                    const URIs = this[querySet][key] ? this[querySet][key] : [];\n                    filters = [...filters, ...URIs];\n                }\n                this.claimFilters[filter] = [...new Set(filters)];\n            },\n            updateEventTypes(types) {\n                this.claimFilters.eventTypes = [];\n                if(types.length > 0) {\n                    this.setClaimFilters(types, 'queryEventTypes', 'eventTypes');\n                    const entityIds = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.ids))];\n                    const roleIds = [...new Set(this.claimFilters.roles.flatMap(role => role.ids))];\n                    const eventTypeIds = [...new Set(this.claimFilters.eventTypes.flatMap(e => e.ids))];\n                    //update roles and names for the claimFilter if they don't have selected values already\n                    if(this.claimFilters.roles.length === 0) {\n                        this.getRoles(eventTypeIds, entityIds);\n                    }\n                    if(this.claimFilters.entityIds.length === 0) {\n                        this.getEntityNames(eventTypeIds, roleIds);\n                    }\n                }\n                else {\n                    //no type filters submitted, reset roles and names\n                    this.getRoles();\n                    this.getEntityNames();\n                }\n            },\n            updateRoles(roles) {\n                this.claimFilters.roles = [];\n                if(roles.length > 0) {\n                    this.setClaimFilters(roles, 'queryRoles', 'roles');\n                    const entityIds = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.ids))];\n                    const roleIds = [...new Set(this.claimFilters.roles.flatMap(role => role.ids))];\n                    const eventTypeIds = [...new Set(this.claimFilters.eventTypes.flatMap(e => e.ids))];\n\n                    //update event types and names for the claimFilter if they don't have selected values already\n                    if(this.claimFilters.eventTypes.length === 0) {\n                        this.getEventTypes(roleIds, entityIds);\n                    }\n                    if(this.claimFilters.entityIds.length === 0) {\n                        this.getEntityNames(eventTypeIds, roleIds);\n                    }\n                }\n                else {\n                    //no type filters submitted, reset event types and names\n                    this.getEventTypes();\n                    this.getEntityNames();\n                }\n            },\n            updateEntityNames(names) {\n                this.claimFilters.entityIds = [];\n                if(names.length > 0) {\n                    //When events change, clear filters and add new ones\n                    this.setClaimFilters(names, 'queryNamedEntities', 'entityIds');\n                    const entityIds = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.ids))];\n                    const roleIds = [...new Set(this.claimFilters.roles.flatMap(role => role.ids))];\n                    const eventTypeIds = [...new Set(this.claimFilters.eventTypes.flatMap(e => e.ids))];\n\n                    //update event types and roles for the claimFilter if they don't have selected values already\n                    if(this.claimFilters.eventTypes.length === 0) {\n                        this.getEventTypes(roleIds,  entityIds);\n                    }\n                    if(this.claimFilters.roles.length === 0) {\n                        this.getRoles(eventTypeIds, entityIds);\n                    }\n                }\n                else {\n                    //no type filters submitted, reset event types and role\n                    this.getEventTypes();\n                    this.getRoles();\n                }\n            },\n            getEventTypes(roles = [], ids = []) {\n                const noFilters = roles.length === 0 && ids.length === 0;\n                //No need to re-run API for the original query values\n                if(Object.keys(this.allQueryValues[CLAIMFILTERS.event]).length > 0 && noFilters) {\n                    this.queryEventTypes = this.allQueryValues[CLAIMFILTERS.event];\n                }\n                else {\n                    API.getAllSinEventTypes(roles, ids).then(response => {\n                        if (response.data.length > 0) {\n                            //event type keys are the clean event types with URI removed\n                            let types = {};\n                            for (const type of response.data) {\n                                const transformedType = getType(type);\n                                const typeIdObject = {type: transformedType, ids: type};\n                                if (types.hasOwnProperty(transformedType)) {\n                                    types[transformedType] = [...types[transformedType], typeIdObject];\n                                }\n                                else {\n                                    types[transformedType] = [typeIdObject];\n                                }\n                            }\n                            //if there are no filters and the original query values haven't been set, set allQueryValues\n                            if (noFilters) {\n                                this.allQueryValues[CLAIMFILTERS.event] = types;\n                            }\n\n                            this.queryEventTypes = types;\n                        }\n                        else {\n                            this.queryEventTypes = {};\n                        }\n                    }).catch((error) => {\n                        console.warn(error)\n                    });\n                }\n            },\n            getRoles(eventTypes = [], ids = []) {\n                const noFilters = eventTypes.length === 0 && ids.length === 0;\n                //No need to re-run API for the original query values\n                if(Object.keys(this.allQueryValues[CLAIMFILTERS.role]).length > 0 && noFilters) {\n                    this.queryRoles = this.allQueryValues[CLAIMFILTERS.role];\n                }\n                else {\n                    API.getAllSinRoles(eventTypes, ids).then(response => {\n                        if(response.data.length > 0 ) {\n                            //role URIs will be grouped by the truncated role name\n                            let roles = {};\n                            for (const d of response.data) {\n                                const truncRole = getRole(d);\n                                const roleIdObject = {role: truncRole, ids: d};\n                                if(roles.hasOwnProperty(truncRole)) {\n                                    roles[truncRole] = [...roles[truncRole], roleIdObject];\n                                }\n                                else {\n                                    roles[truncRole] = [roleIdObject];\n                                }\n                            }\n                            //if there are no filters and the original query values haven't been set, set allQueryValues\n                            if(noFilters) {\n                                this.allQueryValues[CLAIMFILTERS.role] = roles;\n                            }\n                            this.queryRoles = roles;\n                        }\n                        else {\n                            this.queryRoles = {};\n                        }\n                    }).catch((error) => {\n                        console.warn(error)\n                    });\n                }\n            },\n            getEntityNames(eventTypes = [], roles = []) {\n                const noFilters = roles.length === 0 && eventTypes.length === 0;\n                //No need to re-run API for the original query values\n                if(Object.keys(this.allQueryValues[CLAIMFILTERS.entity]).length > 0 && noFilters) {\n                    this.queryNamedEntities = this.allQueryValues[CLAIMFILTERS.entity];\n                }\n                else {\n                    //event types and roles need to be cleaned up for the ElasticSearch API\n                    const esEventTypes = eventTypes.map(t => getType(t));\n                    const esRoles = roles.map(r => getRole(r));\n                    API.getAllSinNames(esEventTypes, esRoles).then(response => {\n                        if (response.data.length > 0) {\n                            //name keys are the actual name while the\n                            let names = {};\n                            for (const name of response.data) {\n                                //clean name in order to sort for multi-select autocomplete\n                                const canonicalName = cleanName(name.id);\n                                const nameIdObject = {name: name.id, ids: name.entities};\n                                if (names.hasOwnProperty(canonicalName)) {\n                                    //No longer using entityIds, names[canonicalName] = [...new Set([...names[canonicalName], ...name.entities])];\n                                    names[canonicalName] = [...names[canonicalName], nameIdObject];\n                                } else {\n                                    //No longer using entityIds, - names[canonicalName] = name.entities;\n                                    names[canonicalName] = [nameIdObject];\n                                }\n                            }\n\n                            //if there are no filters and the original query values haven't been set, set allQueryValues\n                            if (noFilters) {\n                                this.allQueryValues[CLAIMFILTERS.entity] = names;\n                            }\n\n                            this.queryNamedEntities = names;\n                        }\n                        else {\n                            this.queryNamedEntities = {};\n                        }\n                    }).catch((error) => {\n                        console.warn(error)\n                    });\n                }\n            },\n            updateSearchForm(viewType) {\n                if(viewType === this.views.resetQuery.type) {\n                    Object.assign(this.$data, initialState());\n                    this.resetQueryForm();\n                }\n                else if(viewType === this.views.claimResults.type) {\n                    this.views[viewType].disabled = false;\n                    this.formattedFilters = this.formatClaimFilters();\n                    this.scrollToResults();\n                }\n            },\n            resetQueryForm() {\n                this.claimFilters = new Filter();\n                this.allQueryValues = new QueryValues();\n\n                //fetch the query values for all SINs/Incidents\n                this.getEventTypes();\n                this.getRoles();\n                this.getEntityNames();\n            },\n            formatClaimFilters() {\n                let formattedFilters = [];\n                //event type filters were submitted\n                if(this.claimFilters.eventTypes.length > 0) {\n                    //for each event type add a filter object. For each role, add an arguments array to the event filter object. If entity ids exist, add them to the argument object in the array\n                    const eventTypes = [...new Set(this.claimFilters.eventTypes.flatMap(e => e.type))];\n                    for (const eventType of eventTypes) {\n                        if (this.claimFilters.roles.length > 0) {\n                            //Create arguments for each role and id pair\n                            const roles = [...new Set(this.claimFilters.roles.flatMap(r => r.role))];\n                            for (const role of roles) {\n                                if (this.claimFilters.entityIds.length > 0) {\n                                    //changing to names since ES query accepts names\n                                    const entityNames = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.name))];\n                                    for (const name of entityNames) {\n                                        let filterObject = {['eventType']: eventType, ['arguments'] : []};\n                                        let argumentObject = {['role'] : role};\n                                        argumentObject['ids'] = [name];\n                                        filterObject['arguments'].push(argumentObject);\n                                        formattedFilters.push(filterObject);\n                                    }\n                                }\n                                else {\n                                    let filterObject = {['eventType']: eventType, ['arguments'] : []};\n                                    filterObject['arguments'].push({['role'] : role});\n                                    formattedFilters.push(filterObject);\n                                }\n                            }\n                        }\n                        else if (this.claimFilters.entityIds.length > 0) {\n                            //changing to names since ES query accepts names\n                            const entityNames = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.name))];\n                            for(const name of entityNames) {\n                                let filterObject = {['eventType']: eventType, ['arguments'] : []};\n                                let argumentObject = {['ids'] : [name]};\n                                filterObject['arguments'].push(argumentObject);\n                                formattedFilters.push(filterObject);\n                            }\n                        }\n                        else {\n                            //only add event type\n                            let reformat = {['eventType']: eventType};\n                            formattedFilters.push(reformat);\n\n                        }\n                    }\n                }\n                //role filters were submitted without event types\n                else if(this.claimFilters.roles.length > 0) {\n                    //for each role and id pair, add an argument to the arguments array\n                    const roles = [...new Set(this.claimFilters.roles.flatMap(r => r.role))];\n                    for (const role of roles) {\n                        if (this.claimFilters.entityIds.length > 0) {\n                            //changing to names since ES query accepts names\n                            const entityNames = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.name))];\n                            for (const name of entityNames) {\n                                let filterObject = {['arguments'] : []};\n                                let argumentObject = {['role'] : role};\n                                argumentObject['ids'] = [name];\n                                filterObject['arguments'].push(argumentObject);\n                                formattedFilters.push(filterObject);\n                            }\n                        }\n                        else {\n                            let filterObject = {['arguments'] : []};\n                            filterObject['arguments'].push({['role'] : role});\n                            formattedFilters.push(filterObject);\n                        }\n                    }\n                }\n                //named entity filters were submitted without event types or roles\n                else if(this.claimFilters.entityIds.length > 0) {\n                    const entityNames = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.name))];\n                    for(const name of entityNames) {\n                        let filterObject = {['arguments'] : []};\n                        let argumentObject = {['ids'] : [name]};\n                        filterObject['arguments'].push(argumentObject);\n                        formattedFilters.push(filterObject);\n                    }\n                }\n                else {\n                    console.warn('no filters submitted')\n                }\n                return formattedFilters;\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .query-div {\n        @extend .kb-description-wrapper;\n        padding: 10px 0;\n        justify-content: space-between;\n    }\n\n    .query-field-column-wrapper{\n        @include flex-column-nowrap;\n        padding : 0 4px 6px 0;\n    }\n</style>\n\n"]}]}