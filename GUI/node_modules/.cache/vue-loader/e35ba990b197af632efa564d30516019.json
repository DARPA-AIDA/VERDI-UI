{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/HypothesisComparison.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/HypothesisComparison.vue","mtime":1640207172535},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/babel-loader/lib/index.js","mtime":1641411773354},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBEYXRhVGFibGUgZnJvbSAnQC9jb21wb25lbnRzL0RhdGFUYWJsZSc7CmltcG9ydCB7IG1hcE11dGF0aW9ucywgbWFwU3RhdGV9IGZyb20gJ3Z1ZXgnOwppbXBvcnQgQVBJIGZyb20gJy4uLy4uL2FwaSc7CmltcG9ydCB7CiAgICBUQUJMRVNFTEVDVElPTlMsCiAgICBUQUJMRUZJRUxETUFQUElORywKICAgIERBVEFUWVBFUywKICAgIExPQURJTkdNRVNTQUdFLAogICAgUFJFRklYVFlQRVMsCiAgICBzb3J0QXJyYXlPZk9iamVjdHMsCiAgICByZW1vdmVQcmVmaXgsCiAgICBmb3JtYXRTaW5zQ29tcGFyaXNvbiwKICAgIGdldFNpbklkRnJvbURhdGFTb3VyY2UsCiAgICBUYWJsZVNldHRpbmdzLAogICAgSGVhZGVyQ29uZmlnCn0gZnJvbSAnLi4vLi4vdXRpbHMnOwoKZXhwb3J0IGRlZmF1bHQgewogICAgbmFtZTogJ0h5cG90aGVzaXNDb21wYXJpc29uJywKICAgIGNvbXBvbmVudHM6IHtEYXRhVGFibGV9LAogICAgZGF0YTogKCkgPT4gKHsKICAgICAgICBzb3J0OiB7W1RBQkxFU0VMRUNUSU9OUy5zb3J0QnldOiBUQUJMRUZJRUxETUFQUElORy5pZCwgW1RBQkxFU0VMRUNUSU9OUy5zb3J0RGVzY106IGZhbHNlfSwKICAgICAgICBwYWdpbmc6IHtbVEFCTEVTRUxFQ1RJT05TLml0ZW1zUGVyUGFnZV06J0FsbCd9LAogICAgICAgIHN0YXR1c01lc3NhZ2U6ICcnLAogICAgICAgIHNpbkh5cG90aGVzZXM6IHt9LAogICAgICAgIHNpblR5cGVzOiBbXSwKICAgICAgICBzaW5JZCA6ICcnLAogICAgICAgIFNJTjoge30sCiAgICAgICAgbG9hZGluZzogZmFsc2UsCiAgICB9KSwKICAgIGNyZWF0ZWQoKSB7CiAgICAgICAgdGhpcy5UQUJMRUZJRUxETUFQUElORyA9IFRBQkxFRklFTERNQVBQSU5HOwogICAgICAgIHRoaXMuREFUQVRZUEVTID0gREFUQVRZUEVTOwogICAgICAgIHRoaXMubG9hZGluZyAgPSB0cnVlOwogICAgICAgIHRoaXMuc3RhdHVzTWVzc2FnZSA9IExPQURJTkdNRVNTQUdFOwogICAgfSwKICAgIG1vdW50ZWQoKSB7CiAgICAgICAgdGhpcy51cGRhdGVIeXBvdGhlc2lzU2VsZWN0aW9uKHt9KTsKICAgICAgICBsZXQgZGF0YVNvdXJjZSA9IHtbJ2dyYXBoJ10gOiB0aGlzLmN1cnJlbnREYXRhU291cmNlID8gdGhpcy5jdXJyZW50RGF0YVNvdXJjZSA6IHRoaXMuZGVmYXVsdEh5cG90aGVzaXNEYXRhU291cmNlfTsKICAgICAgICB0aGlzLnNpbklkID0gZ2V0U2luSWRGcm9tRGF0YVNvdXJjZSh0aGlzLmN1cnJlbnREYXRhU291cmNlKTsKICAgICAgICBBUEkuZ2V0U2luUXVlcnlSZXN1bHRzKHRoaXMuc2luSWQsIGRhdGFTb3VyY2UpLnRoZW4ocmVzcG9uc2UgPT4gewogICAgICAgICAgICB0aGlzLlNJTiA9IHJlc3BvbnNlLmRhdGE7CiAgICAgICAgICAgIHRoaXMuZ2V0Rm9ybWF0dGVkRGF0YShyZXNwb25zZS5kYXRhKTsKICAgICAgICB9KTsKICAgIH0sCiAgICBjb21wdXRlZDogewogICAgICAgIC4uLm1hcFN0YXRlKFsnZGVmYXVsdEh5cG90aGVzaXNEYXRhU291cmNlJywgJ2h5cG90aGVzaXNTZWxlY3Rpb24nLCdjdXJyZW50RGF0YVNvdXJjZSddKSwKICAgICAgICB0eXBlcygpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2luVHlwZXMubGVuZ3RoID4gMCA/IHRoaXMuc2luVHlwZXMgOiBudWxsOwogICAgICAgIH0sCiAgICAgICAgc2luRGF0YSgpIHsKICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2luSHlwb3RoZXNlcykubGVuZ3RoID4gMCA/IHRoaXMuc2luSHlwb3RoZXNlcyA6IG51bGw7CiAgICAgICAgfQogICAgfSwKICAgIG1ldGhvZHM6IHsKICAgICAgICAuLi5tYXBNdXRhdGlvbnMoWyd1cGRhdGVIeXBvdGhlc2lzU2VsZWN0aW9uJ10pLAogICAgICAgIGJ1aWxkVGFibGVDb25maWd1cmF0aW9uKHR5cGUpIHsKICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLnNpbkRhdGFbdHlwZV1bMF1bVEFCTEVGSUVMRE1BUFBJTkcuY2x1c3RlckNhdGVnb3J5XTsKICAgICAgICAgICAgbGV0IHJvbGVIZWFkZXJzID0gbmV3IE1hcCgpOwogICAgICAgICAgICBsZXQgdGFibGVNYXBwaW5ncyA9IHsKICAgICAgICAgICAgICAgIHRhYmxlU2V0dGluZ3M6IG5ldyBUYWJsZVNldHRpbmdzKFRBQkxFRklFTERNQVBQSU5HLmlkVXJpLCBmYWxzZSwgdHlwZSwgY2F0ZWdvcnksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCAnaGVhZGxpbmUnLCBmYWxzZSksCiAgICAgICAgICAgICAgICBwcmltYXJ5SGVhZGVyczogWwogICAgICAgICAgICAgICAgICAgIG5ldyBIZWFkZXJDb25maWcoJ0h5cG90aGVzaXMnLCAnc3RhcnQnLCB0cnVlLCBUQUJMRUZJRUxETUFQUElORy5oZWFkbGluZSwgZmFsc2UsIGZhbHNlKQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICB9OwoKICAgICAgICAgICAgZm9yIChjb25zdCBoeXBvdGhlc2lzIG9mIHRoaXMuc2luRGF0YVt0eXBlXSkgewogICAgICAgICAgICAgICAgcm9sZUhlYWRlcnMgPSBuZXcgTWFwKFsuLi5yb2xlSGVhZGVycywgLi4ubmV3IE1hcChoeXBvdGhlc2lzW1RBQkxFRklFTERNQVBQSU5HLnJvbGVzXS5tYXAocm9sZSA9PgogICAgICAgICAgICAgICAgICAgIFtyb2xlLCBuZXcgSGVhZGVyQ29uZmlnKHJvbGUsICdzdGFydCcsIHRydWUsIHJvbGUsIHRydWUsIHRydWUpXQogICAgICAgICAgICAgICAgKSldKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy9zb3J0IHJvbGUgaGVhZGVycwogICAgICAgICAgICByb2xlSGVhZGVycyA9IG5ldyBNYXAoWy4uLnJvbGVIZWFkZXJzXS5zb3J0KCkpOwoKICAgICAgICAgICAgLy9jb21iaW5lIGV4aXN0aW5nIHByaW1hcnkgaGVhZGVycyB3aXRoIHJvbGUgYW5kIG1hdGNoIHBlcmNlbnRhZ2UgaGVhZGVycwogICAgICAgICAgICB0YWJsZU1hcHBpbmdzLnByaW1hcnlIZWFkZXJzID0gWwogICAgICAgICAgICAgICAgLi4uWy4uLnRhYmxlTWFwcGluZ3MucHJpbWFyeUhlYWRlcnMsIC4uLm5ldyBTZXQoWy4uLnJvbGVIZWFkZXJzLnZhbHVlcygpXSldLAogICAgICAgICAgICAgICAgLi4uW25ldyBIZWFkZXJDb25maWcoJ01hdGNoICUnLCAnZW5kJywgdHJ1ZSwgVEFCTEVGSUVMRE1BUFBJTkcucGVyY2VudGFnZSwgZmFsc2UsIGZhbHNlKV0KICAgICAgICAgICAgXTsKCiAgICAgICAgICAgIHJldHVybiB0YWJsZU1hcHBpbmdzOwogICAgICAgIH0sCiAgICAgICAgZ2V0Rm9ybWF0dGVkRGF0YShzaW4pIHsKICAgICAgICAgICAgbGV0IGh5cG90aGVzZXMgPSBbXTsKICAgICAgICAgICAgc29ydEFycmF5T2ZPYmplY3RzKHNpbi5oeXBvdGhlc2VzLCAnaHlwb3RoZXNpcycpOwoKICAgICAgICAgICAgZm9yIChjb25zdCBoeXBPYmplY3Qgb2Ygc2luLmh5cG90aGVzZXMpIHsKICAgICAgICAgICAgICAgIC8vbmV3IG1hcCByZW1vdmVzIGR1cGxpY2F0ZSB0eXBlcywgYWRkZWQgVW5rbm93biB0eXBlIHRvIGNvbXBlbnNhdGUgZm9yIGluY29tcGxldGUgbWVtYmVyIGluZm9ybWF0aW9uCiAgICAgICAgICAgICAgICBjb25zdCBoeXBUeXBlcyA9IFsuLi5uZXcgU2V0KGh5cE9iamVjdC50eXBlcy5tYXAodHlwZSA9PiByZW1vdmVQcmVmaXgodHlwZSwgUFJFRklYVFlQRVMuaGFzaCkpKSwgJ1Vua25vd24nXS5zb3J0KCk7CgogICAgICAgICAgICAgICAgbGV0IGh5cG90aGVzaXNCeU1lbWJlclR5cGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGh0IG9mIGh5cFR5cGVzKSB7CiAgICAgICAgICAgICAgICAgICAgLy9zaGFsbG93IGNsb25lCiAgICAgICAgICAgICAgICAgICAgbGV0IGZvcm1hdHRlZEh5cG90aGVzaXMgPSBPYmplY3QuYXNzaWduKHt9LCBoeXBPYmplY3QpOwoKICAgICAgICAgICAgICAgICAgICBsZXQgbWVtYmVycyA9IFtdOwogICAgICAgICAgICAgICAgICAgIGxldCByb2xlcyA9IFtdOwogICAgICAgICAgICAgICAgICAgIC8vY29sbGVjdGluZyBhbmQgZm9ybWF0dGluZyBtZW1iZXJzIHRvIHBlcmZvcm0gYSBkZWVwIGNsb25lCiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgaHlwT2JqZWN0Lm1lbWJlcnMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBhcmUgbm8gYXJndW1lbnRzIHRoZW4gdGhlcmUgaXMgbm8gbmVlZCB0byBzaG93IHRoZSBtZW1iZXIKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0ID09PSByZW1vdmVQcmVmaXgobWVtYmVyLnR5cGUsIFBSRUZJWFRZUEVTLmhhc2gpICYmIG1lbWJlci5yb2xlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXJzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG1lbWJlci5ub2RlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBtZW1iZXIuY2F0ZWdvcnksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWVtYmVyLnR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZXM6IFsuLi5tZW1iZXIucm9sZXNdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IHJvbGUgb2YgbWVtYmVyLnJvbGVzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZXMucHVzaChyZW1vdmVQcmVmaXgocm9sZS5yb2xlLCBQUkVGSVhUWVBFUy51bmRlcnNjb3JlKSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBoeXBvdGhlc2lzIGhhcyBtZW1iZXJzIG9mIHRoaXMgdHlwZSB0aGVuIGNvbnRpbnVlIGZvcm1hdHRpbmcgZGF0YQogICAgICAgICAgICAgICAgICAgIGlmKG1lbWJlcnMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRIeXBvdGhlc2lzLm1lbWJlcnMgPSBtZW1iZXJzOwogICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRIeXBvdGhlc2lzLnJvbGVzID0gWy4uLm5ldyBNYXAocm9sZXMubWFwKHJvbGUgPT4gW3JvbGUsIHJvbGVdKSkudmFsdWVzKCldLnNvcnQoKTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkSHlwb3RoZXNpcy5jYXRlZ29yeSA9IHJlbW92ZVByZWZpeChtZW1iZXJzWzBdLmNhdGVnb3J5LCBQUkVGSVhUWVBFUy5oYXNoKTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkSHlwb3RoZXNpcyA9IGZvcm1hdFNpbnNDb21wYXJpc29uKGZvcm1hdHRlZEh5cG90aGVzaXMsIERBVEFUWVBFUy5zaW4uaWQsIGh0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoeXBEYXRhID0ge3R5cGU6IGh0LCBkYXRhOiBmb3JtYXR0ZWRIeXBvdGhlc2lzfTsKICAgICAgICAgICAgICAgICAgICAgICAgaHlwb3RoZXNpc0J5TWVtYmVyVHlwZS5zZXQoaHQsIGh5cERhdGEpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL2FkZCBuZXdseSBmb3JtYXR0ZWQgaHlwb3RoZXNpcyB0byBoeXBvdGhlc2VzIGFycmF5CiAgICAgICAgICAgICAgICBoeXBvdGhlc2VzID0gWy4uLmh5cG90aGVzZXMsIC4uLmh5cG90aGVzaXNCeU1lbWJlclR5cGUudmFsdWVzKCldOwoKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy9ncm91cHMgaHlwb3RoZXNlcyBkYXRhIGJ5IG1lbWJlciB0eXBlCiAgICAgICAgICAgIGNvbnN0IGh5cG90aGVzZXNSZWR1Y2UgPSBoeXBvdGhlc2VzLnJlZHVjZSgoYWNjLCBvYmopID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IG9iai50eXBlOwogICAgICAgICAgICAgICAgaWYgKCFhY2Nba2V5XSkgewogICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gW107CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLyBBZGQgb2JqZWN0IGRhdGEgdG8gbGlzdCBpbiB0aGUgZ2l2ZW4ga2V5IHBvc2l0aW9uCiAgICAgICAgICAgICAgICBhY2Nba2V5XS5wdXNoKG9iai5kYXRhKTsKICAgICAgICAgICAgICAgIHJldHVybiBhY2M7CiAgICAgICAgICAgIH0sIHt9KTsKCiAgICAgICAgICAgIHRoaXMubG9hZGluZyAgPSBmYWxzZTsKCiAgICAgICAgICAgIC8vdXBkYXRlcyB0aGUgc2luIGRhdGEgYW5kIHNpbiB0eXBlcwogICAgICAgICAgICB0aGlzLnNpbkh5cG90aGVzZXMgPSBoeXBvdGhlc2VzUmVkdWNlOwogICAgICAgICAgICB0aGlzLnNpblR5cGVzID0gT2JqZWN0LmtleXMoaHlwb3RoZXNlc1JlZHVjZSkuc29ydCgpOwogICAgICAgIH0sCiAgICAgICAgdXBkYXRlRm9udHNBbmRCYWNrZ3JvdW5kcyhoeXBvdGhlc2lzLCB0eXBlLCBpZCwgY29tcGFyZU9uKSB7CiAgICAgICAgICAgIGh5cG90aGVzaXNbVEFCTEVGSUVMRE1BUFBJTkcuY29tcGFyZV0gPSBjb21wYXJlT247CiAgICAgICAgICAgIGh5cG90aGVzaXNbVEFCTEVGSUVMRE1BUFBJTkcuaGlnaGxpZ2h0XSA9IGNvbXBhcmVPbjsKCiAgICAgICAgICAgIGlmICghY29tcGFyZU9uKSB7CiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Q29sb3JUZXh0QW5kUGVyY2VudGFnZSh0eXBlKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaHlwb3RoZXNpc1tUQUJMRUZJRUxETUFQUElORy5wZXJjZW50YWdlXSA9IDEwMDsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIGVudGl0aWVzIG9mIHJlZmVyZW5jZSBoeXBvdGhlc2lzCiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZUVudGl0aWVzID0gbmV3IFNldCh0aGlzLmdldEVudGl0aWVzKGh5cG90aGVzaXMpKTsKICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlU3RyaW5ncyA9IG5ldyBTZXQodGhpcy5nZXRFbnRpdHlTdHJpbmdzKGh5cG90aGVzaXMpKTsKCiAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBvdGhlciBoeXBvdGhlc2VzIGFuZCBzZXQgY29sb3JUZXh0IGZvciBmYWxzZSBwb3NpdGl2ZXMKICAgICAgICAgICAgY29uc3QgY29tcGFyZUh5cG90aGVzZXMgPSB0aGlzLnNpbkRhdGFbdHlwZV0uZmlsdGVyKGggPT4gaFtUQUJMRUZJRUxETUFQUElORy5pZFVyaV0gIT09IGlkKTsKICAgICAgICAgICAgZm9yKGNvbnN0IGNvbXBhcmlzb24gb2YgY29tcGFyZUh5cG90aGVzZXMpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVFbnRpdGllcyA9IG5ldyBTZXQodGhpcy5nZXRFbnRpdGllcyhjb21wYXJpc29uKSk7CiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlU3RyaW5ncyA9IG5ldyBTZXQodGhpcy5nZXRFbnRpdHlTdHJpbmdzKGNvbXBhcmlzb24pKTsKICAgICAgICAgICAgICAgIGNvbnN0IGFsbEVudGl0aWVzID0gbmV3IFNldChbLi4ucmVmZXJlbmNlRW50aXRpZXMsIC4uLmNvbXBhcmVFbnRpdGllc10pOwoKICAgICAgICAgICAgICAgIGxldCBmYWxzZVBvc2l0aXZlID0gMDsKICAgICAgICAgICAgICAgIGxldCBmYWxzZU5lZ2F0aXZlID0gMDsKICAgICAgICAgICAgICAgIGxldCB0cnVlUG9zaXRpdmUgPSAwOwogICAgICAgICAgICAgICAgZm9yIChjb25zdCB0ZXN0RW50aXR5IG9mIGFsbEVudGl0aWVzKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdFN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKHRlc3RFbnRpdHkpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGluUmVmID0gcmVmZXJlbmNlU3RyaW5ncy5oYXModGVzdFN0cmluZyk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5Db21wID0gY29tcGFyZVN0cmluZ3MuaGFzKHRlc3RTdHJpbmcpOwogICAgICAgICAgICAgICAgICAgIC8vIGluUmVmIFhPUiBpbkNvbXAKICAgICAgICAgICAgICAgICAgICBpZiAoaW5SZWYgIT0gaW5Db21wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpblJlZikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VOZWdhdGl2ZSsrOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VQb3NpdGl2ZSsrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdEVudGl0eVtUQUJMRUZJRUxETUFQUElORy5jb2xvclRleHRdID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IAogICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIHRydWUgcG9zaXRpdmUKICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVBvc2l0aXZlKys7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29uc3QgZiA9ICB0cnVlUG9zaXRpdmUgLyAodHJ1ZVBvc2l0aXZlICsgLjUgKiAoZmFsc2VQb3NpdGl2ZSArIGZhbHNlTmVnYXRpdmUpKTsKICAgICAgICAgICAgICAgIGNvbXBhcmlzb25bVEFCTEVGSUVMRE1BUFBJTkcucGVyY2VudGFnZV0gPSBNYXRoLmNlaWwoZiAqIDEwMCk7CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHJlc2V0Q29sb3JUZXh0QW5kUGVyY2VudGFnZSh0eXBlKSB7CiAgICAgICAgICAgIGZvciAoY29uc3QgaCBvZiB0aGlzLnNpbkRhdGFbdHlwZV0pIHsKICAgICAgICAgICAgICAgIGRlbGV0ZSBoW1RBQkxFRklFTERNQVBQSU5HLnBlcmNlbnRhZ2VdOwogICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5nZXRFbnRpdGllcyhoKSkgewogICAgICAgICAgICAgICAgICAgIGVudGl0eVtUQUJMRUZJRUxETUFQUElORy5jb2xvclRleHRdID0gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGdldFN0cmluZyhlKSB7CiAgICAgICAgICAgIHJldHVybiBlW1RBQkxFRklFTERNQVBQSU5HLnJvbGVzXVswXSArICcgLSAnICsgZVtUQUJMRUZJRUxETUFQUElORy5oZWFkbGluZV0gKyAnIC0gJyArIGVbVEFCTEVGSUVMRE1BUFBJTkcudHlwZXNdLmpvaW4oJywnKTsKICAgICAgICB9LAogICAgICAgIGdldEVudGl0eVN0cmluZ3MoaHlwb3RoZXNpcykgewogICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFbnRpdGllcyhoeXBvdGhlc2lzKS5tYXAodGhpcy5nZXRTdHJpbmcpOwogICAgICAgIH0sCiAgICAgICAgZ2V0RW50aXRpZXMoaHlwb3RoZXNpcykgewogICAgICAgICAgICByZXR1cm4gaHlwb3RoZXNpc1tUQUJMRUZJRUxETUFQUElORy5jbHVzdGVyTGlzdF0uZmxhdE1hcChjID0+IGNbVEFCTEVGSUVMRE1BUFBJTkcuZW50aXR5TGlzdF0pOwogICAgICAgIH0sCiAgICAgICAgdXBkYXRlSXRlbXNGb3JDb21wYXJpc29uKHJvdykgewogICAgICAgICAgICBsZXQgc2VsZWN0ZWRIeXBvdGhlc2lzID0ge307CiAgICAgICAgICAgIGxldCByZW1vdmVTdHlsaW5nID0gcm93Lml0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuY29tcGFyZV0gPT09IHRydWUgJiYKICAgICAgICAgICAgICAgIHJvdy5pdGVtW1RBQkxFRklFTERNQVBQSU5HLmlkVXJpXSA9PT0gdGhpcy5oeXBvdGhlc2lzU2VsZWN0aW9uW1RBQkxFRklFTERNQVBQSU5HLmlkVXJpXTsKCiAgICAgICAgICAgIGZvcihjb25zdCBjbHVzdGVyVHlwZSBpbiB0aGlzLnNpbkRhdGEpIHsKICAgICAgICAgICAgICAgIGlmKHRoaXMuc2luRGF0YS5oYXNPd25Qcm9wZXJ0eShjbHVzdGVyVHlwZSkpIHsKICAgICAgICAgICAgICAgICAgICAvL1R1cm4gb2ZmIGNvbXBhcmlzb24gaGlnaGxpZ2h0aW5nIGZvciBwcmV2aW91c2x5IHNlbGVjdGVkIGh5cG90aGVzaXMKICAgICAgICAgICAgICAgICAgICBpZihPYmplY3Qua2V5cyh0aGlzLmh5cG90aGVzaXNTZWxlY3Rpb24pLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzSHlwb3RoZXNpcyA9IHRoaXMuc2luRGF0YVtjbHVzdGVyVHlwZV0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKGggPT4gaFtUQUJMRUZJRUxETUFQUElORy5pZFVyaV0gPT09IHRoaXMuaHlwb3RoZXNpc1NlbGVjdGlvbltUQUJMRUZJRUxETUFQUElORy5pZFVyaV0pOwogICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2aW91c0h5cG90aGVzaXMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRm9udHNBbmRCYWNrZ3JvdW5kcyhwcmV2aW91c0h5cG90aGVzaXMsIGNsdXN0ZXJUeXBlLCB0aGlzLmh5cG90aGVzaXNTZWxlY3Rpb25bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldLCBmYWxzZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGlmKCFyZW1vdmVTdHlsaW5nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vVHVybiBvbiBjb21wYXJpc29uIGhpZ2hsaWdodGluZyBmb3IgY3VycmVudGx5IHNlbGVjdGVkIGh5cG90aGVzaXMgYW5kIHNhdmUgdG8gdGhlIHN0b3JlCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoeXBvdGhlc2lzID0gdGhpcy5zaW5EYXRhW2NsdXN0ZXJUeXBlXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoaCA9PiBoW1RBQkxFRklFTERNQVBQSU5HLmlkVXJpXSA9PT0gcm93Lml0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh5cG90aGVzaXMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRm9udHNBbmRCYWNrZ3JvdW5kcyhoeXBvdGhlc2lzLCBjbHVzdGVyVHlwZSwgcm93Lml0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldLCB0cnVlKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2x1c3RlclR5cGUgPT09IHJvdy50eXBlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRIeXBvdGhlc2lzID0gaHlwb3RoZXNpczsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgdGhpcy51cGRhdGVIeXBvdGhlc2lzU2VsZWN0aW9uKHJlbW92ZVN0eWxpbmcgPyB7fSA6IHNlbGVjdGVkSHlwb3RoZXNpcyk7CiAgICAgICAgfQogICAgfQp9Cg=="},{"version":3,"sources":["HypothesisComparison.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"HypothesisComparison.vue","sourceRoot":"src/views/analyze","sourcesContent":["<!--\n  - Copyright 2019 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n-->\n\n<template>\n    <div class=\"page-content\">\n        <div class=\"kb-details\">\n            <div class=\"row-width-description-wrapper\">\n                <div class=\"page-header-left\">\n                    <div class=\"kb-heading\">Hypothesis Comparison</div>\n                    <div><span class=\"kb-labels\">SIN ID: </span><span>{{sinId}}</span></div>\n                    <div><span class=\"kb-labels\">Description: </span><span>{{SIN.description}}</span></div>\n                </div>\n                <div class=\"page-header-align-bottom-right\">\n                    <span>Current Reference</span><v-icon>mdi-compare</v-icon>\n                </div>\n            </div>\n        </div>\n        <div v-if=\"loading===true\" class=\"loading-section\">\n            <v-progress-linear indeterminate></v-progress-linear>\n            <div class=\"loading-message-clear\">{{statusMessage}}</div>\n        </div>\n\n        <div v-else>\n            <div v-for=\"(type, index) in types\" :key=\"index\" :class=\"index > 0 ? 'section-space' : ''\">\n                <DataTable\n                    :data=\"sinData[type]\"\n                    :sort=\"sort\"\n                    :loading=\"Object.keys(sinData[type]).length === 0\"\n                    :paging=\"paging\"\n                    :tableConfiguration=\"buildTableConfiguration(type)\"\n                    :statusMessage=\"statusMessage\"\n                    @activateCompare=\"updateItemsForComparison($event)\"\n                    :hideFooter=true\n                    :hideHeader=true\n                ></DataTable>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import DataTable from '@/components/DataTable';\n    import { mapMutations, mapState} from 'vuex';\n    import API from '../../api';\n    import {\n        TABLESELECTIONS,\n        TABLEFIELDMAPPING,\n        DATATYPES,\n        LOADINGMESSAGE,\n        PREFIXTYPES,\n        sortArrayOfObjects,\n        removePrefix,\n        formatSinsComparison,\n        getSinIdFromDataSource,\n        TableSettings,\n        HeaderConfig\n    } from '../../utils';\n\n    export default {\n        name: 'HypothesisComparison',\n        components: {DataTable},\n        data: () => ({\n            sort: {[TABLESELECTIONS.sortBy]: TABLEFIELDMAPPING.id, [TABLESELECTIONS.sortDesc]: false},\n            paging: {[TABLESELECTIONS.itemsPerPage]:'All'},\n            statusMessage: '',\n            sinHypotheses: {},\n            sinTypes: [],\n            sinId : '',\n            SIN: {},\n            loading: false,\n        }),\n        created() {\n            this.TABLEFIELDMAPPING = TABLEFIELDMAPPING;\n            this.DATATYPES = DATATYPES;\n            this.loading  = true;\n            this.statusMessage = LOADINGMESSAGE;\n        },\n        mounted() {\n            this.updateHypothesisSelection({});\n            let dataSource = {['graph'] : this.currentDataSource ? this.currentDataSource : this.defaultHypothesisDataSource};\n            this.sinId = getSinIdFromDataSource(this.currentDataSource);\n            API.getSinQueryResults(this.sinId, dataSource).then(response => {\n                this.SIN = response.data;\n                this.getFormattedData(response.data);\n            });\n        },\n        computed: {\n            ...mapState(['defaultHypothesisDataSource', 'hypothesisSelection','currentDataSource']),\n            types() {\n                return this.sinTypes.length > 0 ? this.sinTypes : null;\n            },\n            sinData() {\n                return Object.keys(this.sinHypotheses).length > 0 ? this.sinHypotheses : null;\n            }\n        },\n        methods: {\n            ...mapMutations(['updateHypothesisSelection']),\n            buildTableConfiguration(type) {\n                const category = this.sinData[type][0][TABLEFIELDMAPPING.clusterCategory];\n                let roleHeaders = new Map();\n                let tableMappings = {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.idUri, false, type, category, false, false, false, false, true, 'headline', false),\n                    primaryHeaders: [\n                        new HeaderConfig('Hypothesis', 'start', true, TABLEFIELDMAPPING.headline, false, false)\n                    ]\n                };\n\n                for (const hypothesis of this.sinData[type]) {\n                    roleHeaders = new Map([...roleHeaders, ...new Map(hypothesis[TABLEFIELDMAPPING.roles].map(role =>\n                        [role, new HeaderConfig(role, 'start', true, role, true, true)]\n                    ))]);\n                }\n\n                //sort role headers\n                roleHeaders = new Map([...roleHeaders].sort());\n\n                //combine existing primary headers with role and match percentage headers\n                tableMappings.primaryHeaders = [\n                    ...[...tableMappings.primaryHeaders, ...new Set([...roleHeaders.values()])],\n                    ...[new HeaderConfig('Match %', 'end', true, TABLEFIELDMAPPING.percentage, false, false)]\n                ];\n\n                return tableMappings;\n            },\n            getFormattedData(sin) {\n                let hypotheses = [];\n                sortArrayOfObjects(sin.hypotheses, 'hypothesis');\n\n                for (const hypObject of sin.hypotheses) {\n                    //new map removes duplicate types, added Unknown type to compensate for incomplete member information\n                    const hypTypes = [...new Set(hypObject.types.map(type => removePrefix(type, PREFIXTYPES.hash))), 'Unknown'].sort();\n\n                    let hypothesisByMemberType = new Map();\n                    for (const ht of hypTypes) {\n                        //shallow clone\n                        let formattedHypothesis = Object.assign({}, hypObject);\n\n                        let members = [];\n                        let roles = [];\n                        //collecting and formatting members to perform a deep clone\n                        for (const member of hypObject.members) {\n                            //if there are no arguments then there is no need to show the member\n                            if (ht === removePrefix(member.type, PREFIXTYPES.hash) && member.roles.length > 0) {\n                                members.push({\n                                    node: member.node,\n                                    category: member.category,\n                                    type: member.type,\n                                    roles: [...member.roles],\n                                });\n\n                                for(const role of member.roles) {\n                                    roles.push(removePrefix(role.role, PREFIXTYPES.underscore));\n                                }\n                            }\n                        }\n\n                        //if this hypothesis has members of this type then continue formatting data\n                        if(members.length > 0) {\n                            formattedHypothesis.members = members;\n                            formattedHypothesis.roles = [...new Map(roles.map(role => [role, role])).values()].sort();\n                            formattedHypothesis.category = removePrefix(members[0].category, PREFIXTYPES.hash);\n                            formattedHypothesis = formatSinsComparison(formattedHypothesis, DATATYPES.sin.id, ht);\n\n                            let hypData = {type: ht, data: formattedHypothesis};\n                            hypothesisByMemberType.set(ht, hypData);\n                        }\n                    }\n\n                    //add newly formatted hypothesis to hypotheses array\n                    hypotheses = [...hypotheses, ...hypothesisByMemberType.values()];\n\n                }\n\n                //groups hypotheses data by member type\n                const hypothesesReduce = hypotheses.reduce((acc, obj) => {\n                    const key = obj.type;\n                    if (!acc[key]) {\n                        acc[key] = [];\n                    }\n                    // Add object data to list in the given key position\n                    acc[key].push(obj.data);\n                    return acc;\n                }, {});\n\n                this.loading  = false;\n\n                //updates the sin data and sin types\n                this.sinHypotheses = hypothesesReduce;\n                this.sinTypes = Object.keys(hypothesesReduce).sort();\n            },\n            updateFontsAndBackgrounds(hypothesis, type, id, compareOn) {\n                hypothesis[TABLEFIELDMAPPING.compare] = compareOn;\n                hypothesis[TABLEFIELDMAPPING.highlight] = compareOn;\n\n                if (!compareOn) {\n                    this.resetColorTextAndPercentage(type);\n                    return;\n                }\n\n                hypothesis[TABLEFIELDMAPPING.percentage] = 100;\n                \n                // collect the entities of reference hypothesis\n                const referenceEntities = new Set(this.getEntities(hypothesis));\n                const referenceStrings = new Set(this.getEntityStrings(hypothesis));\n\n                // iterate over other hypotheses and set colorText for false positives\n                const compareHypotheses = this.sinData[type].filter(h => h[TABLEFIELDMAPPING.idUri] !== id);\n                for(const comparison of compareHypotheses) {\n                    const compareEntities = new Set(this.getEntities(comparison));\n                    const compareStrings = new Set(this.getEntityStrings(comparison));\n                    const allEntities = new Set([...referenceEntities, ...compareEntities]);\n    \n                    let falsePositive = 0;\n                    let falseNegative = 0;\n                    let truePositive = 0;\n                    for (const testEntity of allEntities) {\n                        const testString = this.getString(testEntity);\n                        const inRef = referenceStrings.has(testString);\n                        const inComp = compareStrings.has(testString);\n                        // inRef XOR inComp\n                        if (inRef != inComp) {\n                            if (inRef) {\n                                falseNegative++;\n                            } else {\n                                falsePositive++;\n                                testEntity[TABLEFIELDMAPPING.colorText] = true;\n                            }\n                        } else { \n                            // must be true positive\n                            truePositive++;\n                        }\n                    }\n                    const f =  truePositive / (truePositive + .5 * (falsePositive + falseNegative));\n                    comparison[TABLEFIELDMAPPING.percentage] = Math.ceil(f * 100);\n                }\n            },\n            resetColorTextAndPercentage(type) {\n                for (const h of this.sinData[type]) {\n                    delete h[TABLEFIELDMAPPING.percentage];\n                    for (const entity of this.getEntities(h)) {\n                        entity[TABLEFIELDMAPPING.colorText] = false;\n                    }\n                }\n            },\n            getString(e) {\n                return e[TABLEFIELDMAPPING.roles][0] + ' - ' + e[TABLEFIELDMAPPING.headline] + ' - ' + e[TABLEFIELDMAPPING.types].join(',');\n            },\n            getEntityStrings(hypothesis) {\n                return this.getEntities(hypothesis).map(this.getString);\n            },\n            getEntities(hypothesis) {\n                return hypothesis[TABLEFIELDMAPPING.clusterList].flatMap(c => c[TABLEFIELDMAPPING.entityList]);\n            },\n            updateItemsForComparison(row) {\n                let selectedHypothesis = {};\n                let removeStyling = row.item[TABLEFIELDMAPPING.compare] === true &&\n                    row.item[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri];\n\n                for(const clusterType in this.sinData) {\n                    if(this.sinData.hasOwnProperty(clusterType)) {\n                        //Turn off comparison highlighting for previously selected hypothesis\n                        if(Object.keys(this.hypothesisSelection).length > 0) {\n                            let previousHypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri]);\n                            if(previousHypothesis) {\n                                this.updateFontsAndBackgrounds(previousHypothesis, clusterType, this.hypothesisSelection[TABLEFIELDMAPPING.idUri], false);\n                            }\n                        }\n\n                        if(!removeStyling) {\n                            //Turn on comparison highlighting for currently selected hypothesis and save to the store\n                            let hypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === row.item[TABLEFIELDMAPPING.idUri]);\n                            if (hypothesis) {\n                                this.updateFontsAndBackgrounds(hypothesis, clusterType, row.item[TABLEFIELDMAPPING.idUri], true);\n\n                                if (clusterType === row.type) {\n                                    selectedHypothesis = hypothesis;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                this.updateHypothesisSelection(removeStyling ? {} : selectedHypothesis);\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .loading-section {\n        margin: 48px 0;\n    }\n\n    .loading-message-clear {\n        @include flex-row-nowrap;\n        justify-content: center;\n        height: 60px;\n        padding: 16px;\n    }\n</style>\n\n"]}]}