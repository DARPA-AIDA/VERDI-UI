{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/IncidentSearch.vue?vue&type=style&index=0&id=499c133a&lang=scss&scoped=true&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/IncidentSearch.vue","mtime":1640207172536},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/css-loader/dist/cjs.js","mtime":1641411773021},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1641411774047},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/postcss-loader/src/index.js","mtime":1641411773350},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/sass-loader/dist/cjs.js","mtime":1641411772200},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5xdWVyeS1kaXYgewogICAgQGV4dGVuZCAua2ItZGVzY3JpcHRpb24td3JhcHBlcjsKICAgIHBhZGRpbmc6IDEwcHggMDsKICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjsKfQoKLnF1ZXJ5LWZpZWxkLWNvbHVtbi13cmFwcGVyewogICAgQGluY2x1ZGUgZmxleC1jb2x1bW4tbm93cmFwOwogICAgcGFkZGluZyA6IDAgNHB4IDZweCAwOwp9Cg=="},{"version":3,"sources":["IncidentSearch.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgfA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"IncidentSearch.vue","sourceRoot":"src/views/eval","sourcesContent":["<!--\n  - Copyright 2021 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n  - Created by s.nordt on 6/23/21\n-->\n\n<template>\n    <div class=\"page-content\">\n        <div class=\"kb-details\">\n            <div class=\"kb-description-wrapper\">\n                <div class=\"element-list-header\">\n                    <div class=\"primary-page-header-left\">Incident Search</div>\n                    <div class=\"page-header-right\">\n                        <button id=\"compare_button\" class=\"dark-app-button\" @click=\"linkToIncidentDetails()\">\n                            <v-icon class=\"button-icon\">mdi-compare</v-icon>\n                            Incident Details\n                        </button>\n                        <button id=\"doc_button\" class=\"dark-app-button\" @click=\"linkToEvalDocSearch()\">\n                            <v-icon class=\"button-icon\">mdi-file-document-box-search-outline</v-icon>\n                            Document Search\n                        </button>\n                    </div>\n                </div>\n                <span class=\"element-list-header\">Begin query by adding a named entity, role, and/or an event type</span>\n                <div class=\"query-div\">\n                    <div class=\"query-field-column-wrapper\">\n                        <MultiSelectAutoComplete\n                             :items=\"namedEntities\"\n                             :required=\"false\"\n                             :placeholder=\"'Named Entities'\"\n                             :index=2\n                             :message=\"'No named entities available'\"\n                             @autoCompleteSubmission=\"updateEntityNames($event)\"\n                             @autoCompleteClear=\"updateEntityNames($event)\"\n                        ></MultiSelectAutoComplete>\n                        <MultiSelectAutoComplete\n                            :items=\"roles\"\n                            :required=\"false\"\n                            :placeholder=\"'Roles'\"\n                            :index=1\n                            :message=\"'No roles available'\"\n                            @autoCompleteSubmission=\"updateRoles($event)\"\n                            @autoCompleteClear=\"updateRoles($event)\"\n                        ></MultiSelectAutoComplete>\n                        <MultiSelectAutoComplete\n                             :items=\"eventTypes\"\n                             :required=\"false\"\n                             :placeholder=\"'Event Types'\"\n                             :index=0\n                             :message=\"'No event types available'\"\n                             @autoCompleteSubmission=\"updateEventTypes($event)\"\n                             @autoCompleteClear=\"updateEventTypes($event)\"\n                        ></MultiSelectAutoComplete>\n                    </div>\n                    <div class=\"footer-button-wrapper\">\n                        <div>\n                            <button type=\"submit\" class=\"dark-gray-submit-button\" @click.prevent=\"updateSearchForm(views.resetQuery.type)\">\n                                Reset\n                            </button>\n                            <button type=\"submit\" ref=\"searchButton\" class=\"dark-teal-submit-button\" @click.prevent=\"updateSearchForm(views.claimResults.type)\">\n                                Search\n                            </button>\n                        </div>\n                        <hr class=\"hr-fade\">\n                    </div>\n                </div>\n            </div>\n        </div>\n        <Claims :ref=\"resultsAnchor\" :searchType=\"SEARCHTYPES.multi\" :claimSearchFilters=\"formattedClaims\" @completedSearch=completedSearch($event) ></Claims>\n    </div>\n</template>\n\n<script>\n    import MultiSelectAutoComplete from '@/components/MultiSelectAutoComplete';\n    import Claims from '@/views/analyze/Claims';\n    import {mapMutations} from 'vuex';\n    import {\n        SEARCHTYPES,\n        INCIDENTMAPPING,\n        getType,\n        getRole,\n        cleanName,\n        sortCaseInsensitive\n    } from '../../utils';\n    import API from '../../api';\n\n    //const currentRequests = new Map();\n    const CLAIMFILTERS = {\n        event: 'eventFilter',\n        entity: 'entityFilter',\n        role: 'roleFilter'\n    };\n\n    class View {\n        constructor (type, disabled) {\n            this.type = type;\n            this.disabled = disabled;\n        }\n    }\n\n     class Filter {\n         constructor() {\n             this.entityIds = [];\n             this.eventTypes = [];\n             this.roles = [];\n         }\n     }\n\n    class QueryValues {\n        constructor() {\n            this[CLAIMFILTERS.entity] = {};\n            this[CLAIMFILTERS.event] = {};\n            this[CLAIMFILTERS.role] = {};\n        }\n    }\n\n    function initialState() {\n        return {\n            claimFilters: {},\n            formattedFilters: [],\n            queryEventTypes : {},\n            queryNamedEntities: {},\n            queryRoles: {},\n            allQueryValues: {},\n            resultsAnchor: 'claim_results',\n            views: {\n                resetQuery: new View('resetQuery', false),\n                claimResults: new View('claimResults', true)\n            }\n        }\n    }\n    export default {\n        name: 'IncidentSearch',\n        components: {Claims, MultiSelectAutoComplete},\n        data: () => (initialState()),\n        created() {\n            this.CLAIMFILTERS = CLAIMFILTERS;\n            this.SEARCHTYPES = SEARCHTYPES;\n            this.INCIDENTMAPPING = INCIDENTMAPPING;\n        },\n        mounted() {\n            window.scroll({\n                top: 0,\n                behavior: 'smooth'\n            });\n            this.resetQueryForm();\n        },\n        computed: {\n           eventTypes() {\n               return this.getPrettyLabels(this.queryEventTypes);\n           },\n            namedEntities() {\n               return this.getPrettyLabels(this.queryNamedEntities);\n            },\n            roles() {\n                return this.getPrettyLabels(this.queryRoles);\n            },\n            formattedClaims() {\n               return this.formattedFilters;\n            },\n            sinIds() {\n                return INCIDENTMAPPING.map(v => v.id);\n            }\n        },\n        methods: {\n            ...mapMutations(['updateSinSelection']),\n            linkToEvalDocSearch () {\n                window.open('https://blackbox.verdi.nextcentury.com/', '_blank');\n            },\n            linkToIncidentDetails () {\n                this.$router.push('/eval/incident_detail');\n            },\n            completedSearch(value) {\n                this.$refs.searchButton.disabled = !value\n            },\n            getPrettyLabels(items) {\n                //remove duplicates and sort\n               return  Object.keys(items) ? sortCaseInsensitive([...Object.keys(items)]) : items;\n            },\n            scrollToResults() {\n                this.$nextTick(() => {\n                    const el = this.$refs[this.resultsAnchor].$el;\n                    if(el) {\n                        el.scrollIntoView({ top: 'position', behavior: 'smooth' })\n                    }\n                });\n            },\n            setClaimFilters(keys, querySet, filter) {\n                let filters = [];\n                for (const key of keys) {\n                    const URIs = this[querySet][key] ? this[querySet][key] : [];\n                    filters = [...filters, ...URIs];\n                }\n                this.claimFilters[filter] = [...new Set(filters)];\n            },\n            updateEventTypes(types) {\n                this.claimFilters.eventTypes = [];\n                if(types.length > 0) {\n                    this.setClaimFilters(types, 'queryEventTypes', 'eventTypes');\n                    const entityIds = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.ids))];\n                    const roleIds = [...new Set(this.claimFilters.roles.flatMap(role => role.ids))];\n                    const eventTypeIds = [...new Set(this.claimFilters.eventTypes.flatMap(e => e.ids))];\n                    //update roles and names for the claimFilter if they don't have selected values already\n                    if(this.claimFilters.roles.length === 0) {\n                        this.getRoles(eventTypeIds, entityIds);\n                    }\n                    if(this.claimFilters.entityIds.length === 0) {\n                        this.getEntityNames(eventTypeIds, roleIds);\n                    }\n                }\n                else {\n                    //no type filters submitted, reset roles and names\n                    this.getRoles();\n                    this.getEntityNames();\n                }\n            },\n            updateRoles(roles) {\n                this.claimFilters.roles = [];\n                if(roles.length > 0) {\n                    this.setClaimFilters(roles, 'queryRoles', 'roles');\n                    const entityIds = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.ids))];\n                    const roleIds = [...new Set(this.claimFilters.roles.flatMap(role => role.ids))];\n                    const eventTypeIds = [...new Set(this.claimFilters.eventTypes.flatMap(e => e.ids))];\n\n                    //update event types and names for the claimFilter if they don't have selected values already\n                    if(this.claimFilters.eventTypes.length === 0) {\n                        this.getEventTypes(roleIds, entityIds);\n                    }\n                    if(this.claimFilters.entityIds.length === 0) {\n                        this.getEntityNames(eventTypeIds, roleIds);\n                    }\n                }\n                else {\n                    //no type filters submitted, reset event types and names\n                    this.getEventTypes();\n                    this.getEntityNames();\n                }\n            },\n            updateEntityNames(names) {\n                this.claimFilters.entityIds = [];\n                if(names.length > 0) {\n                    //When events change, clear filters and add new ones\n                    this.setClaimFilters(names, 'queryNamedEntities', 'entityIds');\n                    const entityIds = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.ids))];\n                    const roleIds = [...new Set(this.claimFilters.roles.flatMap(role => role.ids))];\n                    const eventTypeIds = [...new Set(this.claimFilters.eventTypes.flatMap(e => e.ids))];\n\n                    //update event types and roles for the claimFilter if they don't have selected values already\n                    if(this.claimFilters.eventTypes.length === 0) {\n                        this.getEventTypes(roleIds,  entityIds);\n                    }\n                    if(this.claimFilters.roles.length === 0) {\n                        this.getRoles(eventTypeIds, entityIds);\n                    }\n                }\n                else {\n                    //no type filters submitted, reset event types and role\n                    this.getEventTypes();\n                    this.getRoles();\n                }\n            },\n            getEventTypes(roles = [], ids = []) {\n                const noFilters = roles.length === 0 && ids.length === 0;\n                //No need to re-run API for the original query values\n                if(Object.keys(this.allQueryValues[CLAIMFILTERS.event]).length > 0 && noFilters) {\n                    this.queryEventTypes = this.allQueryValues[CLAIMFILTERS.event];\n                }\n                else {\n                    API.getAllSinEventTypes(roles, ids).then(response => {\n                        if (response.data.length > 0) {\n                            //event type keys are the clean event types with URI removed\n                            let types = {};\n                            for (const type of response.data) {\n                                const transformedType = getType(type);\n                                const typeIdObject = {type: transformedType, ids: type};\n                                if (types.hasOwnProperty(transformedType)) {\n                                    types[transformedType] = [...types[transformedType], typeIdObject];\n                                }\n                                else {\n                                    types[transformedType] = [typeIdObject];\n                                }\n                            }\n                            //if there are no filters and the original query values haven't been set, set allQueryValues\n                            if (noFilters) {\n                                this.allQueryValues[CLAIMFILTERS.event] = types;\n                            }\n\n                            this.queryEventTypes = types;\n                        }\n                        else {\n                            this.queryEventTypes = {};\n                        }\n                    }).catch((error) => {\n                        console.warn(error)\n                    });\n                }\n            },\n            getRoles(eventTypes = [], ids = []) {\n                const noFilters = eventTypes.length === 0 && ids.length === 0;\n                //No need to re-run API for the original query values\n                if(Object.keys(this.allQueryValues[CLAIMFILTERS.role]).length > 0 && noFilters) {\n                    this.queryRoles = this.allQueryValues[CLAIMFILTERS.role];\n                }\n                else {\n                    API.getAllSinRoles(eventTypes, ids).then(response => {\n                        if(response.data.length > 0 ) {\n                            //role URIs will be grouped by the truncated role name\n                            let roles = {};\n                            for (const d of response.data) {\n                                const truncRole = getRole(d);\n                                const roleIdObject = {role: truncRole, ids: d};\n                                if(roles.hasOwnProperty(truncRole)) {\n                                    roles[truncRole] = [...roles[truncRole], roleIdObject];\n                                }\n                                else {\n                                    roles[truncRole] = [roleIdObject];\n                                }\n                            }\n                            //if there are no filters and the original query values haven't been set, set allQueryValues\n                            if(noFilters) {\n                                this.allQueryValues[CLAIMFILTERS.role] = roles;\n                            }\n                            this.queryRoles = roles;\n                        }\n                        else {\n                            this.queryRoles = {};\n                        }\n                    }).catch((error) => {\n                        console.warn(error)\n                    });\n                }\n            },\n            getEntityNames(eventTypes = [], roles = []) {\n                const noFilters = roles.length === 0 && eventTypes.length === 0;\n                //No need to re-run API for the original query values\n                if(Object.keys(this.allQueryValues[CLAIMFILTERS.entity]).length > 0 && noFilters) {\n                    this.queryNamedEntities = this.allQueryValues[CLAIMFILTERS.entity];\n                }\n                else {\n                    //event types and roles need to be cleaned up for the ElasticSearch API\n                    const esEventTypes = eventTypes.map(t => getType(t));\n                    const esRoles = roles.map(r => getRole(r));\n                    API.getAllSinNames(esEventTypes, esRoles).then(response => {\n                        if (response.data.length > 0) {\n                            //name keys are the actual name while the\n                            let names = {};\n                            for (const name of response.data) {\n                                //clean name in order to sort for multi-select autocomplete\n                                const canonicalName = cleanName(name.id);\n                                const nameIdObject = {name: name.id, ids: name.entities};\n                                if (names.hasOwnProperty(canonicalName)) {\n                                    //No longer using entityIds, names[canonicalName] = [...new Set([...names[canonicalName], ...name.entities])];\n                                    names[canonicalName] = [...names[canonicalName], nameIdObject];\n                                } else {\n                                    //No longer using entityIds, - names[canonicalName] = name.entities;\n                                    names[canonicalName] = [nameIdObject];\n                                }\n                            }\n\n                            //if there are no filters and the original query values haven't been set, set allQueryValues\n                            if (noFilters) {\n                                this.allQueryValues[CLAIMFILTERS.entity] = names;\n                            }\n\n                            this.queryNamedEntities = names;\n                        }\n                        else {\n                            this.queryNamedEntities = {};\n                        }\n                    }).catch((error) => {\n                        console.warn(error)\n                    });\n                }\n            },\n            updateSearchForm(viewType) {\n                if(viewType === this.views.resetQuery.type) {\n                    Object.assign(this.$data, initialState());\n                    this.resetQueryForm();\n                }\n                else if(viewType === this.views.claimResults.type) {\n                    this.views[viewType].disabled = false;\n                    this.formattedFilters = this.formatClaimFilters();\n                    this.scrollToResults();\n                }\n            },\n            resetQueryForm() {\n                this.claimFilters = new Filter();\n                this.allQueryValues = new QueryValues();\n\n                //fetch the query values for all SINs/Incidents\n                this.getEventTypes();\n                this.getRoles();\n                this.getEntityNames();\n            },\n            formatClaimFilters() {\n                let formattedFilters = [];\n                //event type filters were submitted\n                if(this.claimFilters.eventTypes.length > 0) {\n                    //for each event type add a filter object. For each role, add an arguments array to the event filter object. If entity ids exist, add them to the argument object in the array\n                    const eventTypes = [...new Set(this.claimFilters.eventTypes.flatMap(e => e.type))];\n                    for (const eventType of eventTypes) {\n                        if (this.claimFilters.roles.length > 0) {\n                            //Create arguments for each role and id pair\n                            const roles = [...new Set(this.claimFilters.roles.flatMap(r => r.role))];\n                            for (const role of roles) {\n                                if (this.claimFilters.entityIds.length > 0) {\n                                    //changing to names since ES query accepts names\n                                    const entityNames = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.name))];\n                                    for (const name of entityNames) {\n                                        let filterObject = {['eventType']: eventType, ['arguments'] : []};\n                                        let argumentObject = {['role'] : role};\n                                        argumentObject['ids'] = [name];\n                                        filterObject['arguments'].push(argumentObject);\n                                        formattedFilters.push(filterObject);\n                                    }\n                                }\n                                else {\n                                    let filterObject = {['eventType']: eventType, ['arguments'] : []};\n                                    filterObject['arguments'].push({['role'] : role});\n                                    formattedFilters.push(filterObject);\n                                }\n                            }\n                        }\n                        else if (this.claimFilters.entityIds.length > 0) {\n                            //changing to names since ES query accepts names\n                            const entityNames = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.name))];\n                            for(const name of entityNames) {\n                                let filterObject = {['eventType']: eventType, ['arguments'] : []};\n                                let argumentObject = {['ids'] : [name]};\n                                filterObject['arguments'].push(argumentObject);\n                                formattedFilters.push(filterObject);\n                            }\n                        }\n                        else {\n                            //only add event type\n                            let reformat = {['eventType']: eventType};\n                            formattedFilters.push(reformat);\n\n                        }\n                    }\n                }\n                //role filters were submitted without event types\n                else if(this.claimFilters.roles.length > 0) {\n                    //for each role and id pair, add an argument to the arguments array\n                    const roles = [...new Set(this.claimFilters.roles.flatMap(r => r.role))];\n                    for (const role of roles) {\n                        if (this.claimFilters.entityIds.length > 0) {\n                            //changing to names since ES query accepts names\n                            const entityNames = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.name))];\n                            for (const name of entityNames) {\n                                let filterObject = {['arguments'] : []};\n                                let argumentObject = {['role'] : role};\n                                argumentObject['ids'] = [name];\n                                filterObject['arguments'].push(argumentObject);\n                                formattedFilters.push(filterObject);\n                            }\n                        }\n                        else {\n                            let filterObject = {['arguments'] : []};\n                            filterObject['arguments'].push({['role'] : role});\n                            formattedFilters.push(filterObject);\n                        }\n                    }\n                }\n                //named entity filters were submitted without event types or roles\n                else if(this.claimFilters.entityIds.length > 0) {\n                    const entityNames = [...new Set(this.claimFilters.entityIds.flatMap(entity => entity.name))];\n                    for(const name of entityNames) {\n                        let filterObject = {['arguments'] : []};\n                        let argumentObject = {['ids'] : [name]};\n                        filterObject['arguments'].push(argumentObject);\n                        formattedFilters.push(filterObject);\n                    }\n                }\n                else {\n                    console.warn('no filters submitted')\n                }\n                return formattedFilters;\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .query-div {\n        @extend .kb-description-wrapper;\n        padding: 10px 0;\n        justify-content: space-between;\n    }\n\n    .query-field-column-wrapper{\n        @include flex-column-nowrap;\n        padding : 0 4px 6px 0;\n    }\n</style>\n\n"]}]}