{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/Claims.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/Claims.vue","mtime":1640207172535},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/babel-loader/lib/index.js","mtime":1641411773354},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBEYXRhVGFibGUgZnJvbSAnQC9jb21wb25lbnRzL0RhdGFUYWJsZSc7CmltcG9ydCB7IG1hcE11dGF0aW9ucywgbWFwU3RhdGUsIG1hcEFjdGlvbnN9IGZyb20gJ3Z1ZXgnOwppbXBvcnQgQVBJIGZyb20gJy4uLy4uL2FwaSc7CmltcG9ydCBDYXRlZ29yeVR5cGVzIGZyb20gJ0AvYXNzZXRzL2RhdGEvdHlwZXMuanNvbic7CmltcG9ydCBJbmZvVG9vbHRpcCBmcm9tICdAL2NvbXBvbmVudHMvSW5mb1Rvb2x0aXAnOwppbXBvcnQgewogICAgVEFCTEVTRUxFQ1RJT05TLAogICAgVEFCTEVGSUVMRE1BUFBJTkcsCiAgICBEQVRBVFlQRVMsCiAgICBMT0FESU5HTUVTU0FHRSwKICAgIE5PREFUQU1FU1NBR0UsCiAgICBTRUFSQ0hUWVBFUywKICAgIGdldFNpbkFyZ3VtZW50SGVhZGxpbmUsCiAgICBTZWNvbmRhcnlFeHBhbmQsCiAgICBmb3JtYXRTaW5zQ2xhaW1zLAogICAgc29ydENhc2VJbnNlbnNpdGl2ZSwKICAgIGdldFR5cGUsCiAgICBnZXRSb2xlLAogICAgZ2V0RW50aXR5TmFtZSwKICAgIGdldEluY2lkZW50TmFtZSwKICAgIGdldEVudGl0eUlkZW50aWZpZXJzLAogICAgZ2V0VGVtcGxhdGUsCiAgICBnZXRUZW1wbGF0ZVByZWRpY2F0ZSwKICAgIGdldFR5cGVzRnJvbVF1ZXJ5LAogICAgZ2V0VHJhbnNmb3JtZWRUeXBlLAogICAgZ2V0TGFzdFN1YlR5cGUsCiAgICBzcG9uc29yVHlwZXMsCiAgICBUYWJsZVNldHRpbmdzLAogICAgSGVhZGVyQ29uZmlnCn0gZnJvbSAnLi4vLi4vdXRpbHMnOwoKY29uc3QgY3VycmVudFJlcXVlc3RzID0gbmV3IE1hcCgpOwpleHBvcnQgZGVmYXVsdCB7CiAgICBuYW1lOiAnQ2xhaW1zJywKICAgIHByb3BzOiB7CiAgICAgICAgc2VhcmNoVHlwZTogewogICAgICAgICAgICB0eXBlOiBTdHJpbmcsCiAgICAgICAgICAgIGRlZmF1bHQ6IFNFQVJDSFRZUEVTLnNpbmdsZSwKICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICBjbGFpbVNlYXJjaFNpbklkOiB7CiAgICAgICAgICAgIHR5cGU6IFN0cmluZywKICAgICAgICAgICAgZGVmYXVsdDogbnVsbCwKICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICBjbGFpbVNlYXJjaEZpbHRlcnM6IHsKICAgICAgICAgICAgdHlwZTogQXJyYXksCiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsCiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZQogICAgICAgIH0sCiAgICB9LAogICAgY29tcG9uZW50czoge0RhdGFUYWJsZSwgSW5mb1Rvb2x0aXB9LAogICAgZGF0YTogKCkgPT4gKHsKICAgICAgICBzb3J0OiB7W1RBQkxFU0VMRUNUSU9OUy5zb3J0QnldOiBUQUJMRUZJRUxETUFQUElORy5zdGF0ZW1lbnQsIFtUQUJMRVNFTEVDVElPTlMuc29ydERlc2NdOiBmYWxzZX0sCiAgICAgICAgcGFnaW5nOiB7W1RBQkxFU0VMRUNUSU9OUy5pdGVtc1BlclBhZ2VdOidBbGwnfSwKICAgICAgICBzdGF0dXNNZXNzYWdlOiAnJywKICAgICAgICBjbGFpbXM6IHt9LAogICAgICAgIG1lbWJlclR5cGVzOiBbXSwKICAgICAgICBpbmNpZGVudFR5cGVzOiB7fSwKICAgICAgICBTSU46IHt9LAogICAgICAgIGxvYWRpbmc6IGZhbHNlLAogICAgICAgIHRvZ2dsZVRhYmxlczoge30KICAgIH0pLAogICAgY3JlYXRlZCgpIHsKICAgICAgICB0aGlzLlRBQkxFRklFTERNQVBQSU5HID0gVEFCTEVGSUVMRE1BUFBJTkc7CiAgICAgICAgdGhpcy5EQVRBVFlQRVMgPSBEQVRBVFlQRVM7CiAgICAgICAgdGhpcy5sb2FkaW5nICA9IHRydWU7CiAgICAgICAgdGhpcy5zdGF0dXNNZXNzYWdlID0gTE9BRElOR01FU1NBR0U7CiAgICAgICAgdGhpcy5OT0RBVEFNRVNTQUdFID0gTk9EQVRBTUVTU0FHRTsKICAgICAgICB0aGlzLlNFQVJDSFRZUEVTID0gU0VBUkNIVFlQRVM7CiAgICB9LAogICAgbW91bnRlZCgpIHsKICAgICAgICB0aGlzLnVwZGF0ZUh5cG90aGVzaXNTZWxlY3Rpb24oe30pOwogICAgfSwKICAgIGNvbXB1dGVkOiB7CiAgICAgICAgLi4ubWFwU3RhdGUoWydkZWZhdWx0SHlwb3RoZXNpc0RhdGFTb3VyY2UnLCAnaHlwb3RoZXNpc1NlbGVjdGlvbicsJ2N1cnJlbnREYXRhU291cmNlJywgJ3NpblNlbGVjdGlvbicsICd0ZXJtJywgJ2RhdGFTb3VyY2VMaXN0J10pLAogICAgICAgIHR5cGVzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJUeXBlcy5sZW5ndGggPiAwID8gdGhpcy5tZW1iZXJUeXBlcyA6IG51bGw7CiAgICAgICAgfSwKICAgICAgICBpbmNpZGVudHMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmluY2lkZW50VHlwZXM7CiAgICAgICAgfSwKICAgICAgICBzaW5EYXRhKCkgewogICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jbGFpbXMpLmxlbmd0aCA+IDAgPyB0aGlzLmNsYWltcyA6IG51bGw7CiAgICAgICAgfSwKICAgICAgICBzaW5JZCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2luU2VsZWN0aW9uW1RBQkxFRklFTERNQVBQSU5HLnNpbkxpc3RdID8gdGhpcy5zaW5TZWxlY3Rpb25bVEFCTEVGSUVMRE1BUFBJTkcuc2luTGlzdF1bMF0gOiB0aGlzLmNsYWltc1NlYXJjaFNpbklkID8gdGhpcy5jbGFpbXNTZWFyY2hTaW5JZCA6ICcnOwogICAgICAgIH0sCiAgICAgICAgY2xhaW1zVG9waWMoKSB7CiAgICAgICAgICAgIGlmKHRoaXMuc2luSWQgJiYgdGhpcy5zZWFyY2hUeXBlID09PSBTRUFSQ0hUWVBFUy5zaW5nbGUgfHwgdGhpcy5zZWFyY2hUeXBlID09PSBTRUFSQ0hUWVBFUy5tdWx0aSkgewogICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2xhaW1zKCk7CiAgICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlcm0gJiYgdGhpcy50ZXJtLmlucHV0ID8gdGhpcy50ZXJtLmlucHV0IDogJyc7CiAgICAgICAgfSwKICAgICAgICB0b2dnbGVJbmNpZGVudHMoKSB7CiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRvZ2dsZVRhYmxlcykubGVuZ3RoID4gMCA/IHRoaXMudG9nZ2xlVGFibGVzIDogbnVsbDsKICAgICAgICB9CiAgICB9LAogICAgbWV0aG9kczogewogICAgICAgIC4uLm1hcE11dGF0aW9ucyhbJ3VwZGF0ZUh5cG90aGVzaXNTZWxlY3Rpb24nXSksCiAgICAgICAgLi4ubWFwQWN0aW9ucyhbJ3VwZGF0ZUN1cnJlbnREYXRhU291cmNlJ10pLAogICAgICAgIGJ1aWxkVGFibGVDb25maWd1cmF0aW9uKHR5cGUpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHRhYmxlU2V0dGluZ3M6IG5ldyBUYWJsZVNldHRpbmdzKFRBQkxFRklFTERNQVBQSU5HLmlkLCB0cnVlLCB0eXBlLCAnJywgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnc3RhdGVtZW50JywgZmFsc2UsIHRydWUpLAogICAgICAgICAgICAgICAgcHJpbWFyeUhlYWRlcnM6IFsKICAgICAgICAgICAgICAgICAgICBuZXcgSGVhZGVyQ29uZmlnKCdTdGF0ZW1lbnQnLCAnc3RhcnQnLCB0cnVlLCBUQUJMRUZJRUxETUFQUElORy5zdGF0ZW1lbnQpLAogICAgICAgICAgICAgICAgICAgIG5ldyBIZWFkZXJDb25maWcoJ0V2ZW50IFR5cGUnLCAnc3RhcnQnLCB0cnVlLCBUQUJMRUZJRUxETUFQUElORy5jbHVzdGVyVHlwZSksCiAgICAgICAgICAgICAgICAgICAgbmV3IEhlYWRlckNvbmZpZygnRGF0ZScsICdzdGFydCcsIHRydWUsIFRBQkxFRklFTERNQVBQSU5HLmRhdGVzKSwKICAgICAgICAgICAgICAgICAgICBuZXcgSGVhZGVyQ29uZmlnKCcnLCAnY2VudGVyJywgZmFsc2UsICdkYXRhLXRhYmxlLWV4cGFuZCcpCiAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgc2Vjb25kYXJ5SGVhZGVyczogewogICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkOiBuZXcgU2Vjb25kYXJ5RXhwYW5kKCcnLCBUQUJMRUZJRUxETUFQUElORy5kb2N1bWVudExpc3QsCiAgICAgICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBIZWFkZXJDb25maWcoJ0VudGl0eScsICdzdGFydCcsIGZhbHNlLCBUQUJMRUZJRUxETUFQUElORy5oZWFkbGluZSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgSGVhZGVyQ29uZmlnKCdTdXBwb3J0aW5nIERvY3VtZW50JywgJ3N0YXJ0JywgZmFsc2UsIFRBQkxFRklFTERNQVBQSU5HLmRvY0lkKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBIZWFkZXJDb25maWcoJ0RvY3VtZW50IFRpdGxlJywgJ3N0YXJ0JywgZmFsc2UsIFRBQkxFRklFTERNQVBQSU5HLmRvY1RpdGxlKQogICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgIH0sCiAgICAgICAgdG9nZ2xlSW5jaWRlbnRTZWN0aW9uKGluZGV4KSB7CiAgICAgICAgICAgIGNvbnN0IHRvZ2dsZUlkID0gdGhpcy5nZXRUb29sdGlwSWQoaW5kZXgpOwogICAgICAgICAgICBpZih0aGlzLiRyZWZzW3RvZ2dsZUlkXS5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuJHJlZnNbdG9nZ2xlSWRdWzBdOwogICAgICAgICAgICAgICAgaWYodGhpcy50b2dnbGVUYWJsZXMuaGFzT3duUHJvcGVydHkodG9nZ2xlSWQpKSB7CiAgICAgICAgICAgICAgICAgICAgaWYoZWwuaWNvbiA9PT0gJ21kaS1jaGV2cm9uLWRvd24nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlVGFibGVzW3RvZ2dsZUlkXS5tZXNzYWdlID0gJ09wZW4gU2VjdGlvbic7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlVGFibGVzW3RvZ2dsZUlkXS5pY29uID0gJ21kaS1jaGV2cm9uLXVwJzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlVGFibGVzW3RvZ2dsZUlkXS5tZXNzYWdlID0gJ0Nsb3NlIFNlY3Rpb24nOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVRhYmxlc1t0b2dnbGVJZF0uaWNvbiA9ICdtZGktY2hldnJvbi1kb3duJzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGVUYWJsZXNbdG9nZ2xlSWRdLmNsb3NlZCA9ICF0aGlzLnRvZ2dsZVRhYmxlc1t0b2dnbGVJZF0uY2xvc2VkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB1cGRhdGVJdGVtcyhjdXJyZW50SXRlbXMpIHsKICAgICAgICAgICAgY29uc3QgdG9Qb3B1bGF0ZSA9IGN1cnJlbnRJdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtW1RBQkxFRklFTERNQVBQSU5HLmRvY3VtZW50TGlzdF0ubGVuZ3RoID09PSAwICYmCiAgICAgICAgICAgICAgICAhY3VycmVudFJlcXVlc3RzLmhhcyhpdGVtW1RBQkxFRklFTERNQVBQSU5HLnByb3RvdHlwZVVyaV0pKTsKCiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0b1BvcHVsYXRlKSB7CiAgICAgICAgICAgICAgICBjb25zdCBwcm90b3R5cGUgPSBpdGVtW1RBQkxFRklFTERNQVBQSU5HLnByb3RvdHlwZVVyaV07CiAgICAgICAgICAgICAgICBjb25zdCByb2xlcyA9IFsuLi5uZXcgU2V0KGl0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuZW50aXR5TGlzdF0uZmxhdE1hcChlbnRpdHkgPT4gZW50aXR5W1RBQkxFRklFTERNQVBQSU5HLnJvbGVVcmldKSldOwogICAgICAgICAgICAgICAgY29uc3QgaHlwb3RoZXNpc1VyaSA9IGl0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuaHlwb3RoZXNpc0xpc3RdWzBdOwogICAgICAgICAgICAgICAgY29uc3QgZ3JhcGggPSAhdGhpcy5jbGFpbVNlYXJjaFNpbklkID8gdGhpcy5jdXJyZW50RGF0YVNvdXJjZSA6ICcnOwogICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IEFQSS5nZXRTaW5Eb2N1bWVudHMocHJvdG90eXBlLCBncmFwaCwgaHlwb3RoZXNpc1VyaSwgcm9sZXMpOwoKCiAgICAgICAgICAgICAgICBjdXJyZW50UmVxdWVzdHMuc2V0KHByb3RvdHlwZSwgcHJvbWlzZSk7CiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZG9jcyA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkRG9jcyA9IG5ldyBNYXAoKTsKICAgICAgICAgICAgICAgICAgICBpZihPYmplY3Qua2V5cyhkb2NzLmRhdGEpLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZG9jcy5kYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2NMaXN0ID0gb2JqZWN0W1RBQkxFRklFTERNQVBQSU5HLmRvY3VtZW50TGlzdF07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJndW1lbnRTdHJpbmcgPSAnJzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9iamVjdC5xdWVyeU9iamVjdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKERBVEFUWVBFUy5lbnRpdHlUeXBlLmlkKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50ID0gaXRlbVtUQUJMRUZJRUxETUFQUElORy5lbnRpdHlMaXN0XS5maW5kKGVudGl0eSA9PiBlbnRpdHlbVEFCTEVGSUVMRE1BUFBJTkcucHJvdG90eXBlVXJpXSA9PT0gb2JqZWN0LnF1ZXJ5T2JqZWN0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmd1bWVudElkZW50aWZpZXIgPSBhcmd1bWVudCAmJiB0aGlzLmdldEVudGl0eUlkZW50aWZpZXJzKFthcmd1bWVudF0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50U3RyaW5nID0gYXJndW1lbnRJZGVudGlmaWVyICYmIE9iamVjdC52YWx1ZXMoYXJndW1lbnRJZGVudGlmaWVyKVswXVswXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50U3RyaW5nID0gZ2V0VGVtcGxhdGVQcmVkaWNhdGUoaXRlbVtUQUJMRUZJRUxETUFQUElORy5jbHVzdGVyVHlwZV0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihjb25zdCBkb2Mgb2YgZG9jTGlzdCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFmb3JtYXR0ZWREb2NzLmhhcyhkb2MpICYmIGFyZ3VtZW50U3RyaW5nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZERvY3Muc2V0KGRvYywge1tUQUJMRUZJRUxETUFQUElORy5kb2NJZF06IGRvYy5pZCwgW1RBQkxFRklFTERNQVBQSU5HLmRvY1RpdGxlXTogZG9jLnRpdGxlLCBbVEFCTEVGSUVMRE1BUFBJTkcuaGVhZGxpbmVdOiBbYXJndW1lbnRTdHJpbmddfSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYXJndW1lbnRTdHJpbmcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkRG9jcy5nZXQoZG9jKVtUQUJMRUZJRUxETUFQUElORy5oZWFkbGluZV0ucHVzaChhcmd1bWVudFN0cmluZyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCB0byB0dXJuIHRoZSBpdGVtcyBpbiB0aGUgc3VwcG9ydGVkIGRvY3VtZW50IGhlYWRsaW5lIGFycmF5IGludG8gYSBzaW5nbGUgc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IGZkIG9mIGZvcm1hdHRlZERvY3MudmFsdWVzKCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZmRbVEFCTEVGSUVMRE1BUFBJTkcuaGVhZGxpbmVdID0gdGhpcy5nZXRRdW90ZWRTdHJpbmdzKGZkW1RBQkxFRklFTERNQVBQSU5HLmhlYWRsaW5lXSk7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL2FkZHMgZG9jdW1lbnRzIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBjbGFpbXMgZGF0YQogICAgICAgICAgICAgICAgICAgIGl0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuZG9jdW1lbnRMaXN0XSA9IFsuLi5mb3JtYXR0ZWREb2NzLnZhbHVlcygpXTsKICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVxdWVzdHMuZGVsZXRlKHByb3RvdHlwZSk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2V0Q2xhaW1zKCkgewogICAgICAgICAgICB0aGlzLiRlbWl0KCdjb21wbGV0ZWRTZWFyY2gnLCBmYWxzZSk7CiAgICAgICAgICAgIGlmKHRoaXMuc2luSWQgJiYgdGhpcy5zaW5JZCAhPT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zZWFyY2hUeXBlID09PSBTRUFSQ0hUWVBFUy5tdWx0aSkgewogICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBnZXRUeXBlc0Zyb21RdWVyeSh0aGlzLnRlcm0gJiYgdGhpcy50ZXJtLmlucHV0IHx8ICcnKTsKICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJzID0gW107CiAgICAgICAgICAgICAgICBpZiAodHlwZXMpIHsKICAgICAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKC4uLnNwb25zb3JUeXBlcyk7CiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh7WydldmVudFR5cGUnXSA6IHR5cGV9KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgY29uc3Qgc2luRGF0YVNvdXJjZSA9IHRoaXMucmVwbGFjZURhdGFTb3VyY2VTaW5JZCgpOwogICAgICAgICAgICAgICAgaWYodGhpcy5kYXRhU291cmNlTGlzdC5pbmNsdWRlcyhzaW5EYXRhU291cmNlKSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudERhdGFTb3VyY2Uoc2luRGF0YVNvdXJjZSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IHRoaXMuY3VycmVudERhdGFTb3VyY2UgPyB0aGlzLmN1cnJlbnREYXRhU291cmNlIDogdGhpcy5kZWZhdWx0SHlwb3RoZXNpc0RhdGFTb3VyY2U7CiAgICAgICAgICAgICAgICBsZXQgcXVlcnlGaWx0ZXJzID0ge1snZ3JhcGgnXSA6IGRhdGFTb3VyY2V9OwogICAgICAgICAgICAgICAgaWYoZmlsdGVycy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgcXVlcnlGaWx0ZXJzWydmaWx0ZXJzJ10gPSBmaWx0ZXJzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzTWVzc2FnZSA9IExPQURJTkdNRVNTQUdFOwogICAgICAgICAgICAgICAgaWYoIXRoaXMuY2xhaW1TZWFyY2hTaW5JZCAmJiB0aGlzLnNlYXJjaFR5cGUgPT09IFNFQVJDSFRZUEVTLnNpbmdsZSkgewogICAgICAgICAgICAgICAgICAgIEFQSS5nZXRTaW5RdWVyeVJlc3VsdHModGhpcy5zaW5JZCwgcXVlcnlGaWx0ZXJzKS50aGVuKHJlc3BvbnNlID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2luRGF0YSA9IHJlc3BvbnNlLmRhdGE7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzaW5EYXRhKS5sZW5ndGggPiAwICYmIHNpbkRhdGEuaHlwb3RoZXNlcykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5TSU4gPSBzaW5EYXRhOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRGb3JtYXR0ZWREYXRhKHNpbkRhdGEpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNNZXNzYWdlID0gdGhpcy5OT0RBVEFNRVNTQUdFOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjb21wbGV0ZWRTZWFyY2gnLCB0cnVlKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIGlmKCF0aGlzLmNsYWltU2VhcmNoU2luSWQgJiYgdGhpcy5zZWFyY2hUeXBlID09PSBTRUFSQ0hUWVBFUy5tdWx0aSkgewogICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlcyB0aGUgY2xhaW1zIGRhdGEgYW5kIG1lbWJlciB0eXBlcwogICAgICAgICAgICAgICAgICAgIGxldCBmb3JtYXR0ZWREYXRhID0ge307CiAgICAgICAgICAgICAgICAgICAgbGV0IHRvZ2dsZURhdGEgPSB7fTsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYWltcyA9IHt9OwogICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRUeXBlcyA9IHt9OwoKICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGFpbUZpbHRlcnMgPSB0aGlzLmNsYWltU2VhcmNoRmlsdGVycy5sZW5ndGggPiAwID8ge1snZmlsdGVycyddOnRoaXMuY2xhaW1TZWFyY2hGaWx0ZXJzfSA6IHt9OwogICAgICAgICAgICAgICAgICAgIEFQSS5nZXRBbGxTaW5RdWVyeVJlc3VsdHMoY2xhaW1GaWx0ZXJzKS50aGVuKHJlc3BvbnNlID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2luRXZlbnRzID0gcmVzcG9uc2UuZGF0YTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNpbkV2ZW50cykubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9NYXAgZXZlbnRzIGJhc2VkIG9uIHNpbiBhbmQgdGhlbiBldmVudCB0eXBlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHNpbkV2ZW50cykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpblRpdGxlID0gZ2V0SW5jaWRlbnROYW1lKGV2ZW50W1RBQkxFRklFTERNQVBQSU5HLnNpbklkXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnRbVEFCTEVGSUVMRE1BUFBJTkcuY2x1c3RlclR5cGVdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZm9ybWF0dGVkRGF0YSkuaW5jbHVkZXMoc2luVGl0bGUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZERhdGFbc2luVGl0bGVdID0ge307CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGZvcm1hdHRlZERhdGFbc2luVGl0bGVdKS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkRGF0YVtzaW5UaXRsZV0gPSB7W2V2ZW50VHlwZV0gOiB7fX07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoIU9iamVjdC5rZXlzKGZvcm1hdHRlZERhdGFbc2luVGl0bGVdKS5pbmNsdWRlcyhldmVudFR5cGUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZERhdGFbc2luVGl0bGVdW2V2ZW50VHlwZV0gPSB7fTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQmVmb3JlIGFkZGluZyB0aGUgZXZlbnQsIGZvcm1hdCByb2xlcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGV2ZW50W1RBQkxFRklFTERNQVBQSU5HLmVudGl0eUxpc3RdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eVtUQUJMRUZJRUxETUFQUElORy5yb2xlc10gPSBzb3J0Q2FzZUluc2Vuc2l0aXZlKFsuLi5uZXcgU2V0KGVudGl0eVtUQUJMRUZJRUxETUFQUElORy5yb2xlVXJpXS5mbGF0TWFwKGdldFJvbGUpKV0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50W1RBQkxFRklFTERNQVBQSU5HLmh5cG90aGVzaXNMaXN0XSA9IFtldmVudC5oeXBvdGhlc2lzXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFtUQUJMRUZJRUxETUFQUElORy5jYXRlZ29yeV0gPSBldmVudFtUQUJMRUZJRUxETUFQUElORy5jbHVzdGVyQ2F0ZWdvcnldOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ZSA9IG51bGw7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXZlbnQuZGF0ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gZXZlbnQuZGF0ZS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFtUQUJMRUZJRUxETUFQUElORy5kYXRlc10gPSBldmVudC5kYXRlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZXZlbnRbVEFCTEVGSUVMRE1BUFBJTkcuc3RhdGVtZW50XSArIGV2ZW50W1RBQkxFRklFTERNQVBQSU5HLmNsdXN0ZXJUeXBlXSArICBkYXRlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50W1RBQkxFRklFTERNQVBQSU5HLmlkXSA9IGtleTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kZWR1cGxpY2F0ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFmb3JtYXR0ZWREYXRhW3NpblRpdGxlXVtldmVudFR5cGVdLmhhc093blByb3BlcnR5KGtleSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkRGF0YVtzaW5UaXRsZV1bZXZlbnRUeXBlXVtrZXldID0gZXZlbnQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGtleXMgZnJvbSBldmVudCBvYmplY3QKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgc2luIGluIGZvcm1hdHRlZERhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmb3JtYXR0ZWREYXRhLmhhc093blByb3BlcnR5KHNpbikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBldmVudFR5cGUgaW4gZm9ybWF0dGVkRGF0YVtzaW5dKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmb3JtYXR0ZWREYXRhW3Npbl0uaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZERhdGFbc2luXVtldmVudFR5cGVdID0gT2JqZWN0LnZhbHVlcyhmb3JtYXR0ZWREYXRhW3Npbl1bZXZlbnRUeXBlXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFpbXMgPSBmb3JtYXR0ZWREYXRhOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihjb25zdCBbaW5jaWRlbnQsIHR5cGVzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmNsYWltcykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50VHlwZXNbaW5jaWRlbnRdID0gT2JqZWN0LmtleXModHlwZXMpLnNvcnQoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpIDxPYmplY3Qua2V5cyh0aGlzLmluY2lkZW50VHlwZXMpLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlRGF0YVt0aGlzLmdldFRvb2x0aXBJZChpKV0gPSB7bWVzc2FnZSA6ICdDbG9zZSBTZWN0aW9uJywgaWNvbiA6ICdtZGktY2hldnJvbi1kb3duJywgY2xvc2VkIDogZmFsc2V9OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGVUYWJsZXMgPSB0b2dnbGVEYXRhOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY29tcGxldGVkU2VhcmNoJywgdHJ1ZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c01lc3NhZ2UgPSB0aGlzLk5PREFUQU1FU1NBR0U7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NvbXBsZXRlZFNlYXJjaCcsIHRydWUpOwogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGFpbUZpbHRlcnMgPSB0aGlzLmNsYWltU2VhcmNoRmlsdGVycy5sZW5ndGggPiAwID8ge1snZmlsdGVycyddOnRoaXMuY2xhaW1TZWFyY2hGaWx0ZXJzfSA6IHt9OwogICAgICAgICAgICAgICAgICAgIEFQSS5nZXRTaW5RdWVyeVJlc3VsdHModGhpcy5jbGFpbVNlYXJjaFNpbklkLCBjbGFpbUZpbHRlcnMpLnRoZW4ocmVzcG9uc2UgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaW5EYXRhID0gcmVzcG9uc2UuZGF0YTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNpbkRhdGEpLmxlbmd0aCA+IDAgJiYgc2luRGF0YS5oeXBvdGhlc2VzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlNJTiA9IHNpbkRhdGE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEZvcm1hdHRlZERhdGEoc2luRGF0YSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c01lc3NhZ2UgPSB0aGlzLk5PREFUQU1FU1NBR0U7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NvbXBsZXRlZFNlYXJjaCcsIHRydWUpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcikKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzTWVzc2FnZSA9IHRoaXMuTk9EQVRBTUVTU0FHRTsKICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlOwogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY29tcGxldGVkU2VhcmNoJywgdHJ1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGFkZFNwb25zb3JlZChzcG9uc29yZWQsIG1lbWJlcikgewogICAgICAgICAgICBjb25zdCBldmVudHMgPSBtZW1iZXIucm9sZXMuZmluZChyb2xlID0+IHJvbGUucm9sZS5pbmNsdWRlcygnX0FjdG9yT3JFdmVudCcpKTsKICAgICAgICAgICAgbGV0IHNwb25zb3JSb2xlcyA9IG1lbWJlci5yb2xlcy5maW5kKHJvbGUgPT4gcm9sZS5yb2xlLmluY2x1ZGVzKCdfU3BvbnNvcicpKTsKICAgICAgICAgICAgaWYgKGV2ZW50cyAmJiBzcG9uc29yUm9sZXMpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHNwb25zb3JzID0gbmV3IFNldCgpOwogICAgICAgICAgICAgICAgZm9yIChjb25zdCBzcG9uc29yIG9mIHNwb25zb3JSb2xlcy5hcmd1bWVudHMpICB7CiAgICAgICAgICAgICAgICAgICAgc3BvbnNvcltUQUJMRUZJRUxETUFQUElORy5oZWFkbGluZV0gPSBnZXRTaW5Bcmd1bWVudEhlYWRsaW5lKHNwb25zb3IpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRFbnRpdHlOYW1lKHNwb25zb3IpOwogICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNwb25zb3JzLmFkZChuYW1lKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3BvbnNvcnMuc2l6ZSkgewogICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzLmFyZ3VtZW50cykgewogICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BvbnNvcmVkRXZlbnQgPSBzcG9uc29yZWRbZXZlbnQuaWRdOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNwb25zb3JlZEV2ZW50KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcG9uc29yZWRFdmVudCA9IHNwb25zb3JlZFtldmVudC5pZF0gPSBbXTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBzcG9uc29yZWRFdmVudC5wdXNoKC4uLnNwb25zb3JzKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGdldFRvb2x0aXBJZChpZCkgewogICAgICAgICAgICByZXR1cm4gJ2luY2lkZW50VG9vbHRpcCcgKyBpZDsKICAgICAgICB9LAogICAgICAgIGdldEZvcm1hdHRlZERhdGEoc2luKSB7CiAgICAgICAgICAgIGNvbnN0IG1lbWJlcnMgPSBuZXcgTWFwKCk7CiAgICAgICAgICAgIGZvciAoY29uc3QgaHlwT2JqZWN0IG9mIHNpbi5oeXBvdGhlc2VzIHx8IFtdKSB7CiAgICAgICAgICAgICAgICBjb25zdCBzcG9uc29yZWQgPSB7fTsKICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGh5cE9iamVjdC5tZW1iZXJzKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBnZXRUeXBlKG1lbWJlcltUQUJMRUZJRUxETUFQUElORy5jYXRlZ29yeV0pLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGUobWVtYmVyLnR5cGUpOwogICAgICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gREFUQVRZUEVTLnJlbGF0aW9uVHlwZS5pZCAmJiBtZW1iZXIucm9sZXMubGVuZ3RoID09PSAyICYmIHR5cGUuaW5jbHVkZXMoJ1Nwb25zb3JzaGlwJykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTcG9uc29yZWQoc3BvbnNvcmVkLCBtZW1iZXIpOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBhcmUgbm8gYXJndW1lbnRzIHRoZW4gdGhlcmUgaXMgbm8gbmVlZCB0byBzaG93IHRoZSBtZW1iZXIKICAgICAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09IERBVEFUWVBFUy5ldmVudFR5cGUuaWQgJiYgbWVtYmVyLnJvbGVzLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcm1hdHRlZE1lbWJlciA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG1lbWJlci5ub2RlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlOiBtZW1iZXIucHJvdG90eXBlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGVzOiBbLi4ubmV3IE1hcChtZW1iZXIucm9sZXMubWFwKHJvbGUgPT4gW3JvbGUsIHJvbGVdKSkudmFsdWVzKCldLnNvcnQoKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5cG90aGVzZXM6IFtoeXBPYmplY3QuaHlwb3RoZXNpc10sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlczogbWVtYmVyLmRhdGVzCiAgICAgICAgICAgICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRNZW1iZXIgPSBmb3JtYXRTaW5zQ2xhaW1zKGZvcm1hdHRlZE1lbWJlciwgREFUQVRZUEVTLmV2ZW50VHlwZS5pZCwgdHlwZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXJzID0gZ2V0RW50aXR5SWRlbnRpZmllcnMoZm9ybWF0dGVkTWVtYmVyW1RBQkxFRklFTERNQVBQSU5HLmVudGl0eUxpc3RdKTsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BvbnNvciA9IHNwb25zb3JlZFttZW1iZXIubm9kZV07CiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZE1lbWJlcltUQUJMRUZJRUxETUFQUElORy5zdGF0ZW1lbnRdID0gZ2V0VGVtcGxhdGUodHlwZSwgaWRlbnRpZmllcnMpICsgKHNwb25zb3IgPyAnIChzcG9uc29yOiAnICsgc3BvbnNvciArICcpJyA6ICcnKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFR5cGUgPSBnZXRUcmFuc2Zvcm1lZFR5cGUoZ2V0TGFzdFN1YlR5cGUodHlwZSksIENhdGVnb3J5VHlwZXMuZXZlbnRUeXBlTWFwcGluZyk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVtYmVycy5oYXMoZm9ybWF0dGVkVHlwZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlcnMuc2V0KGZvcm1hdHRlZFR5cGUsIFtdKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXJzLmdldChmb3JtYXR0ZWRUeXBlKS5wdXNoKGZvcm1hdHRlZE1lbWJlcik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBjcmVhdGUgb2JqZWN0IG9mIHR5cGUtPlttZW1iZXJzXQogICAgICAgICAgICBjb25zdCBtZW1iZXJzUmVkdWNlID0ge307CiAgICAgICAgICAgIG1lbWJlcnMuZm9yRWFjaCgodmFsdWVzLCBrZXkpID0+IHsKICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB2YWx1ZXMgYW5kIGFkZCB0aGVtIHRvIG1lbWJlcnNSZWR1Y2Vba2V5XQogICAgICAgICAgICAgICAgY29uc3QgZGVkdXBlZCA9IG5ldyBNYXAoKTsKICAgICAgICAgICAgICAgIGNvbnN0IGFkZE1lbWJlciA9IG1lbWJlciA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG1lbWJlci5kYXRlID8gbWVtYmVyLmRhdGUudG9TdHJpbmcoKSA6IG51bGw7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbWVtYmVyLnN0YXRlbWVudCArIG1lbWJlci50eXBlOwogICAgICAgICAgICAgICAgICAgIGlmICghZGVkdXBlZC5oYXMoa2V5KSkgewogICAgICAgICAgICAgICAgICAgICAgICBkZWR1cGVkLnNldChrZXksIG5ldyBNYXAoKSk7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGF0ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wIGR1cGxpY2F0ZXMgd2l0aG91dCBkYXRlCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbWVtYmVyLmlkID0ga2V5ICsgZGF0ZTsKICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGtlZXAgdHJhY2sgb2Ygb25lIG1lbWJlciBwZXIgZGF0ZQogICAgICAgICAgICAgICAgICAgIGRlZHVwZWQuZ2V0KGtleSkuc2V0KGRhdGUsIG1lbWJlcik7CiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgY29uc3Qgbm9EYXRlcyA9IFtdOwogICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdmFsdWVzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW1iZXIuZGF0ZSkgewogICAgICAgICAgICAgICAgICAgICAgICBub0RhdGVzLnB1c2gobWVtYmVyKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBhZGRNZW1iZXIobWVtYmVyKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBub0RhdGVzLmZvckVhY2goYWRkTWVtYmVyKTsKICAgICAgICAgICAgICAgIG1lbWJlcnNSZWR1Y2Vba2V5XSA9IFtdOwogICAgICAgICAgICAgICAgZGVkdXBlZC5mb3JFYWNoKHZhbHVlID0+IG1lbWJlcnNSZWR1Y2Vba2V5XS5wdXNoKC4uLnZhbHVlLnZhbHVlcygpKSk7CiAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7CiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NvbXBsZXRlZFNlYXJjaCcsIHRydWUpOwoKICAgICAgICAgICAgLy91cGRhdGVzIHRoZSBjbGFpbXMgZGF0YSBhbmQgbWVtYmVyIHR5cGVzCiAgICAgICAgICAgIHRoaXMuY2xhaW1zID0gbWVtYmVyc1JlZHVjZTsKICAgICAgICAgICAgdGhpcy5tZW1iZXJUeXBlcyA9IE9iamVjdC5rZXlzKG1lbWJlcnNSZWR1Y2UpLnNvcnQoKTsKICAgICAgICB9LAogICAgICAgIHJlcGxhY2VEYXRhU291cmNlU2luSWQoKSB7CiAgICAgICAgICAgIGxldCB0cnVuY2F0ZVNvdXJjZSA9IHRoaXMuY3VycmVudERhdGFTb3VyY2Uuc3BsaXQoJy8nKTsKICAgICAgICAgICAgLy9lLmcuIFtodHRwczosICwgd3d3Lm5leHRjZW50dXJ5LmNvbSwgVEEzLCBFMjAxLCBHQUlBLTIwMjEwMjAzLCBHQUlBLTIwMjEwMTE5LCBHQUlBLTIwMjEwMTE5XQogICAgICAgICAgICB0cnVuY2F0ZVNvdXJjZS5zcGxpY2UoNCwgMSwgdGhpcy5zaW5JZCk7CiAgICAgICAgICAgIHJldHVybiB0cnVuY2F0ZVNvdXJjZS5qb2luKCcvJyk7CiAgICAgICAgfSwKICAgICAgICBnZXRRdW90ZWRTdHJpbmdzKHZhbHVlcykgewogICAgICAgICAgICByZXR1cm4gJyInICsgWy4uLm5ldyBTZXQodmFsdWVzKV0uam9pbignIiwgIicpICsgJyInOwogICAgICAgIH0KICAgIH0KfQo="},{"version":3,"sources":["Claims.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Claims.vue","sourceRoot":"src/views/analyze","sourcesContent":["<!--\n  - Copyright 2019 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n-->\n\n<template>\n    <div class=\"page-content\">\n        <div class=\"kb-details\">\n            <div class=\"kb-description-wrapper\">\n                <div v-if=\"searchType !== SEARCHTYPES.multi\" class=\"kb-heading\">Claims</div>\n                <div v-if=\"claimsTopic\"><span class=\"kb-labels\">Topic: </span><span>{{claimsTopic}}</span></div>\n            </div>\n        </div>\n        <div v-if=\"loading===true\" class=\"loading-section\">\n            <v-progress-linear indeterminate></v-progress-linear>\n            <div class=\"loading-message-clear\">{{statusMessage}}</div>\n        </div>\n        <div v-else>\n            <div v-if=\"statusMessage === NODATAMESSAGE\"  class=\"loading-message-clear\">{{statusMessage}}</div>\n            <div v-else-if=\"incidents && Object.keys(incidents).length > 0\">\n                <div v-for=\"(incident, incidentIndex) in Object.keys(incidents)\" :key=\"incidentIndex\" class=\"incident-space\">\n                    <div class=\"element-list-header\">\n                        <div class=\"page-header-left incident-title\">{{incident}}</div>\n                        <div class=\"page-header-right\">\n                            <div class=\"button-icon\" @click=\"toggleIncidentSection(incidentIndex)\">\n                                <InfoTooltip :ref=\"getTooltipId(incidentIndex)\" :message=\"toggleIncidents[getTooltipId(incidentIndex)].message\" :icon=\"toggleIncidents[getTooltipId(incidentIndex)].icon\" :iconStyle=\"'teal-large'\"></InfoTooltip>\n                            </div>\n                        </div>\n                    </div>\n                    <div v-for=\"(type, typeIndex) in incidents[incident]\" :key=\"typeIndex\" :class=\"typeIndex > 0 && !toggleIncidents[getTooltipId(incidentIndex)].closed ? 'section-space' : ''\">\n                        <DataTable\n                                :data=\"sinData[incident][type]\"\n                                :sort=\"sort\"\n                                :loading=\"Object.keys(sinData[incident][type]).length === 0\"\n                                :paging=\"paging\"\n                                :tableConfiguration=\"buildTableConfiguration(type)\"\n                                :statusMessage=\"statusMessage\"\n                                :hideData=\"toggleIncidents[getTooltipId(incidentIndex)].closed\"\n                                :hideFooter=true\n                                @currentItems=\"updateItems($event)\"\n                        ></DataTable>\n                    </div>\n                </div>\n            </div>\n            <div v-else>\n                <div v-for=\"(type, index) in types\" :key=\"index\" :class=\"index > 0 ? 'section-space' : ''\">\n                    <DataTable\n                            :data=\"sinData[type]\"\n                            :sort=\"sort\"\n                            :loading=\"Object.keys(sinData[type]).length === 0\"\n                            :paging=\"paging\"\n                            :tableConfiguration=\"buildTableConfiguration(type)\"\n                            :statusMessage=\"statusMessage\"\n                            :hideFooter=true\n                            @currentItems=\"updateItems($event)\"\n                    ></DataTable>\n                </div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import DataTable from '@/components/DataTable';\n    import { mapMutations, mapState, mapActions} from 'vuex';\n    import API from '../../api';\n    import CategoryTypes from '@/assets/data/types.json';\n    import InfoTooltip from '@/components/InfoTooltip';\n    import {\n        TABLESELECTIONS,\n        TABLEFIELDMAPPING,\n        DATATYPES,\n        LOADINGMESSAGE,\n        NODATAMESSAGE,\n        SEARCHTYPES,\n        getSinArgumentHeadline,\n        SecondaryExpand,\n        formatSinsClaims,\n        sortCaseInsensitive,\n        getType,\n        getRole,\n        getEntityName,\n        getIncidentName,\n        getEntityIdentifiers,\n        getTemplate,\n        getTemplatePredicate,\n        getTypesFromQuery,\n        getTransformedType,\n        getLastSubType,\n        sponsorTypes,\n        TableSettings,\n        HeaderConfig\n    } from '../../utils';\n\n    const currentRequests = new Map();\n    export default {\n        name: 'Claims',\n        props: {\n            searchType: {\n                type: String,\n                default: SEARCHTYPES.single,\n                required: false\n            },\n            claimSearchSinId: {\n                type: String,\n                default: null,\n                required: false\n            },\n            claimSearchFilters: {\n                type: Array,\n                default: null,\n                required: false\n            },\n        },\n        components: {DataTable, InfoTooltip},\n        data: () => ({\n            sort: {[TABLESELECTIONS.sortBy]: TABLEFIELDMAPPING.statement, [TABLESELECTIONS.sortDesc]: false},\n            paging: {[TABLESELECTIONS.itemsPerPage]:'All'},\n            statusMessage: '',\n            claims: {},\n            memberTypes: [],\n            incidentTypes: {},\n            SIN: {},\n            loading: false,\n            toggleTables: {}\n        }),\n        created() {\n            this.TABLEFIELDMAPPING = TABLEFIELDMAPPING;\n            this.DATATYPES = DATATYPES;\n            this.loading  = true;\n            this.statusMessage = LOADINGMESSAGE;\n            this.NODATAMESSAGE = NODATAMESSAGE;\n            this.SEARCHTYPES = SEARCHTYPES;\n        },\n        mounted() {\n            this.updateHypothesisSelection({});\n        },\n        computed: {\n            ...mapState(['defaultHypothesisDataSource', 'hypothesisSelection','currentDataSource', 'sinSelection', 'term', 'dataSourceList']),\n            types() {\n                return this.memberTypes.length > 0 ? this.memberTypes : null;\n            },\n            incidents() {\n                return this.incidentTypes;\n            },\n            sinData() {\n                return Object.keys(this.claims).length > 0 ? this.claims : null;\n            },\n            sinId() {\n                return this.sinSelection[TABLEFIELDMAPPING.sinList] ? this.sinSelection[TABLEFIELDMAPPING.sinList][0] : this.claimsSearchSinId ? this.claimsSearchSinId : '';\n            },\n            claimsTopic() {\n                if(this.sinId && this.searchType === SEARCHTYPES.single || this.searchType === SEARCHTYPES.multi) {\n                     this.setClaims();\n                 }\n                return this.term && this.term.input ? this.term.input : '';\n            },\n            toggleIncidents() {\n                return Object.keys(this.toggleTables).length > 0 ? this.toggleTables : null;\n            }\n        },\n        methods: {\n            ...mapMutations(['updateHypothesisSelection']),\n            ...mapActions(['updateCurrentDataSource']),\n            buildTableConfiguration(type) {\n                return {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.id, true, type, '', false, false, false, false, false, 'statement', false, true),\n                    primaryHeaders: [\n                        new HeaderConfig('Statement', 'start', true, TABLEFIELDMAPPING.statement),\n                        new HeaderConfig('Event Type', 'start', true, TABLEFIELDMAPPING.clusterType),\n                        new HeaderConfig('Date', 'start', true, TABLEFIELDMAPPING.dates),\n                        new HeaderConfig('', 'center', false, 'data-table-expand')\n                    ],\n                    secondaryHeaders: {\n                        expanded: new SecondaryExpand('', TABLEFIELDMAPPING.documentList,\n                            [\n                                new HeaderConfig('Entity', 'start', false, TABLEFIELDMAPPING.headline),\n                                new HeaderConfig('Supporting Document', 'start', false, TABLEFIELDMAPPING.docId),\n                                new HeaderConfig('Document Title', 'start', false, TABLEFIELDMAPPING.docTitle)\n                            ]\n                        )\n                    }\n                };\n            },\n            toggleIncidentSection(index) {\n                const toggleId = this.getTooltipId(index);\n                if(this.$refs[toggleId].length > 0) {\n                    const el = this.$refs[toggleId][0];\n                    if(this.toggleTables.hasOwnProperty(toggleId)) {\n                        if(el.icon === 'mdi-chevron-down') {\n                            this.toggleTables[toggleId].message = 'Open Section';\n                            this.toggleTables[toggleId].icon = 'mdi-chevron-up';\n                        }\n                        else {\n                            this.toggleTables[toggleId].message = 'Close Section';\n                            this.toggleTables[toggleId].icon = 'mdi-chevron-down';\n                        }\n                        this.toggleTables[toggleId].closed = !this.toggleTables[toggleId].closed;\n                    }\n                }\n            },\n            updateItems(currentItems) {\n                const toPopulate = currentItems.filter(item => item[TABLEFIELDMAPPING.documentList].length === 0 &&\n                    !currentRequests.has(item[TABLEFIELDMAPPING.prototypeUri]));\n\n                for (const item of toPopulate) {\n                    const prototype = item[TABLEFIELDMAPPING.prototypeUri];\n                    const roles = [...new Set(item[TABLEFIELDMAPPING.entityList].flatMap(entity => entity[TABLEFIELDMAPPING.roleUri]))];\n                    const hypothesisUri = item[TABLEFIELDMAPPING.hypothesisList][0];\n                    const graph = !this.claimSearchSinId ? this.currentDataSource : '';\n                    const promise = API.getSinDocuments(prototype, graph, hypothesisUri, roles);\n\n\n                    currentRequests.set(prototype, promise);\n                    promise.then(docs => {\n                        const formattedDocs = new Map();\n                        if(Object.keys(docs.data).length > 0) {\n                            for (const object of docs.data) {\n                                const docList = object[TABLEFIELDMAPPING.documentList];\n                                let argumentString = '';\n                                if(object.queryObject.toLowerCase().includes(DATATYPES.entityType.id)) {\n                                    const argument = item[TABLEFIELDMAPPING.entityList].find(entity => entity[TABLEFIELDMAPPING.prototypeUri] === object.queryObject);\n                                    const argumentIdentifier = argument && this.getEntityIdentifiers([argument]);\n                                    argumentString = argumentIdentifier && Object.values(argumentIdentifier)[0][0];\n                                }\n                                else {\n                                    argumentString = getTemplatePredicate(item[TABLEFIELDMAPPING.clusterType]);\n                                }\n\n                                for(const doc of docList) {\n                                    if(!formattedDocs.has(doc) && argumentString) {\n                                        formattedDocs.set(doc, {[TABLEFIELDMAPPING.docId]: doc.id, [TABLEFIELDMAPPING.docTitle]: doc.title, [TABLEFIELDMAPPING.headline]: [argumentString]});\n                                    }\n                                    else if(argumentString) {\n                                        formattedDocs.get(doc)[TABLEFIELDMAPPING.headline].push(argumentString);\n                                    }\n                                }\n                            }\n                        }\n\n                        //loop through to turn the items in the supported document headline array into a single string\n                        for(const fd of formattedDocs.values()) {\n                            fd[TABLEFIELDMAPPING.headline] = this.getQuotedStrings(fd[TABLEFIELDMAPPING.headline]);\n                        }\n\n                        //adds documents to the current position in the claims data\n                        item[TABLEFIELDMAPPING.documentList] = [...formattedDocs.values()];\n                        currentRequests.delete(prototype);\n                    });\n                }\n            },\n            setClaims() {\n                this.$emit('completedSearch', false);\n                if(this.sinId && this.sinId !== 'undefined' || this.searchType === SEARCHTYPES.multi) {\n                    const types = getTypesFromQuery(this.term && this.term.input || '');\n                    let filters = [];\n                    if (types) {\n                        types.push(...sponsorTypes);\n                        for (const type of types) {\n                            filters.push({['eventType'] : type});\n                        }\n                    }\n\n                    const sinDataSource = this.replaceDataSourceSinId();\n                    if(this.dataSourceList.includes(sinDataSource)) {\n                        this.updateCurrentDataSource(sinDataSource);\n                    }\n\n                    const dataSource = this.currentDataSource ? this.currentDataSource : this.defaultHypothesisDataSource;\n                    let queryFilters = {['graph'] : dataSource};\n                    if(filters.length > 0) {\n                        queryFilters['filters'] = filters;\n                    }\n                    this.loading = true;\n                    this.statusMessage = LOADINGMESSAGE;\n                    if(!this.claimSearchSinId && this.searchType === SEARCHTYPES.single) {\n                        API.getSinQueryResults(this.sinId, queryFilters).then(response => {\n                            const sinData = response.data;\n                            if (Object.keys(sinData).length > 0 && sinData.hypotheses) {\n                                this.SIN = sinData;\n                                this.getFormattedData(sinData);\n                            }\n                            else {\n                                this.statusMessage = this.NODATAMESSAGE;\n                                this.loading = false;\n                                this.$emit('completedSearch', true);\n                            }\n                        }).catch((error) => {\n                            console.warn(error)\n                        });\n                    }\n                    else if(!this.claimSearchSinId && this.searchType === SEARCHTYPES.multi) {\n                        //updates the claims data and member types\n                        let formattedData = {};\n                        let toggleData = {};\n                        this.claims = {};\n                        this.incidentTypes = {};\n\n                        const claimFilters = this.claimSearchFilters.length > 0 ? {['filters']:this.claimSearchFilters} : {};\n                        API.getAllSinQueryResults(claimFilters).then(response => {\n                            const sinEvents = response.data;\n                            if (Object.keys(sinEvents).length > 0) {\n                                //Map events based on sin and then event type\n                                for (const event of sinEvents) {\n                                    const sinTitle = getIncidentName(event[TABLEFIELDMAPPING.sinId]);\n                                    const eventType = event[TABLEFIELDMAPPING.clusterType];\n                                    if (!Object.keys(formattedData).includes(sinTitle)) {\n                                        formattedData[sinTitle] = {};\n                                    }\n\n                                    if (!Object.keys(formattedData[sinTitle]).length) {\n                                        formattedData[sinTitle] = {[eventType] : {}};\n                                    }\n                                    else if(!Object.keys(formattedData[sinTitle]).includes(eventType)) {\n                                        formattedData[sinTitle][eventType] = {};\n                                    }\n\n                                    //Before adding the event, format roles\n                                    for (const entity of event[TABLEFIELDMAPPING.entityList]) {\n                                        entity[TABLEFIELDMAPPING.roles] = sortCaseInsensitive([...new Set(entity[TABLEFIELDMAPPING.roleUri].flatMap(getRole))])\n                                    }\n                                    event[TABLEFIELDMAPPING.hypothesisList] = [event.hypothesis];\n                                    event[TABLEFIELDMAPPING.category] = event[TABLEFIELDMAPPING.clusterCategory];\n\n                                    let date = null;\n                                    if(event.date) {\n                                        date = event.date.toString();\n                                        event[TABLEFIELDMAPPING.dates] = event.date;\n                                    }\n\n                                    const key = event[TABLEFIELDMAPPING.statement] + event[TABLEFIELDMAPPING.clusterType] +  date;\n                                    event[TABLEFIELDMAPPING.id] = key;\n\n                                    //deduplicate\n                                    if(!formattedData[sinTitle][eventType].hasOwnProperty(key)) {\n                                        formattedData[sinTitle][eventType][key] = event;\n                                    }\n                                }\n\n                                //remove keys from event object\n                                for(let sin in formattedData) {\n                                    if(formattedData.hasOwnProperty(sin)) {\n                                        for(let eventType in formattedData[sin]) {\n                                            if(formattedData[sin].hasOwnProperty(eventType)) {\n                                                formattedData[sin][eventType] = Object.values(formattedData[sin][eventType]);\n                                            }\n                                        }\n                                    }\n                                }\n\n                                this.claims = formattedData;\n\n                                for(const [incident, types] of Object.entries(this.claims)) {\n                                    this.incidentTypes[incident] = Object.keys(types).sort();\n                                }\n                                for(let i=0; i <Object.keys(this.incidentTypes).length; i++) {\n                                    toggleData[this.getTooltipId(i)] = {message : 'Close Section', icon : 'mdi-chevron-down', closed : false};\n                                }\n                                this.toggleTables = toggleData;\n\n                                this.loading = false;\n                                this.$emit('completedSearch', true);\n                            }\n                            else {\n                                this.statusMessage = this.NODATAMESSAGE;\n                                this.loading = false;\n                                this.$emit('completedSearch', true);\n                            }\n\n                        }).catch((error) => {\n                            console.warn(error)\n                        });\n                    }\n                    else {\n                        const claimFilters = this.claimSearchFilters.length > 0 ? {['filters']:this.claimSearchFilters} : {};\n                        API.getSinQueryResults(this.claimSearchSinId, claimFilters).then(response => {\n                            const sinData = response.data;\n                            if (Object.keys(sinData).length > 0 && sinData.hypotheses) {\n                                this.SIN = sinData;\n                                this.getFormattedData(sinData);\n                            } else {\n                                this.statusMessage = this.NODATAMESSAGE;\n                                this.loading = false;\n                                this.$emit('completedSearch', true);\n                            }\n                        }).catch((error) => {\n                            console.warn(error)\n                        });\n                    }\n                }\n                else {\n                    this.statusMessage = this.NODATAMESSAGE;\n                    this.loading = false;\n                    this.$emit('completedSearch', true);\n                }\n            },\n            addSponsored(sponsored, member) {\n                const events = member.roles.find(role => role.role.includes('_ActorOrEvent'));\n                let sponsorRoles = member.roles.find(role => role.role.includes('_Sponsor'));\n                if (events && sponsorRoles) {\n                    const sponsors = new Set();\n                    for (const sponsor of sponsorRoles.arguments)  {\n                        sponsor[TABLEFIELDMAPPING.headline] = getSinArgumentHeadline(sponsor);\n                        const name = getEntityName(sponsor);\n                        if (name) {\n                            sponsors.add(name);\n                        }\n                    }\n                    if (sponsors.size) {\n                        for (const event of events.arguments) {\n                            let sponsoredEvent = sponsored[event.id];\n                            if (!sponsoredEvent) {\n                                sponsoredEvent = sponsored[event.id] = [];\n                            }\n                            sponsoredEvent.push(...sponsors);\n                        }\n                    }\n                }\n            },\n            getTooltipId(id) {\n                return 'incidentTooltip' + id;\n            },\n            getFormattedData(sin) {\n                const members = new Map();\n                for (const hypObject of sin.hypotheses || []) {\n                    const sponsored = {};\n                    for (const member of hypObject.members) {\n                        const category = getType(member[TABLEFIELDMAPPING.category]).toLowerCase();\n                        const type = getType(member.type);\n                        if (category === DATATYPES.relationType.id && member.roles.length === 2 && type.includes('Sponsorship')) {\n                            this.addSponsored(sponsored, member);\n                        }\n\n                        //if there are no arguments then there is no need to show the member\n                        if (category === DATATYPES.eventType.id && member.roles.length > 0) {\n                            let formattedMember = {\n                                node: member.node,\n                                prototype: member.prototype,\n                                category: category,\n                                type: type,\n                                roles: [...new Map(member.roles.map(role => [role, role])).values()].sort(),\n                                hypotheses: [hypObject.hypothesis],\n                                dates: member.dates\n                            };\n\n                            formattedMember = formatSinsClaims(formattedMember, DATATYPES.eventType.id, type);\n                            const identifiers = getEntityIdentifiers(formattedMember[TABLEFIELDMAPPING.entityList]);\n                            const sponsor = sponsored[member.node];\n                            formattedMember[TABLEFIELDMAPPING.statement] = getTemplate(type, identifiers) + (sponsor ? ' (sponsor: ' + sponsor + ')' : '');\n\n                            const formattedType = getTransformedType(getLastSubType(type), CategoryTypes.eventTypeMapping);\n                            if (!members.has(formattedType)) {\n                                members.set(formattedType, []);\n                            }\n                            members.get(formattedType).push(formattedMember);\n                        }\n                    }\n                }\n\n                // create object of type->[members]\n                const membersReduce = {};\n                members.forEach((values, key) => {\n                    // iterate over values and add them to membersReduce[key]\n                    const deduped = new Map();\n                    const addMember = member => {\n                        const date = member.date ? member.date.toString() : null;\n                        const key = member.statement + member.type;\n                        if (!deduped.has(key)) {\n                            deduped.set(key, new Map());\n                        } else if (!date) {\n                            // drop duplicates without date\n                            return;\n                        }\n                        member.id = key + date;\n                        // only keep track of one member per date\n                        deduped.get(key).set(date, member);\n                    };\n                    const noDates = [];\n                    for (const member of values) {\n                        if (!member.date) {\n                            noDates.push(member);\n                        } else {\n                            addMember(member);\n                        }\n                    }\n                    noDates.forEach(addMember);\n                    membersReduce[key] = [];\n                    deduped.forEach(value => membersReduce[key].push(...value.values()));\n                });\n\n                this.loading = false;\n                this.$emit('completedSearch', true);\n\n                //updates the claims data and member types\n                this.claims = membersReduce;\n                this.memberTypes = Object.keys(membersReduce).sort();\n            },\n            replaceDataSourceSinId() {\n                let truncateSource = this.currentDataSource.split('/');\n                //e.g. [https:, , www.nextcentury.com, TA3, E201, GAIA-20210203, GAIA-20210119, GAIA-20210119]\n                truncateSource.splice(4, 1, this.sinId);\n                return truncateSource.join('/');\n            },\n            getQuotedStrings(values) {\n                return '\"' + [...new Set(values)].join('\", \"') + '\"';\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .loading-section {\n        margin: 48px 0;\n    }\n\n    .loading-message-clear {\n        @include flex-row-nowrap;\n        justify-content: center;\n        height: 60px;\n        padding: 16px;\n    }\n\n    .incident-space:not(:first-child) {\n        margin: 60px 0 32px;\n    }\n\n    .incident-title {\n        font-size: 18px;\n        @extend .bold-text;\n        width: 100%;\n        color: $theme-teal-text;\n        line-height: 32px;\n        font-style: italic;\n    }\n\n</style>\n"]}]}