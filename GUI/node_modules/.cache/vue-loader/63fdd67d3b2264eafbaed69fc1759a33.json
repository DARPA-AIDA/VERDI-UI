{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/ClaimSearch.vue?vue&type=style&index=0&id=08a0c38b&lang=scss&scoped=true&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/ClaimSearch.vue","mtime":1640207172536},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/css-loader/dist/cjs.js","mtime":1641411773021},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1641411774047},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/postcss-loader/src/index.js","mtime":1641411773350},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/sass-loader/dist/cjs.js","mtime":1641411772200},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLnF1ZXJ5LWRpdiB7CiAgICBAZXh0ZW5kIC5rYi1kZXNjcmlwdGlvbi13cmFwcGVyOwogICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwp9CgoucXVlcnktdG9waWMtd3JhcHBlciB7CiAgICBwYWRkaW5nLWJvdHRvbTogMzZweDsKfQoKLmNsYWltLXF1ZXJ5LXdyYXBwZXIgewogICAgQGluY2x1ZGUgZmxleC1yb3ctd3JhcDsKICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDsKfQoKLmNsYWltLXF1ZXJ5LWlucHV0LXdyYXBwZXIgewogICAgQGluY2x1ZGUgZmxleC1jb2x1bW4tbm93cmFwOwogICAgcGFkZGluZy1ib3R0b206IDhweDsKICAgIHBhZGRpbmctcmlnaHQ6IDRweDsKfQoKLmNsYWltLXF1ZXJ5LWFkZC13cmFwcGVyIHsKICAgIEBpbmNsdWRlIGZsZXgtY29sdW1uLXdyYXA7CiAgICBwYWRkaW5nLWJvdHRvbTogMjBweDsKICAgIGxpbmUtaGVpZ2h0OiAzMHB4OwogICAgd2lkdGg6IDEwMCU7Cn0KCi5pbml0aWFsLXF1ZXJ5LXdyYXBwZXJ7CiAgICBAaW5jbHVkZSBmbGV4LWNvbHVtbi1ub3dyYXA7CgogICAgZGl2ID4gbGFiZWx7CiAgICAgICAgcGFkZGluZzogMCA0cHg7CiAgICAgICAgQGV4dGVuZCAuYm9sZC10ZXh0OwogICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdzsKICAgICAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7CiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogICAgfQp9CgouZmlsdGVyLXJvd3sKICAgIGRpc3BsYXk6IGZsZXg7CiAgICBmbGV4LWZsb3c6IHJvdyB3cmFwOwp9CgouZmlsdGVyLXJvdy1sYWJlbCB7CiAgICBAZXh0ZW5kIC5mb3JtLWxhYmVsOwogICAgQGV4dGVuZCAuYm9sZC10ZXh0OwogICAgZm9udC1zaXplOiAxNHB4OwogICAgd2lkdGg6IDEwMCU7CiAgICBsYWJlbCB7CiAgICAgICAgcGFkZGluZzogMCA0cHg7CiAgICB9Cn0KCg=="},{"version":3,"sources":["ClaimSearch.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0sBA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ClaimSearch.vue","sourceRoot":"src/views/eval","sourcesContent":["<!--\n  - Copyright 2021 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n  - Created by s.nordt on 6/23/21\n-->\n\n<template>\n    <div class=\"page-content\">\n        <div class=\"kb-details\">\n            <div class=\"kb-description-wrapper\">\n                <div class=\"element-list-header\">\n                    <div class=\"primary-page-header-left\">Claim Search</div>\n                    <div class=\"page-header-right\">\n                        <button id=\"compare_button\" class=\"dark-app-button\" @click=\"linkToEvalDocSearch()\">\n                            <v-icon class=\"button-icon\">mdi-file-document-box-search-outline</v-icon>\n                            Document Search\n                        </button>\n                    </div>\n                </div>\n                <span class=\"element-list-header\">Begin query by selecting an incident. To limit the results returned, add an event type or named entity:</span>\n                <div class=\"query-div\">\n                    <div class=\"initial-query-wrapper\">\n                        <div class=\"query-topic-wrapper\">\n                            <label>Known Incidents</label>\n                            <SelectDropdown :options=\"sinIds\"\n                                            :selectDisplay=\"selectDisplay\"\n                                            :selectedOption=\"sinIds[0]\"\n                                            @selectDropdownChange=\"updateSelectedSinId($event)\">\n                            </SelectDropdown>\n                        </div>\n                        <div v-if=\"showSearchButtons\" class=\"pad-vertically\">\n                            <button class=\"dark-teal-submit-button\" @click.prevent=\"updateSearchForm(views.eventQuery.type)\">Add Event Type</button>\n                            <button class=\"dark-teal-submit-button\" @click.prevent=\"updateSearchForm(views.namedEntityQuery.type)\">Add Named Entity</button>\n                        </div>\n                    </div>\n                    <div v-if=\"!views.startQuery.disabled\">\n                        <div v-for=\"(queryId, queryIndex) in Object.keys(computedClaims)\" :key=\"queryId\">\n                            <span v-if=\"queryIndex > 0\" class=\"icon-text-label\">OR</span>\n                            <!--Event Type filter display-->\n                            <div v-if=\"computedClaims[queryId].filterType === CLAIMFILTERS.event\" class=\"claim-query-wrapper\">\n                                <div class=\"claim-query-input-wrapper\">\n                                    <div class=\"filter-row-label\">\n                                        <label>Event Type</label>\n                                    </div>\n                                    <div class=\"filter-row\">\n                                        <div class=\"query-field-wrapper\">\n                                            <div class=\"autocomplete-input\">\n                                                <AutoComplete class=\"filter-input\"\n                                                        :items=\"getPrettyLabels(eventTypes)\"\n                                                        :required=\"true\"\n                                                        :placeholder=\"'Search by Event Type'\"\n                                                        @autoCompleteSubmission=\"updateEventType(queryId, $event)\"\n                                                ></AutoComplete>\n                                            </div>\n                                        </div>\n                                        <button class=\"dark-icon-button\" @click.prevent=\"deleteQuery(queryId)\">\n                                            <v-icon>mdi-trash-can-outline</v-icon>\n                                        </button>\n                                    </div>\n                                </div>\n                                <div class=\"claim-query-add-wrapper\">\n                                    <div v-if=\"computedClaims[queryId]\" class=\"filter-row\">\n                                        <span v-if=\"computedClaims[queryId].conditionCount > 0\" class=\"icon-text-large\"> & </span>\n                                        <CategoryRoleFilter v-for=\"index in computedClaims[queryId].conditionCount\" :key=\"CLAIMFILTERS.entityRole + index\"\n                                              :categoryDetails=\"getCategoryDetails('AS', 'Entity', 'entity names')\"\n                                              :categoryValues=\"getFilterValues(computedClaims[queryId].names, queryId, CLAIMFILTERS.entityRole + index)\"\n                                              :roleValues=\"getFilterValues(computedClaims[queryId].roles, queryId, CLAIMFILTERS.entityRole + index)\"\n                                              :condition=\"index===1 ? '' : '&'\"\n                                              :conditionClass=\"'icon-text-large'\"\n                                              @categoryValueChange=\"updateCategoryRoleValue(queryId, CLAIMFILTERS.entityRole + index, CLAIMFILTERS.argumentIds, $event)\"\n                                              @roleValueChange=\"updateCategoryRoleValue(queryId, CLAIMFILTERS.entityRole + index, CLAIMFILTERS.role, $event)\"\n                                        ></CategoryRoleFilter>\n                                        <button v-if=\"computedClaims[queryId].conditionCount > 0\" class=\"dark-icon-button\" @click.prevent=\"deleteQuery(queryId, CLAIMFILTERS.entityRole + computedClaims[queryId].conditionCount)\">\n                                            <v-icon>mdi-trash-can-outline</v-icon>\n                                        </button>\n                                    </div>\n                                    <div>\n                                        <button class=\"dark-teal-submit-button\"  v-if=\"!views.startQuery.disabled\"\n                                                @click.prevent=\"updateSearchForm(views.categoryAddArgument.type, queryId)\"\n                                        >\n                                            <v-icon>mdi-plus-circle</v-icon> Add Entity and/or Role\n                                        </button>\n                                    </div>\n                                </div>\n                            </div>\n                            <!--Named Entity filter display-->\n                            <div v-else class=\"claim-query-wrapper\">\n                                <div class=\"claim-query-input-wrapper\">\n                                    <div class=\"filter-row-label\">\n                                        <label>Named Entity</label>\n                                    </div>\n                                    <div class=\"filter-row\">\n                                        <div class=\"query-field-wrapper\">\n                                            <div class=\"autocomplete-input\">\n                                                <AutoComplete class=\"filter-input\"\n                                                              :items=\"getPrettyLabels(namedEntities)\"\n                                                              :required=\"true\"\n                                                              :placeholder=\"'Search by Named Entity'\"\n                                                              @autoCompleteSubmission=\"updateNamedEntity(queryId, $event)\"\n                                                ></AutoComplete>\n                                            </div>\n                                        </div>\n                                        <button class=\"dark-icon-button\" @click.prevent=\"deleteQuery(queryId)\">\n                                            <v-icon>mdi-trash-can-outline</v-icon>\n                                        </button>\n                                    </div>\n                                </div>\n                                <div class=\"claim-query-add-wrapper\">\n                                    <div v-if=\"computedClaims[queryId]\" class=\"filter-row\">\n                                        <span class=\"icon-text-large\" v-if=\"computedClaims[queryId].conditionCount > 0\"> & </span>\n                                        <CategoryRoleFilter v-for=\"index in computedClaims[queryId].conditionCount\" :key=\"CLAIMFILTERS.eventRole + index\"\n                                                          :categoryDetails=\"getCategoryDetails('HAVING  ', 'Event', 'event types')\"\n                                                          :categoryValues=\"getFilterValues(computedClaims[queryId].events, queryId, CLAIMFILTERS.eventRole + index)\"\n                                                          :roleValues=\"getFilterValues(computedClaims[queryId].roles, queryId, CLAIMFILTERS.eventRole + index)\"\n                                                          :condition=\"index===1 ? '' : '&'\"\n                                                          :conditionClass=\"'icon-text-large'\"\n                                                          @categoryValueChange=\"updateCategoryRoleValue(queryId, CLAIMFILTERS.eventRole + index, CLAIMFILTERS.eventType, $event)\"\n                                                          @roleValueChange=\"updateCategoryRoleValue(queryId, CLAIMFILTERS.eventRole + index, CLAIMFILTERS.role, $event)\"\n                                        ></CategoryRoleFilter>\n                                        <button v-if=\"computedClaims[queryId].conditionCount > 0\" class=\"dark-icon-button\" @click.prevent=\"deleteQuery(queryId, CLAIMFILTERS.eventRole + computedClaims[queryId].conditionCount)\">\n                                            <v-icon>mdi-trash-can-outline</v-icon>\n                                        </button>\n                                    </div>\n                                    <div>\n                                        <button class=\"dark-teal-submit-button\"  v-if=\"!views.startQuery.disabled\"\n                                                @click.prevent=\"updateSearchForm(views.categoryAddArgument.type, queryId)\"\n                                        >\n                                            <v-icon>mdi-plus-circle</v-icon> Add Event and/or Role\n                                        </button>\n                                    </div>\n                                </div>\n                            </div>\n                            <hr class=\"hr-light\">\n                        </div>\n                    </div>\n                    <div v-if=\"showAddToSearchButtons\" class=\"kb-description-wrapper\">\n                        <span class=\"pad-vertically\">Add another query condition:</span>\n                        <div  class=\"pad-vertically\">\n                            <button type=\"submit\" class=\"dark-teal-submit-button\" @click.prevent=\"updateSearchForm(views.eventQuery.type)\">Add Event Type</button>\n                            <button type=\"submit\" class=\"dark-teal-submit-button\" @click.prevent=\"updateSearchForm(views.namedEntityQuery.type)\">Add Named Entity</button>\n                        </div>\n                    </div>\n                    <div class=\"footer-button-wrapper\">\n                        <div>\n                            <button type=\"submit\" class=\"dark-gray-submit-button\" @click.prevent=\"updateSearchForm(views.resetQuery.type)\">\n                                Reset\n                            </button>\n                            <button type=\"submit\" ref=\"searchButton\" class=\"dark-teal-submit-button\" @click.prevent=\"updateSearchForm(views.claimResults.type)\">\n                                Search\n                            </button>\n                        </div>\n                        <hr class=\"hr-fade\">\n                    </div>\n                </div>\n            </div>\n        </div>\n        <Claims v-if=\"!views.claimResults.disabled\" :ref=\"resultsAnchor\" :claimSearchSinId=\"selectedSinId\" :claimSearchFilters=\"formattedClaims\" @completedSearch=completedSearch($event) ></Claims>\n    </div>\n</template>\n\n<script>\n    import AutoComplete from '@/components/AutoComplete';\n    import CategoryRoleFilter from '@/components/forms/CategoryRoleFilter';\n    import SelectDropdown from '@/components/SelectDropdown';\n    import Claims from '@/views/analyze/Claims';\n    import CategoryTypes from '@/assets/data/types.json';\n    import {mapMutations} from 'vuex';\n    import {SELECTDISPLAY,\n        TABLEFIELDMAPPING,\n        INCIDENTMAPPING,\n        getTransformedType,\n        getLastSubType,\n        getRole,\n        getIncidentId,\n        sortCaseInsensitive\n    } from '../../utils';\n    import API from '../../api';\n\n    const CLAIMFILTERS = {\n        parentFilter: 'filter',\n        event: 'eventFilter',\n        entity: 'entityFilter',\n        entityRole: 'entityRoleFilter',\n        eventRole: 'eventRoleFilter',\n        //specific to Rest API data formatting\n        argumentIds: 'ids',\n        role: 'role',\n        eventType: 'eventType'\n    };\n\n    class CategoryDetails {\n        constructor (preposition, label, message) {\n            this.preposition = preposition;\n            this.label = label;\n            this.message = message;\n        }\n    }\n\n    class View {\n        constructor (type, disabled) {\n            this.type = type;\n            this.disabled = disabled;\n        }\n    }\n\n    class EventFilter {\n        constructor(id) {\n            this.filterId = id;\n            this.filterType = CLAIMFILTERS.event;\n            this.eventType = [];\n            this.arguments = {};\n            this.conditionCount = 0;\n            this.names = {};\n            this.roles = {};\n        }\n    }\n\n    class EntityFilter {\n        constructor(id) {\n            this.filterId = id;\n            this.filterType = CLAIMFILTERS.entity;\n            this.namedEntity = [];\n            this.arguments = {};\n            this.conditionCount = 0;\n            this.events = {};\n            this.roles = {};\n        }\n    }\n\n    function initialState() {\n        return {\n            selectDisplay: SELECTDISPLAY.input,\n            selectedSinId:'E201',\n            showSearchButtons: true,\n            showAddToSearchButtons: false,\n            claimFilters: {},\n            formattedFilters: {},\n            queryKey: 1,\n            queryEventTypes : [],\n            queryNamedEntities: [],\n            resultsAnchor: 'claim_results',\n            views: {\n                resetQuery: new View('resetQuery', false),\n                startQuery: new View('startQuery', true),\n                eventQuery: new View('eventQuery', true),\n                namedEntityQuery: new View('namedEntityQuery', true),\n                categoryAddArgument :new View('categoryAddArgument', true),\n                claimResults: new View('claimResults', true)\n            }\n        }\n    }\n    export default {\n        name: 'ClaimSearch',\n        components: {AutoComplete, Claims, CategoryRoleFilter, SelectDropdown},\n        data: () => (initialState()),\n        created() {\n            this.CLAIMFILTERS = CLAIMFILTERS;\n            this.INCIDENTMAPPING = INCIDENTMAPPING;\n        },\n        mounted() {\n            window.scroll({\n                top: 0,\n                behavior: 'smooth'\n            });\n            //fetch the query event types and named entities for the selected SIN\n            this.getEventTypes();\n            this.getEntityNames();\n        },\n        computed: {\n           eventTypes() {\n               return this.transformEventTypes(this.queryEventTypes);\n           },\n            namedEntities() {\n               return this.queryNamedEntities;\n            },\n            computedClaims() {\n                return this.claimFilters;\n            },\n            formattedClaims() {\n               return this.formattedFilters;\n            },\n            sinIds() {\n                return INCIDENTMAPPING.map(v => v.value);\n            }\n        },\n        methods: {\n            ...mapMutations(['updateSinSelection']),\n            linkToEvalDocSearch () {\n                window.open('https://blackbox.verdi.nextcentury.com/', '_blank');\n            },\n            completedSearch(value) {\n                this.$refs.searchButton.disabled = !value\n            },\n            getPrettyLabels(items) {\n                //remove duplicates and sort\n               return  Object.keys(items) ? sortCaseInsensitive([...Object.keys(items)]) : items;\n            },\n            transformEventTypes(eventTypes) {\n                let types = {};\n                for (const type of eventTypes) {\n                    const transformedType = getTransformedType(getLastSubType(type), CategoryTypes.eventTypeMapping);\n                    if(types.hasOwnProperty(transformedType)) {\n                        types[transformedType].push(type);\n                    }\n                    else {\n                        types[transformedType] = [type];\n                    }\n                }\n                return types;\n            },\n            getCategoryDetails(preposition, label, message) {\n                return new CategoryDetails(preposition, label, message);\n            },\n            scrollToResults() {\n                this.$nextTick(() => {\n                    const el = this.$refs[this.resultsAnchor].$el;\n\n                    if(el) {\n                        el.scrollIntoView({ top: 'position', behavior: 'smooth' })\n                    }\n                });\n            },\n            updateSelectedSinId(input) {\n                this.selectedSinId = getIncidentId(input.target.value);\n                this.getEventTypes();\n            },\n            getDefaultEventFilter(key) {\n                return new EventFilter(key);\n            },\n            getDefaultEntityFilter(key) {\n                return new EntityFilter(key);\n            },\n            getFilterValues(claimValues, filterKey, subFilterKey) {\n                const filterValues = claimValues.hasOwnProperty(subFilterKey) ? claimValues[subFilterKey] : claimValues[filterKey];\n                let labels = [];\n                if(filterValues) {\n                    labels = subFilterKey.includes(this.CLAIMFILTERS.eventRole) ? Object.keys(filterValues) : this.getPrettyLabels(filterValues);\n                }\n                return labels;\n            },\n            updateEventType(key, input) {\n                //update the existing event type filter\n                let createFilter = {[key] : this.getDefaultEventFilter(key)};\n                this.claimFilters[key] = {...createFilter[key], ['eventType'] : this.eventTypes[input]};\n\n                if(input) {\n                    //update roles and names for the claimFilter\n                    this.getEntityNamesForEvent(key, null, this.eventTypes[input]);\n                    this.getRoleOptions(key, null, this.eventTypes[input]);\n                }\n            },\n            updateNamedEntity(key, input) {\n                //update the existing named entity filter\n                let createFilter = {[key] : this.getDefaultEntityFilter(key)};\n                this.claimFilters[key] = {...createFilter[key], ['namedEntity'] : this.namedEntities[input]};\n\n                if(input) {\n                    //update roles and event types for the claimFilter\n                    this.getEventTypesForNamedEntity(key, null, this.namedEntities[input]);\n                    this.getRoleOptions(key, null, null, this.namedEntities[input]);\n                }\n            },\n            updateCategoryRoleValue(filterKey, subFilterKey, valueType, value) {\n                let convertedValue = '';\n                if(value) {\n                    if(valueType === CLAIMFILTERS.role) {\n                        convertedValue = this.claimFilters[filterKey].roles.hasOwnProperty(subFilterKey) ? this.claimFilters[filterKey].roles[subFilterKey][value] : this.claimFilters[filterKey].roles[filterKey][value];\n                        if (this.claimFilters[filterKey].eventType) {\n                            this.getEntityNamesForEvent(filterKey, subFilterKey, this.claimFilters[filterKey].eventType, convertedValue);\n                        } else if (this.claimFilters[filterKey].namedEntity) {\n                            this.getEventTypesForNamedEntity(filterKey, subFilterKey, this.claimFilters[filterKey].namedEntity, convertedValue);\n                        }\n                    }\n                    else if(valueType === CLAIMFILTERS.eventType) {\n                        convertedValue = this.claimFilters[filterKey].events.hasOwnProperty(subFilterKey) ? this.claimFilters[filterKey].events[subFilterKey][value] : this.claimFilters[filterKey].events[filterKey][value];\n                        this.getRoleOptions(filterKey, subFilterKey, convertedValue, this.claimFilters[filterKey].namedEntity);\n                    }\n                    else if(valueType === CLAIMFILTERS.argumentIds) {\n                        convertedValue = this.claimFilters[filterKey].names.hasOwnProperty(subFilterKey) ? this.claimFilters[filterKey].names[subFilterKey][value] : this.claimFilters[filterKey].names[filterKey][value];\n                        this.getRoleOptions(filterKey, subFilterKey, this.claimFilters[filterKey].eventType, convertedValue);\n                    }\n                }\n                else {\n                    this.claimFilters = {...this.claimFilters};\n                    if(valueType === CLAIMFILTERS.role) {\n                        if (this.claimFilters[filterKey].eventType) {\n                            delete this.claimFilters[filterKey].names[subFilterKey];\n                        } else if (this.claimFilters[filterKey].namedEntity) {\n                            delete this.claimFilters[filterKey].events[subFilterKey];\n                        }\n                    }\n                    else if(valueType === CLAIMFILTERS.eventType || valueType === CLAIMFILTERS.argumentIds) {\n                        delete this.claimFilters[filterKey].roles[subFilterKey];\n                    }\n                }\n\n                //update current arguments or add a new argument\n                if(this.claimFilters[filterKey].arguments.hasOwnProperty(subFilterKey)) {\n                    const currentFilter = this.claimFilters[filterKey].arguments[subFilterKey];\n                    currentFilter[valueType] = convertedValue;\n                }\n                else {\n                    this.claimFilters[filterKey].arguments[subFilterKey] = {[valueType] : convertedValue};\n                }\n            },\n            deleteQuery(filterKey, subFilterKey) {\n                //if no subfilter key delete the parent filter\n                if(!subFilterKey) {\n                    this.claimFilters = {...this.claimFilters};\n                    delete this.claimFilters[filterKey];\n                }\n                else { //if subfilter key, delete all subfilter parts from filter\n                    this.claimFilters = {...this.claimFilters};\n                    delete this.claimFilters[filterKey].arguments[subFilterKey];\n                    delete this.claimFilters[filterKey].roles[subFilterKey];\n                    if(this.claimFilters[filterKey].filterType === CLAIMFILTERS.event) {\n                        delete this.claimFilters[filterKey].names[subFilterKey];\n                    }\n                    else if(this.claimFilters[filterKey].filterType === CLAIMFILTERS.entity) {\n                         delete this.claimFilters[filterKey].events[subFilterKey];\n                    }\n                    this.claimFilters[filterKey].conditionCount --;\n                }\n\n                if(Object.keys(this.claimFilters).length === 0) {\n                    this.showAddToSearchButtons = false;\n                    this.showSearchButtons = true;\n                }\n            },\n            updateSearchForm(viewType, key) {\n                if(viewType === this.views.resetQuery.type) {\n                    const saveSinId = this.selectedSinId;\n                    Object.assign(this.$data, initialState());\n                    this.selectedSinId = saveSinId;\n                    this.getEventTypes();\n                    this.getEntityNames();\n                }\n                else if(viewType === this.views.eventQuery.type || viewType === this.views.namedEntityQuery.type) {\n                    this.showSearchButtons = false;\n                    this.showAddToSearchButtons = true;\n\n                    //create a new filterID and a new filter\n                    const filterKey = this.CLAIMFILTERS.parentFilter + this.queryKey;\n                    if(!this.claimFilters.hasOwnProperty(filterKey)) {\n                        this.claimFilters = {...this.claimFilters, [filterKey] :\n                            viewType === this.views.eventQuery.type ?\n                                this.getDefaultEventFilter(filterKey) : this.getDefaultEntityFilter(filterKey)\n                        }\n                    }\n                    this.queryKey ++;\n\n                    for (const view in this.views) {\n                        this.views[view].disabled = view !== this.views.startQuery.type;\n                    }\n                }\n                else if(viewType === this.views.categoryAddArgument.type && key) {\n                    //Only add subfilters if event type or named entity has a value\n                    if((this.claimFilters[key].filterType === CLAIMFILTERS.event && this.claimFilters[key].eventType.length !== 0) ||\n                        (this.claimFilters[key].filterType === CLAIMFILTERS.entity && this.claimFilters[key].namedEntity.length !== 0))\n                    {\n                        this.claimFilters[key].conditionCount ++;\n                    }\n                }\n                else if(viewType === this.views.claimResults.type) {\n                    this.updateSinSelection({[TABLEFIELDMAPPING.sinList]: [this.selectedSinId]});\n                    this.views[viewType].disabled = false;\n                    this.formattedFilters = this.formatClaimFilters();\n                    this.scrollToResults();\n                }\n            },\n            findRolesAndEntitiesForEventType(argument, eventType) {\n                let argumentObject = {};\n                if(argument.role) {\n                    let argRole = argument.role.find(role => role.includes(eventType));\n                    if(argRole) {\n                        //add role and only add ids if the respective role is found\n                        argumentObject['role'] = argRole;\n                        if(argument.ids) {\n                            argumentObject['ids'] = argument.ids;\n                        }\n                    }\n                }   //if ids and no roles, add ids to the filter\n                else if(argument.ids) {\n                    argumentObject['ids'] = argument.ids;\n                }\n                return argumentObject;\n            },\n            formatClaimFilters() {\n                let formattedFilters = [];\n                Object.values(this.claimFilters).map(filter => {\n                    ///Handles formatting for the Event Types query for multiple event types\n                    if(filter.eventType && filter.eventType.length > 0) {\n                        for(const eType of filter.eventType) {\n                            let reformat = {};\n                            //if event type filter has arguments, loop through the arguments to collect the respective role and ids\n                            if(Object.values(filter.arguments).length > 0) {\n                                for(const argument of Object.values(filter.arguments)) {\n                                    const argumentObject = this.findRolesAndEntitiesForEventType(argument, eType);\n                                    if(Object.keys(argumentObject).length > 0) {\n                                        reformat['eventType'] = eType;\n                                        if (reformat.hasOwnProperty('arguments')) {\n                                            reformat['arguments'].push(argumentObject)\n                                        } else {\n                                            reformat['arguments'] = [argumentObject];\n                                        }\n                                    }\n                                }\n                            }\n                            //if there are no arguments, just add the event type to the filter\n                            else {\n                                reformat['eventType'] = eType;\n                            }\n\n                            if(Object.keys(reformat).length > 0) {\n                                formattedFilters.push(reformat);\n                            }\n                        }\n                    }//Handles formatting for the Named Entity query having arguments that possibly contain multiple event types and/or multiple roles\n                    else if(Object.values(filter.arguments).length > 0) {\n                        let addNamedEntities = false;\n                        for (const argument of Object.values(filter.arguments)) {\n                            if(argument.eventType && argument.eventType.length > 0) {\n                                //If there are multiple event types as an argument, find the respective roles and entities and add as separate argument objects\n                                for (const eType of argument.eventType) {\n                                    let reformat = {['eventType']: eType};\n                                    const roleArgument = this.findRolesAndEntitiesForEventType(argument, eType);\n\n                                    if(roleArgument.role && filter.namedEntity) {\n                                        roleArgument['ids'] = filter.namedEntity;\n                                        reformat['arguments'] = [roleArgument];\n                                    }\n                                    else if(filter.namedEntity) {\n                                        reformat['arguments'] = [{['ids']: filter.namedEntity}];\n                                    }\n\n                                    formattedFilters.push(reformat);\n                                }\n                            }\n                            else if (argument.role && argument.role.length > 0) {\n                                //If there are multiple roles as an argument, add as separate argument objects\n                                for (const argRole of argument.role) {\n                                    let reformat = {'arguments' : []};\n                                    let argumentObject = {};\n\n                                    if (argument.eventType || filter.eventType) {\n                                        reformat['eventType'] = filter.eventType ? filter.eventType[0] : argument.eventType[0];\n                                        //If there is an event, only add roles that correspond with the event\n                                        let role = argRole.includes(reformat['eventType']);\n                                        if(role) {\n                                            argumentObject['role'] = argRole;\n                                        }\n                                    }\n                                    else {\n                                        argumentObject['role'] = argRole;\n                                    }\n\n                                    if (Object.keys(argumentObject).length > 0) {\n                                        if (argument.ids || filter.namedEntity) {\n                                            argumentObject['ids'] = filter.namedEntity ? filter.namedEntity : argument.ids;\n                                            reformat['arguments'] = [argumentObject]\n                                        }\n                                        formattedFilters.push(reformat);\n                                    }\n                                }\n                            }//If there are arguments containing empty event types or empty roles, then the namedEntities are the only things that need to be added to the filter\n                            else{\n                                addNamedEntities = true;\n                            }\n                        }\n\n                        if(addNamedEntities) {\n                            let reformat = {['arguments'] : [{'ids' : filter.namedEntity}]};\n                            formattedFilters.push(reformat);\n                        }\n\n                    }//Handles if a named entity is selected with no arguments\n                    else {\n                        let reformat = {};\n                        //capture the single event type in the array\n                        if(filter.eventType) {\n                            reformat['eventType'] = filter.eventType[0];\n                        }\n                        if(filter.namedEntity) {\n                            reformat['arguments'] = [{'ids' : filter.namedEntity}];\n                        }\n                        if(Object.keys(reformat).length > 0) {\n                            formattedFilters.push(reformat);\n                        }\n                    }\n                });\n                return formattedFilters;\n            },\n            getEventTypesForNamedEntity(filterKey, subFilterKey, namedEntities, roles) {\n                const rolesExist = roles ? roles : null;\n                this.getEventTypes(filterKey, subFilterKey, namedEntities, rolesExist);\n\n            },\n            getEventTypes(filterKey, subFilterKey = '', namedEntities = [], roles = []) {\n                API.getSinEventTypes(this.selectedSinId, namedEntities, roles).then(response => {\n                    if(response.data.length > 0 ) {\n                        if(filterKey && this.claimFilters[filterKey].hasOwnProperty('namedEntity')) {\n                            const eventKey = subFilterKey ? subFilterKey : filterKey;\n                            //Use spread operator to insure nested changes are picked up by computedClaims property\n                            this.claimFilters[filterKey].events = {\n                                ...this.claimFilters[filterKey].events,\n                                [eventKey]: this.transformEventTypes(response.data)\n                            };\n                        }\n                        else if(!filterKey) {\n                            this.queryEventTypes = response.data;\n                        }\n                    }\n                }).catch((error) => {\n                    console.warn(error)\n                });\n            },\n            getEntityNamesForEvent(filterKey, subFilterKey, eventTypes, roles) {\n                const rolesExist = roles ? roles : null;\n                let filterTypes = [];\n                //if roles exist, only query for the event types that correspond with the existing roles.\n                if(rolesExist) {\n                    for(const r of roles) {\n                        for(const e of eventTypes) {\n                            if(r.includes(e)) {\n                                filterTypes.push(e);\n                            }\n                        }\n                    }\n                }\n                this.getEntityNames(filterKey, subFilterKey, filterTypes.length > 0 ? filterTypes : eventTypes, rolesExist);\n            },\n            getEntityNames(filterKey, subFilterKey = '', eventTypes = [], roles = []) {\n                return API.getSinEntityNames(this.selectedSinId, eventTypes, roles).then(response => {\n                    if(response.data.length > 0 ) {\n                        let names = {};\n                        for (const d of response.data) {\n                            //removes any empty strings from the autocomplete dropdown\n                            if(d.name) {\n                                names[d.name] = d.entities;\n                            }\n                        }\n\n                        if(filterKey && this.claimFilters[filterKey].hasOwnProperty('eventType')) {\n                            const nameKey = subFilterKey ? subFilterKey : filterKey;\n                            //Use spread operator to insure nested changes are picked up by computedClaims property\n                            this.claimFilters[filterKey].names = {\n                                ...this.claimFilters[filterKey].names,\n                                [nameKey]: names\n                            };\n                        }\n                        else if(!filterKey) {\n                            this.queryNamedEntities = names;\n                        }\n                    }\n                }).catch((error) => {\n                    console.warn(error);\n                });\n            },\n            getRoleOptions(filterKey, subFilterKey, eventTypes, ids) {\n                const idsCheck = Array.isArray(ids) ? ids : null;\n                const nameKey = subFilterKey ? subFilterKey : filterKey;\n                return API.getSinRoles(this.selectedSinId, eventTypes, idsCheck).then(response => {\n                    if(response.data.length > 0 ) {\n                        for (const d of response.data) {\n                            //role URIs will be grouped by the truncated role name\n                            const truncRole = getRole(d);\n                            if(this.claimFilters[filterKey].roles.hasOwnProperty(nameKey)) {\n                                if(this.claimFilters[filterKey].roles[nameKey].hasOwnProperty(truncRole)) {\n                                    //Use spread operator to insure nested changes are picked up by computedClaims property\n                                    this.claimFilters[filterKey].roles = {\n                                        ...this.claimFilters[filterKey].roles, [nameKey] :\n                                            {...this.claimFilters[filterKey].roles[nameKey], [truncRole] :\n                                                    [...this.claimFilters[filterKey].roles[nameKey][truncRole], d]\n                                            }\n                                    }\n                                }\n                                else {\n                                    this.claimFilters[filterKey].roles = {\n                                        ...this.claimFilters[filterKey].roles, [nameKey] :\n                                        {...this.claimFilters[filterKey].roles[nameKey], [truncRole] : [d]}\n                                    }\n                                }\n                            }\n                            else {\n                                let roleObject = {};\n                                roleObject[truncRole] = [d] ;\n                                this.claimFilters[filterKey].roles = {...this.claimFilters[filterKey].roles, [nameKey] : roleObject};\n                            }\n                        }\n                    }\n                    else {\n                        this.claimFilters[filterKey].roles = {...this.claimFilters[filterKey].roles, [nameKey] : []};\n                    }\n                }).catch((error) => {\n                    console.warn(error);\n                });\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .query-div {\n        @extend .kb-description-wrapper;\n        justify-content: space-between;\n    }\n\n    .query-topic-wrapper {\n        padding-bottom: 36px;\n    }\n\n    .claim-query-wrapper {\n        @include flex-row-wrap;\n        align-items: flex-end;\n    }\n\n    .claim-query-input-wrapper {\n        @include flex-column-nowrap;\n        padding-bottom: 8px;\n        padding-right: 4px;\n    }\n\n    .claim-query-add-wrapper {\n        @include flex-column-wrap;\n        padding-bottom: 20px;\n        line-height: 30px;\n        width: 100%;\n    }\n\n    .initial-query-wrapper{\n        @include flex-column-nowrap;\n\n        div > label{\n            padding: 0 4px;\n            @extend .bold-text;\n            display: flex;\n            flex-direction: row;\n            align-items: flex-end;\n            justify-content: space-between;\n        }\n    }\n\n    .filter-row{\n        display: flex;\n        flex-flow: row wrap;\n    }\n\n    .filter-row-label {\n        @extend .form-label;\n        @extend .bold-text;\n        font-size: 14px;\n        width: 100%;\n        label {\n            padding: 0 4px;\n        }\n    }\n\n</style>\n\n"]}]}