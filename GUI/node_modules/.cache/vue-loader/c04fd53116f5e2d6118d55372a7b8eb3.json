{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/HypothesisComparison.vue?vue&type=style&index=0&id=533d763c&lang=scss&scoped=true&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/HypothesisComparison.vue","mtime":1640207172535},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/css-loader/dist/cjs.js","mtime":1641411773021},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1641411774047},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/postcss-loader/src/index.js","mtime":1641411773350},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/sass-loader/dist/cjs.js","mtime":1641411772200},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoubG9hZGluZy1zZWN0aW9uIHsKICAgIG1hcmdpbjogNDhweCAwOwp9CgoubG9hZGluZy1tZXNzYWdlLWNsZWFyIHsKICAgIEBpbmNsdWRlIGZsZXgtcm93LW5vd3JhcDsKICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOwogICAgaGVpZ2h0OiA2MHB4OwogICAgcGFkZGluZzogMTZweDsKfQo="},{"version":3,"sources":["HypothesisComparison.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiTA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"HypothesisComparison.vue","sourceRoot":"src/views/analyze","sourcesContent":["<!--\n  - Copyright 2019 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n-->\n\n<template>\n    <div class=\"page-content\">\n        <div class=\"kb-details\">\n            <div class=\"row-width-description-wrapper\">\n                <div class=\"page-header-left\">\n                    <div class=\"kb-heading\">Hypothesis Comparison</div>\n                    <div><span class=\"kb-labels\">SIN ID: </span><span>{{sinId}}</span></div>\n                    <div><span class=\"kb-labels\">Description: </span><span>{{SIN.description}}</span></div>\n                </div>\n                <div class=\"page-header-align-bottom-right\">\n                    <span>Current Reference</span><v-icon>mdi-compare</v-icon>\n                </div>\n            </div>\n        </div>\n        <div v-if=\"loading===true\" class=\"loading-section\">\n            <v-progress-linear indeterminate></v-progress-linear>\n            <div class=\"loading-message-clear\">{{statusMessage}}</div>\n        </div>\n\n        <div v-else>\n            <div v-for=\"(type, index) in types\" :key=\"index\" :class=\"index > 0 ? 'section-space' : ''\">\n                <DataTable\n                    :data=\"sinData[type]\"\n                    :sort=\"sort\"\n                    :loading=\"Object.keys(sinData[type]).length === 0\"\n                    :paging=\"paging\"\n                    :tableConfiguration=\"buildTableConfiguration(type)\"\n                    :statusMessage=\"statusMessage\"\n                    @activateCompare=\"updateItemsForComparison($event)\"\n                    :hideFooter=true\n                    :hideHeader=true\n                ></DataTable>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import DataTable from '@/components/DataTable';\n    import { mapMutations, mapState} from 'vuex';\n    import API from '../../api';\n    import {\n        TABLESELECTIONS,\n        TABLEFIELDMAPPING,\n        DATATYPES,\n        LOADINGMESSAGE,\n        PREFIXTYPES,\n        sortArrayOfObjects,\n        removePrefix,\n        formatSinsComparison,\n        getSinIdFromDataSource,\n        TableSettings,\n        HeaderConfig\n    } from '../../utils';\n\n    export default {\n        name: 'HypothesisComparison',\n        components: {DataTable},\n        data: () => ({\n            sort: {[TABLESELECTIONS.sortBy]: TABLEFIELDMAPPING.id, [TABLESELECTIONS.sortDesc]: false},\n            paging: {[TABLESELECTIONS.itemsPerPage]:'All'},\n            statusMessage: '',\n            sinHypotheses: {},\n            sinTypes: [],\n            sinId : '',\n            SIN: {},\n            loading: false,\n        }),\n        created() {\n            this.TABLEFIELDMAPPING = TABLEFIELDMAPPING;\n            this.DATATYPES = DATATYPES;\n            this.loading  = true;\n            this.statusMessage = LOADINGMESSAGE;\n        },\n        mounted() {\n            this.updateHypothesisSelection({});\n            let dataSource = {['graph'] : this.currentDataSource ? this.currentDataSource : this.defaultHypothesisDataSource};\n            this.sinId = getSinIdFromDataSource(this.currentDataSource);\n            API.getSinQueryResults(this.sinId, dataSource).then(response => {\n                this.SIN = response.data;\n                this.getFormattedData(response.data);\n            });\n        },\n        computed: {\n            ...mapState(['defaultHypothesisDataSource', 'hypothesisSelection','currentDataSource']),\n            types() {\n                return this.sinTypes.length > 0 ? this.sinTypes : null;\n            },\n            sinData() {\n                return Object.keys(this.sinHypotheses).length > 0 ? this.sinHypotheses : null;\n            }\n        },\n        methods: {\n            ...mapMutations(['updateHypothesisSelection']),\n            buildTableConfiguration(type) {\n                const category = this.sinData[type][0][TABLEFIELDMAPPING.clusterCategory];\n                let roleHeaders = new Map();\n                let tableMappings = {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.idUri, false, type, category, false, false, false, false, true, 'headline', false),\n                    primaryHeaders: [\n                        new HeaderConfig('Hypothesis', 'start', true, TABLEFIELDMAPPING.headline, false, false)\n                    ]\n                };\n\n                for (const hypothesis of this.sinData[type]) {\n                    roleHeaders = new Map([...roleHeaders, ...new Map(hypothesis[TABLEFIELDMAPPING.roles].map(role =>\n                        [role, new HeaderConfig(role, 'start', true, role, true, true)]\n                    ))]);\n                }\n\n                //sort role headers\n                roleHeaders = new Map([...roleHeaders].sort());\n\n                //combine existing primary headers with role and match percentage headers\n                tableMappings.primaryHeaders = [\n                    ...[...tableMappings.primaryHeaders, ...new Set([...roleHeaders.values()])],\n                    ...[new HeaderConfig('Match %', 'end', true, TABLEFIELDMAPPING.percentage, false, false)]\n                ];\n\n                return tableMappings;\n            },\n            getFormattedData(sin) {\n                let hypotheses = [];\n                sortArrayOfObjects(sin.hypotheses, 'hypothesis');\n\n                for (const hypObject of sin.hypotheses) {\n                    //new map removes duplicate types, added Unknown type to compensate for incomplete member information\n                    const hypTypes = [...new Set(hypObject.types.map(type => removePrefix(type, PREFIXTYPES.hash))), 'Unknown'].sort();\n\n                    let hypothesisByMemberType = new Map();\n                    for (const ht of hypTypes) {\n                        //shallow clone\n                        let formattedHypothesis = Object.assign({}, hypObject);\n\n                        let members = [];\n                        let roles = [];\n                        //collecting and formatting members to perform a deep clone\n                        for (const member of hypObject.members) {\n                            //if there are no arguments then there is no need to show the member\n                            if (ht === removePrefix(member.type, PREFIXTYPES.hash) && member.roles.length > 0) {\n                                members.push({\n                                    node: member.node,\n                                    category: member.category,\n                                    type: member.type,\n                                    roles: [...member.roles],\n                                });\n\n                                for(const role of member.roles) {\n                                    roles.push(removePrefix(role.role, PREFIXTYPES.underscore));\n                                }\n                            }\n                        }\n\n                        //if this hypothesis has members of this type then continue formatting data\n                        if(members.length > 0) {\n                            formattedHypothesis.members = members;\n                            formattedHypothesis.roles = [...new Map(roles.map(role => [role, role])).values()].sort();\n                            formattedHypothesis.category = removePrefix(members[0].category, PREFIXTYPES.hash);\n                            formattedHypothesis = formatSinsComparison(formattedHypothesis, DATATYPES.sin.id, ht);\n\n                            let hypData = {type: ht, data: formattedHypothesis};\n                            hypothesisByMemberType.set(ht, hypData);\n                        }\n                    }\n\n                    //add newly formatted hypothesis to hypotheses array\n                    hypotheses = [...hypotheses, ...hypothesisByMemberType.values()];\n\n                }\n\n                //groups hypotheses data by member type\n                const hypothesesReduce = hypotheses.reduce((acc, obj) => {\n                    const key = obj.type;\n                    if (!acc[key]) {\n                        acc[key] = [];\n                    }\n                    // Add object data to list in the given key position\n                    acc[key].push(obj.data);\n                    return acc;\n                }, {});\n\n                this.loading  = false;\n\n                //updates the sin data and sin types\n                this.sinHypotheses = hypothesesReduce;\n                this.sinTypes = Object.keys(hypothesesReduce).sort();\n            },\n            updateFontsAndBackgrounds(hypothesis, type, id, compareOn) {\n                hypothesis[TABLEFIELDMAPPING.compare] = compareOn;\n                hypothesis[TABLEFIELDMAPPING.highlight] = compareOn;\n\n                if (!compareOn) {\n                    this.resetColorTextAndPercentage(type);\n                    return;\n                }\n\n                hypothesis[TABLEFIELDMAPPING.percentage] = 100;\n                \n                // collect the entities of reference hypothesis\n                const referenceEntities = new Set(this.getEntities(hypothesis));\n                const referenceStrings = new Set(this.getEntityStrings(hypothesis));\n\n                // iterate over other hypotheses and set colorText for false positives\n                const compareHypotheses = this.sinData[type].filter(h => h[TABLEFIELDMAPPING.idUri] !== id);\n                for(const comparison of compareHypotheses) {\n                    const compareEntities = new Set(this.getEntities(comparison));\n                    const compareStrings = new Set(this.getEntityStrings(comparison));\n                    const allEntities = new Set([...referenceEntities, ...compareEntities]);\n    \n                    let falsePositive = 0;\n                    let falseNegative = 0;\n                    let truePositive = 0;\n                    for (const testEntity of allEntities) {\n                        const testString = this.getString(testEntity);\n                        const inRef = referenceStrings.has(testString);\n                        const inComp = compareStrings.has(testString);\n                        // inRef XOR inComp\n                        if (inRef != inComp) {\n                            if (inRef) {\n                                falseNegative++;\n                            } else {\n                                falsePositive++;\n                                testEntity[TABLEFIELDMAPPING.colorText] = true;\n                            }\n                        } else { \n                            // must be true positive\n                            truePositive++;\n                        }\n                    }\n                    const f =  truePositive / (truePositive + .5 * (falsePositive + falseNegative));\n                    comparison[TABLEFIELDMAPPING.percentage] = Math.ceil(f * 100);\n                }\n            },\n            resetColorTextAndPercentage(type) {\n                for (const h of this.sinData[type]) {\n                    delete h[TABLEFIELDMAPPING.percentage];\n                    for (const entity of this.getEntities(h)) {\n                        entity[TABLEFIELDMAPPING.colorText] = false;\n                    }\n                }\n            },\n            getString(e) {\n                return e[TABLEFIELDMAPPING.roles][0] + ' - ' + e[TABLEFIELDMAPPING.headline] + ' - ' + e[TABLEFIELDMAPPING.types].join(',');\n            },\n            getEntityStrings(hypothesis) {\n                return this.getEntities(hypothesis).map(this.getString);\n            },\n            getEntities(hypothesis) {\n                return hypothesis[TABLEFIELDMAPPING.clusterList].flatMap(c => c[TABLEFIELDMAPPING.entityList]);\n            },\n            updateItemsForComparison(row) {\n                let selectedHypothesis = {};\n                let removeStyling = row.item[TABLEFIELDMAPPING.compare] === true &&\n                    row.item[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri];\n\n                for(const clusterType in this.sinData) {\n                    if(this.sinData.hasOwnProperty(clusterType)) {\n                        //Turn off comparison highlighting for previously selected hypothesis\n                        if(Object.keys(this.hypothesisSelection).length > 0) {\n                            let previousHypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri]);\n                            if(previousHypothesis) {\n                                this.updateFontsAndBackgrounds(previousHypothesis, clusterType, this.hypothesisSelection[TABLEFIELDMAPPING.idUri], false);\n                            }\n                        }\n\n                        if(!removeStyling) {\n                            //Turn on comparison highlighting for currently selected hypothesis and save to the store\n                            let hypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === row.item[TABLEFIELDMAPPING.idUri]);\n                            if (hypothesis) {\n                                this.updateFontsAndBackgrounds(hypothesis, clusterType, row.item[TABLEFIELDMAPPING.idUri], true);\n\n                                if (clusterType === row.type) {\n                                    selectedHypothesis = hypothesis;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                this.updateHypothesisSelection(removeStyling ? {} : selectedHypothesis);\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .loading-section {\n        margin: 48px 0;\n    }\n\n    .loading-message-clear {\n        @include flex-row-nowrap;\n        justify-content: center;\n        height: 60px;\n        padding: 16px;\n    }\n</style>\n\n"]}]}