{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/IncidentDetail.vue?vue&type=style&index=0&id=7073a6e8&lang=scss&scoped=true&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/eval/IncidentDetail.vue","mtime":1640207172536},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/css-loader/dist/cjs.js","mtime":1641411773021},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1641411774047},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/postcss-loader/src/index.js","mtime":1641411773350},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/sass-loader/dist/cjs.js","mtime":1641411772200},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLmxvYWRpbmctc2VjdGlvbiB7CiAgICBtYXJnaW46IDQ4cHggMDsKfQoKLmxvYWRpbmctbWVzc2FnZS1jbGVhciB7CiAgICBAaW5jbHVkZSBmbGV4LXJvdy1ub3dyYXA7CiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKICAgIGhlaWdodDogNjBweDsKICAgIHBhZGRpbmc6IDE2cHg7Cn0KCi5zY3JvbGwtdG9wLWljb257CiAgICBkaXNwbGF5OiBub25lOwogICAgYmFja2dyb3VuZC1jb2xvcjogJHRoZW1lLWljb24tY29sb3I7CiAgICBwb3NpdGlvbjogZml4ZWQ7CiAgICBib3R0b206IDIwcHg7CiAgICBsZWZ0OiAxJTsKICAgIHotaW5kZXg6IDk5OwogICAgZm9udC1zaXplOiAyMHB4OwogICAgYm9yZGVyOiBub25lOwogICAgb3V0bGluZTogbm9uZTsKICAgIGNvbG9yOiB3aGl0ZTsKICAgIGN1cnNvcjogcG9pbnRlcjsKICAgIHBhZGRpbmc6IDEwcHg7CiAgICBib3JkZXItcmFkaXVzOiA0cHg7Cn0KCg=="},{"version":3,"sources":["IncidentDetail.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoaA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"IncidentDetail.vue","sourceRoot":"src/views/eval","sourcesContent":["<!--\n  - Copyright 2019 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n-->\n\n<template>\n    <div>\n        <v-icon :ref=\"topAnchor\"\n                @click=\"scrollToEventSummary()\"\n                title=\"return to Event Summary\"\n                class=\"scroll-top-icon dark-icon-button\"\n        >\n            mdi-arrow-up-bold\n        </v-icon>\n        <div class=\"page-content\">\n            <div class=\"element-list-header\">\n                <div class=\"primary-page-header-left\">Incident Details</div>\n                <div class=\"page-header-right\">\n                    <button id=\"compare_button\" class=\"dark-app-button\" @click=\"linkToIncidentSearch()\">\n                        <v-icon class=\"button-icon\">mdi-compare</v-icon>\n                        Incident Search\n                    </button>\n                    <button id=\"doc_button\" class=\"dark-app-button\" @click=\"linkToEvalDocSearch()\">\n                        <v-icon class=\"button-icon\">mdi-file-document-box-search-outline</v-icon>\n                        Document Search\n                    </button>\n                </div>\n            </div>\n            <div class=\"page-header-element-space\">\n                <SelectDropdown\n                        :options=\"sinIds\"\n                        :selectDisplay=\"selectDisplay\"\n                        :selectedOption=\"sinId\"\n                        @selectDropdownChange=\"updateSelectedSinId($event)\">\n                </SelectDropdown>\n            </div>\n            <div v-if=\"loading===true\" class=\"loading-section\">\n                <v-progress-linear indeterminate></v-progress-linear>\n                <div class=\"loading-message-clear\">{{statusMessage}}</div>\n            </div>\n            <div v-else>\n                <div class=\"section-space\" v-if=\"summaryData\">\n                    <DataTable\n                        :data=\"summaryData\"\n                        :sort=\"sort\"\n                        :loading=\"summaryData === 0\"\n                        :paging=\"paging\"\n                        :tableConfiguration=\"buildSumamryTable()\"\n                        :statusMessage=\"statusMessage\"\n                        :hideFooter=true\n                        :hideHeader=true\n                        @anchorScroll=\"scrollToEventDetails($event)\"\n                    ></DataTable>\n                </div>\n                <div class=\"section-space loading-section\" v-else>\n                    <div class=\"loading-message-clear\">{{statusMessage}}</div>\n                </div>\n                <div v-for=\"(type, index) in types\" :key=\"index\" :class=\"index > 0 ? 'section-space' : ''\">\n                    <DataTable\n                        :ref=\"getRefId(type)\"\n                        :data=\"sinData[type]\"\n                        :sort=\"sort\"\n                        :loading=\"sinData[type] && Object.keys(sinData[type]).length === 0\"\n                        :paging=\"paging\"\n                        :tableConfiguration=\"buildTableConfiguration(type)\"\n                        :statusMessage=\"statusMessage\"\n                        @activateCompare=\"updateItemsForComparison($event)\"\n                        :hideFooter=true\n                        :hideHeader=true\n                    ></DataTable>\n                </div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import DataTable from '@/components/DataTable';\n    import SelectDropdown from '@/components/SelectDropdown';\n    import QuerySubmissionMixin from '@/mixins/QuerySubmissionMixin';\n    import { mapMutations, mapState} from 'vuex';\n    import {\n        TABLESELECTIONS,\n        TABLEFIELDMAPPING,\n        DATATYPES,\n        LOADINGMESSAGE,\n        NODATAMESSAGE,\n        INCIDENTMAPPING,\n        SELECTDISPLAY,\n        PARAMETERNAMES,\n        JOINSTRING,\n        getIncidentName,\n        getIncidentId,\n        TableSettings,\n        HeaderConfig\n    } from '../../utils';\n\n    export default {\n        name: 'IncidentDetail',\n        mixins: [QuerySubmissionMixin],\n        components: {DataTable, SelectDropdown},\n        data: () => ({\n            sort: {[TABLESELECTIONS.sortBy]: TABLEFIELDMAPPING.id, [TABLESELECTIONS.sortDesc]: false},\n            paging: {[TABLESELECTIONS.itemsPerPage]:'All'},\n            statusMessage: '',\n            sinClustersBySinId : {},\n            summaryItemsBySinId: [],\n            summaryTypes: [],\n            sinId: null,\n            selectDisplay: SELECTDISPLAY.input,\n            SIN: {},\n            resultsAnchor: 'event_anchor_',\n            topAnchor: 'summary_anchor',\n            scrollPosition: 0,\n            currentPosition: null\n        }),\n        created() {\n            this.TABLEFIELDMAPPING = TABLEFIELDMAPPING;\n            this.DATATYPES = DATATYPES;\n            this.statusMessage = LOADINGMESSAGE;\n            this.PARAMETERNAMES = PARAMETERNAMES;\n        },\n        mounted() {\n            this.updateHypothesisSelection({});\n            this.sinId = INCIDENTMAPPING[0].id;\n\n            if(Object.keys(this.knowledgeBase).length === 0 || !this.knowledgeBase[DATATYPES.sin.id]) {\n                this.loadSINData(DATATYPES.sin.id);\n            }\n\n            window.onscroll = () => this.activateScrollArrow();\n        },\n        computed: {\n            ...mapState(['defaultHypothesisDataSource', 'hypothesisSelection','currentDataSource', 'knowledgeBase']),\n            summaryData() {\n                return this.summaryItemsBySinId.length > 0  ? this.summaryItemsBySinId : this.getDetailData();\n            },\n            types() {\n                return this.summaryTypes;\n            },\n            sinData() {\n                return this.sinClustersBySinId;\n            },\n            sinIds() {\n                return INCIDENTMAPPING.map(v => v.value);\n            }\n        },\n        methods: {\n            ...mapMutations(['updateHypothesisSelection']),\n            buildSumamryTable() {\n                let tableMappings = {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.id, false, 'Claims Summary', '', false, false, false, false, false, 'headline', false),\n                    primaryHeaders: [\n                        new HeaderConfig('', 'center', false, 'data-table-anchor'),\n                        new HeaderConfig('Events', 'start', true, TABLEFIELDMAPPING.headline, true, false),\n                        new HeaderConfig('', 'start', true, TABLEFIELDMAPPING.nodeCount, true, false),\n                        new HeaderConfig('', 'start', true, TABLEFIELDMAPPING.entityCount, true, false),\n                        new HeaderConfig('', 'start', true, TABLEFIELDMAPPING.id, true, false)\n                    ]\n                };\n\n                return tableMappings;\n            },\n            buildTableConfiguration(type) {\n                const category = this.sinData[type][0][TABLEFIELDMAPPING.sinTitle];\n                let roleHeaders = new Map();\n                let tableMappings = {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.idUri, false, type.split(JOINSTRING)[0], category, false, false, false, false, true, 'headline', false),\n                    primaryHeaders: [\n                        new HeaderConfig('Claim', 'start', true, TABLEFIELDMAPPING.headline, false, false),\n                        new HeaderConfig('Event Statement', 'start', true, TABLEFIELDMAPPING.statement, false, true)\n                    ]\n                };\n\n                for (const hypothesis of this.sinData[type]) {\n                    roleHeaders = new Map([...roleHeaders, ...new Map(hypothesis[TABLEFIELDMAPPING.roles].map(role =>\n                        [role, new HeaderConfig(role, 'start', true, role, false, true)]\n                    ))]);\n                }\n                //sort role headers\n                roleHeaders = new Map([...roleHeaders].sort());\n\n                //Add date to roles in order to compare\n                roleHeaders.set(TABLEFIELDMAPPING.dates, new HeaderConfig('Date', 'start', true, TABLEFIELDMAPPING.dates, false, true));\n\n                //combine existing primary headers with role and match percentage headers\n                tableMappings.primaryHeaders = [\n                    ...[...tableMappings.primaryHeaders, ...new Set([...roleHeaders.values()])],\n                    ...[new HeaderConfig('Match %', 'end', true, TABLEFIELDMAPPING.percentage, true, false)]\n                ];\n\n                return tableMappings;\n            },\n            linkToEvalDocSearch () {\n                window.open('https://blackbox.verdi.nextcentury.com/', '_blank');\n            },\n            linkToIncidentSearch () {\n                this.$router.push('/eval');\n            },\n            activateScrollArrow() {\n                if(this.$refs[this.topAnchor]) {\n                    const el = this.$refs[this.topAnchor].$el;\n                    const showPosition = 100;\n                    if (el) {\n                        if (document.body.scrollTop > showPosition || document.documentElement.scrollTop > showPosition) {\n                            el.style.display = 'block';\n                        } else {\n                            el.style.display = 'none';\n                        }\n                    }\n                }\n            },\n            scrollToEventDetails(location) {\n                if(this.$refs[this.resultsAnchor + location].length > 0) {\n                    this.scrollPosition = window.scrollY;\n                    const el = this.$refs[this.resultsAnchor + location][0].$el;\n                    const yOffset = -100;\n                    if (el) {\n                        const y = el.getBoundingClientRect().top + window.pageYOffset + yOffset;\n                        window.scrollTo({top: y})\n                    }\n                }\n            },\n            scrollToEventSummary() {\n                if(this.currentPosition !== this.scrollPosition) {\n                    this.currentPosition = window.scrollY;\n                }\n\n                if(this.currentPosition === this.scrollPosition) {\n                    this.scrollPosition = 0;\n                    this.currentPosition = null;\n                }\n\n                window.scrollTo({ top: this.scrollPosition });\n            },\n            getRefId(type) {\n                const tableId = this.sinClustersBySinId[type][0][TABLEFIELDMAPPING.clusterList][0][TABLEFIELDMAPPING.clusterUri];\n                return this.resultsAnchor + tableId;\n            },\n            getDetailData() {\n                if(this.knowledgeBase[DATATYPES.sin.id]) {\n                    const sinClusters = this.knowledgeBase[DATATYPES.sin.id];\n                    if (sinClusters[DATATYPES.eventType.id]) {\n                        this.sinClustersBySinId = sinClusters[DATATYPES.eventType.id][this.sinId];\n                        this.summaryTypes = Object.keys(this.sinClustersBySinId).sort();\n                    }\n\n                    if (sinClusters[DATATYPES.summary.id]) {\n                        this.summaryItemsBySinId = sinClusters[DATATYPES.summary.id].filter(item => item.sin === this.sinId);\n                    }\n                }\n                return this.summaryItemsBySinId;\n            },\n            updateSelectedSinId(input) {\n                this.sinId = getIncidentId(input.target.value);\n                this.$nextTick(() => {\n                    this.filterDataBySinId();\n                });\n            },\n            filterDataBySinId() {\n                const sinData = this.knowledgeBase[DATATYPES.sin.id];\n                const sinClusters = sinData[DATATYPES.eventType.id];\n                if (Object.keys(sinClusters).includes(this.sinId)) {\n                    this.sinClustersBySinId = sinClusters[this.sinId];\n                    this.summaryItemsBySinId = sinData[DATATYPES.summary.id].filter(item => item.sin === this.sinId);\n                    this.summaryTypes = Object.keys(this.sinClustersBySinId).sort();\n                    this.statusMessage = LOADINGMESSAGE;\n                }\n                else {\n                    this.sinClustersBySinId = {};\n                    this.summaryItemsBySinId = [];\n                    this.summaryTypes = [];\n                    this.statusMessage = NODATAMESSAGE + ' for Incident: ' + getIncidentName(this.sinId);\n                }\n            },\n            updateFontsAndBackgrounds(hypothesis, type, id, compareOn) {\n                hypothesis[TABLEFIELDMAPPING.compare] = compareOn;\n                hypothesis[TABLEFIELDMAPPING.highlight] = compareOn;\n\n                if (!compareOn) {\n                    this.resetColorTextAndPercentage(type);\n                    return;\n                }\n\n                hypothesis[TABLEFIELDMAPPING.percentage] = 100;\n\n                // collect the entities of reference hypothesis\n                const referenceEntities = new Set(this.getEntities(hypothesis));\n                const referenceStrings = new Set(this.getEntityStrings(hypothesis));\n                const referenceDates = new Set(hypothesis[TABLEFIELDMAPPING.dates]);\n\n                // iterate over other hypotheses and set colorText for false positives\n                const compareHypotheses = this.sinData[type].filter(h => h[TABLEFIELDMAPPING.idUri] !== id);\n                for(const comparison of compareHypotheses) {\n                    const compareEntities = new Set(this.getEntities(comparison));\n                    const compareStrings = new Set(this.getEntityStrings(comparison));\n                    const compareDates = new Set(comparison[TABLEFIELDMAPPING.dates]);\n                    const allEntities = new Set([...referenceEntities, ...compareEntities]);\n                    const allDates = new Set([...referenceDates, ...compareDates]);\n\n                    let falsePositive = 0;\n                    let falseNegative = 0;\n                    let truePositive = 0;\n                    for (const testEntity of allEntities) {\n                        const testString = this.getString(testEntity);\n                        const inRef = referenceStrings.has(testString);\n                        const inComp = compareStrings.has(testString);\n\n                        if (inRef !== inComp) {\n                            if (inRef) {\n                                falseNegative++;\n                            } else {\n                                falsePositive++;\n                                testEntity[TABLEFIELDMAPPING.colorText] = true;\n                            }\n                        } else { \n                            // must be true positive\n                            truePositive++;\n                        }\n                    }\n\n                    let datesCompared = new Map();\n                    [...allDates].map(d => datesCompared.set(d, d));\n\n                    for(const testDate of allDates) {\n                        const inRef = referenceDates.has(testDate);\n                        const inComp = compareDates.has(testDate);\n\n                        if (inRef !== inComp) {\n                            if (inRef) {\n                                //value only exists in the selected hypothesis\n                                falseNegative++;\n                                datesCompared.delete(testDate);\n                            } else {\n                                //value only exists in the compared hypothesis\n                                falsePositive++;\n                                datesCompared.set(testDate, {[TABLEFIELDMAPPING.colorText] : true, text : testDate});\n                            }\n                        } else {\n                            //value exists in both the selected and compared hypothesis\n                            truePositive++;\n                        }\n                    }\n\n                    const dates = [...datesCompared.values()];\n                    if(dates.length > 0) {\n                        comparison[TABLEFIELDMAPPING.dates] = dates;\n                    }\n\n                    const f =  truePositive / (truePositive + .5 * (falsePositive + falseNegative));\n                    comparison[TABLEFIELDMAPPING.percentage] = Math.ceil(f * 100);\n                }\n            },\n            resetColorTextAndPercentage(type) {\n                for (const h of this.sinData[type]) {\n                    delete h[TABLEFIELDMAPPING.percentage];\n                    for (const entity of this.getEntities(h)) {\n                        entity[TABLEFIELDMAPPING.colorText] = false;\n                    }\n                    h[TABLEFIELDMAPPING.dates] = h[TABLEFIELDMAPPING.dates].map(d => d.hasOwnProperty(TABLEFIELDMAPPING.colorText) ? d.text : d);\n                }\n            },\n            getString(e) {\n                const types = e[TABLEFIELDMAPPING.resolvedType] ? e[TABLEFIELDMAPPING.resolvedType] : e[TABLEFIELDMAPPING.types].join(',');\n                return e[TABLEFIELDMAPPING.roles][0] + ' - ' + e[TABLEFIELDMAPPING.headline] + ' - ' + types;\n            },\n            getEntityStrings(hypothesis) {\n                return this.getEntities(hypothesis).map(this.getString);\n            },\n            getEntities(hypothesis) {\n                return hypothesis[TABLEFIELDMAPPING.clusterList].flatMap(c => c[TABLEFIELDMAPPING.entityList]);\n            },\n            updateItemsForComparison(row) {\n                let selectedHypothesis = {};\n                let removeStyling = row.item[TABLEFIELDMAPPING.compare] === true &&\n                    row.item[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri];\n                for(const clusterType in this.sinData) {\n                    if(this.sinData.hasOwnProperty(clusterType)) {\n                        //Turn off comparison highlighting for previously selected hypothesis\n                        if(Object.keys(this.hypothesisSelection).length > 0) {\n                            let previousHypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri]);\n                            if(previousHypothesis) {\n                                this.updateFontsAndBackgrounds(previousHypothesis, clusterType, this.hypothesisSelection[TABLEFIELDMAPPING.idUri], false);\n                            }\n                        }\n\n                        if(!removeStyling) {\n                            //Turn on comparison highlighting for currently selected hypothesis and save to the store\n                            let hypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === row.item[TABLEFIELDMAPPING.idUri]);\n                            if (hypothesis) {\n                                this.updateFontsAndBackgrounds(hypothesis, clusterType, row.item[TABLEFIELDMAPPING.idUri], true);\n\n                                if (clusterType === row.type) {\n                                    selectedHypothesis = hypothesis;\n                                }\n                            }\n                        }\n                    }\n                }\n                this.updateHypothesisSelection(removeStyling ? {} : selectedHypothesis);\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .loading-section {\n        margin: 48px 0;\n    }\n\n    .loading-message-clear {\n        @include flex-row-nowrap;\n        justify-content: center;\n        height: 60px;\n        padding: 16px;\n    }\n\n    .scroll-top-icon{\n        display: none;\n        background-color: $theme-icon-color;\n        position: fixed;\n        bottom: 20px;\n        left: 1%;\n        z-index: 99;\n        font-size: 20px;\n        border: none;\n        outline: none;\n        color: white;\n        cursor: pointer;\n        padding: 10px;\n        border-radius: 4px;\n    }\n\n</style>\n\n"]}]}