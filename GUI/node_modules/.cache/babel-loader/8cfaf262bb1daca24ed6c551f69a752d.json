{"remainingRequest":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/babel-loader/lib/index.js!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/HypothesisComparison.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/src/views/analyze/HypothesisComparison.vue","mtime":1640207172535},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/babel.config.js","mtime":1639107483667},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/babel-loader/lib/index.js","mtime":1641411773354},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/cache-loader/dist/cjs.js","mtime":1641411772188},{"path":"/Users/womitowoju/workspace/aida/VERDI-UI/GUI/node_modules/vue-loader/lib/index.js","mtime":1641411773606}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQiOwppbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gIi9Vc2Vycy93b21pdG93b2p1L3dvcmtzcGFjZS9haWRhL1ZFUkRJLVVJL0dVSS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzIjsKaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICIvVXNlcnMvd29taXRvd29qdS93b3Jrc3BhY2UvYWlkYS9WRVJESS1VSS9HVUkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiOwoKZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gInVuZGVmaW5lZCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bIkBAaXRlcmF0b3IiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSAibnVtYmVyIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH0KCmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gInN0cmluZyIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSAiT2JqZWN0IiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gIk1hcCIgfHwgbiA9PT0gIlNldCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gIkFyZ3VtZW50cyIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9CgpmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0KCmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9CgpmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfQoKLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KaW1wb3J0IERhdGFUYWJsZSBmcm9tICdAL2NvbXBvbmVudHMvRGF0YVRhYmxlJzsKaW1wb3J0IHsgbWFwTXV0YXRpb25zLCBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnOwppbXBvcnQgQVBJIGZyb20gIi4uLy4uL2FwaSI7CmltcG9ydCB7IFRBQkxFU0VMRUNUSU9OUywgVEFCTEVGSUVMRE1BUFBJTkcsIERBVEFUWVBFUywgTE9BRElOR01FU1NBR0UsIFBSRUZJWFRZUEVTLCBzb3J0QXJyYXlPZk9iamVjdHMsIHJlbW92ZVByZWZpeCwgZm9ybWF0U2luc0NvbXBhcmlzb24sIGdldFNpbklkRnJvbURhdGFTb3VyY2UsIFRhYmxlU2V0dGluZ3MsIEhlYWRlckNvbmZpZyB9IGZyb20gIi4uLy4uL3V0aWxzIjsKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdIeXBvdGhlc2lzQ29tcGFyaXNvbicsCiAgY29tcG9uZW50czogewogICAgRGF0YVRhYmxlOiBEYXRhVGFibGUKICB9LAogIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7CiAgICB2YXIgX3NvcnQ7CgogICAgcmV0dXJuIHsKICAgICAgc29ydDogKF9zb3J0ID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfc29ydCwgVEFCTEVTRUxFQ1RJT05TLnNvcnRCeSwgVEFCTEVGSUVMRE1BUFBJTkcuaWQpLCBfZGVmaW5lUHJvcGVydHkoX3NvcnQsIFRBQkxFU0VMRUNUSU9OUy5zb3J0RGVzYywgZmFsc2UpLCBfc29ydCksCiAgICAgIHBhZ2luZzogX2RlZmluZVByb3BlcnR5KHt9LCBUQUJMRVNFTEVDVElPTlMuaXRlbXNQZXJQYWdlLCAnQWxsJyksCiAgICAgIHN0YXR1c01lc3NhZ2U6ICcnLAogICAgICBzaW5IeXBvdGhlc2VzOiB7fSwKICAgICAgc2luVHlwZXM6IFtdLAogICAgICBzaW5JZDogJycsCiAgICAgIFNJTjoge30sCiAgICAgIGxvYWRpbmc6IGZhbHNlCiAgICB9OwogIH0sCiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHsKICAgIHRoaXMuVEFCTEVGSUVMRE1BUFBJTkcgPSBUQUJMRUZJRUxETUFQUElORzsKICAgIHRoaXMuREFUQVRZUEVTID0gREFUQVRZUEVTOwogICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTsKICAgIHRoaXMuc3RhdHVzTWVzc2FnZSA9IExPQURJTkdNRVNTQUdFOwogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgdGhpcy51cGRhdGVIeXBvdGhlc2lzU2VsZWN0aW9uKHt9KTsKCiAgICB2YXIgZGF0YVNvdXJjZSA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgJ2dyYXBoJywgdGhpcy5jdXJyZW50RGF0YVNvdXJjZSA/IHRoaXMuY3VycmVudERhdGFTb3VyY2UgOiB0aGlzLmRlZmF1bHRIeXBvdGhlc2lzRGF0YVNvdXJjZSk7CgogICAgdGhpcy5zaW5JZCA9IGdldFNpbklkRnJvbURhdGFTb3VyY2UodGhpcy5jdXJyZW50RGF0YVNvdXJjZSk7CiAgICBBUEkuZ2V0U2luUXVlcnlSZXN1bHRzKHRoaXMuc2luSWQsIGRhdGFTb3VyY2UpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7CiAgICAgIF90aGlzLlNJTiA9IHJlc3BvbnNlLmRhdGE7CgogICAgICBfdGhpcy5nZXRGb3JtYXR0ZWREYXRhKHJlc3BvbnNlLmRhdGEpOwogICAgfSk7CiAgfSwKICBjb21wdXRlZDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtYXBTdGF0ZShbJ2RlZmF1bHRIeXBvdGhlc2lzRGF0YVNvdXJjZScsICdoeXBvdGhlc2lzU2VsZWN0aW9uJywgJ2N1cnJlbnREYXRhU291cmNlJ10pKSwge30sIHsKICAgIHR5cGVzOiBmdW5jdGlvbiB0eXBlcygpIHsKICAgICAgcmV0dXJuIHRoaXMuc2luVHlwZXMubGVuZ3RoID4gMCA/IHRoaXMuc2luVHlwZXMgOiBudWxsOwogICAgfSwKICAgIHNpbkRhdGE6IGZ1bmN0aW9uIHNpbkRhdGEoKSB7CiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNpbkh5cG90aGVzZXMpLmxlbmd0aCA+IDAgPyB0aGlzLnNpbkh5cG90aGVzZXMgOiBudWxsOwogICAgfQogIH0pLAogIG1ldGhvZHM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbWFwTXV0YXRpb25zKFsndXBkYXRlSHlwb3RoZXNpc1NlbGVjdGlvbiddKSksIHt9LCB7CiAgICBidWlsZFRhYmxlQ29uZmlndXJhdGlvbjogZnVuY3Rpb24gYnVpbGRUYWJsZUNvbmZpZ3VyYXRpb24odHlwZSkgewogICAgICB2YXIgY2F0ZWdvcnkgPSB0aGlzLnNpbkRhdGFbdHlwZV1bMF1bVEFCTEVGSUVMRE1BUFBJTkcuY2x1c3RlckNhdGVnb3J5XTsKICAgICAgdmFyIHJvbGVIZWFkZXJzID0gbmV3IE1hcCgpOwogICAgICB2YXIgdGFibGVNYXBwaW5ncyA9IHsKICAgICAgICB0YWJsZVNldHRpbmdzOiBuZXcgVGFibGVTZXR0aW5ncyhUQUJMRUZJRUxETUFQUElORy5pZFVyaSwgZmFsc2UsIHR5cGUsIGNhdGVnb3J5LCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgJ2hlYWRsaW5lJywgZmFsc2UpLAogICAgICAgIHByaW1hcnlIZWFkZXJzOiBbbmV3IEhlYWRlckNvbmZpZygnSHlwb3RoZXNpcycsICdzdGFydCcsIHRydWUsIFRBQkxFRklFTERNQVBQSU5HLmhlYWRsaW5lLCBmYWxzZSwgZmFsc2UpXQogICAgICB9OwoKICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuc2luRGF0YVt0eXBlXSksCiAgICAgICAgICBfc3RlcDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBoeXBvdGhlc2lzID0gX3N0ZXAudmFsdWU7CiAgICAgICAgICByb2xlSGVhZGVycyA9IG5ldyBNYXAoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyb2xlSGVhZGVycyksIF90b0NvbnN1bWFibGVBcnJheShuZXcgTWFwKGh5cG90aGVzaXNbVEFCTEVGSUVMRE1BUFBJTkcucm9sZXNdLm1hcChmdW5jdGlvbiAocm9sZSkgewogICAgICAgICAgICByZXR1cm4gW3JvbGUsIG5ldyBIZWFkZXJDb25maWcocm9sZSwgJ3N0YXJ0JywgdHJ1ZSwgcm9sZSwgdHJ1ZSwgdHJ1ZSldOwogICAgICAgICAgfSkpKSkpOwogICAgICAgIH0gLy9zb3J0IHJvbGUgaGVhZGVycwoKICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICB9CgogICAgICByb2xlSGVhZGVycyA9IG5ldyBNYXAoX3RvQ29uc3VtYWJsZUFycmF5KHJvbGVIZWFkZXJzKS5zb3J0KCkpOyAvL2NvbWJpbmUgZXhpc3RpbmcgcHJpbWFyeSBoZWFkZXJzIHdpdGggcm9sZSBhbmQgbWF0Y2ggcGVyY2VudGFnZSBoZWFkZXJzCgogICAgICB0YWJsZU1hcHBpbmdzLnByaW1hcnlIZWFkZXJzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0YWJsZU1hcHBpbmdzLnByaW1hcnlIZWFkZXJzKSwgX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBTZXQoX3RvQ29uc3VtYWJsZUFycmF5KHJvbGVIZWFkZXJzLnZhbHVlcygpKSkpKS5jb25jYXQoW25ldyBIZWFkZXJDb25maWcoJ01hdGNoICUnLCAnZW5kJywgdHJ1ZSwgVEFCTEVGSUVMRE1BUFBJTkcucGVyY2VudGFnZSwgZmFsc2UsIGZhbHNlKV0pOwogICAgICByZXR1cm4gdGFibGVNYXBwaW5nczsKICAgIH0sCiAgICBnZXRGb3JtYXR0ZWREYXRhOiBmdW5jdGlvbiBnZXRGb3JtYXR0ZWREYXRhKHNpbikgewogICAgICB2YXIgaHlwb3RoZXNlcyA9IFtdOwogICAgICBzb3J0QXJyYXlPZk9iamVjdHMoc2luLmh5cG90aGVzZXMsICdoeXBvdGhlc2lzJyk7CgogICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNpbi5oeXBvdGhlc2VzKSwKICAgICAgICAgIF9zdGVwMjsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBoeXBPYmplY3QgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgICAvL25ldyBtYXAgcmVtb3ZlcyBkdXBsaWNhdGUgdHlwZXMsIGFkZGVkIFVua25vd24gdHlwZSB0byBjb21wZW5zYXRlIGZvciBpbmNvbXBsZXRlIG1lbWJlciBpbmZvcm1hdGlvbgogICAgICAgICAgdmFyIGh5cFR5cGVzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShuZXcgU2V0KGh5cE9iamVjdC50eXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsKICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVByZWZpeCh0eXBlLCBQUkVGSVhUWVBFUy5oYXNoKTsKICAgICAgICAgIH0pKSksIFsnVW5rbm93biddKS5zb3J0KCk7CiAgICAgICAgICB2YXIgaHlwb3RoZXNpc0J5TWVtYmVyVHlwZSA9IG5ldyBNYXAoKTsKCiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGh5cFR5cGVzKSwKICAgICAgICAgICAgICBfc3RlcDM7CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICB2YXIgaHQgPSBfc3RlcDMudmFsdWU7CiAgICAgICAgICAgICAgLy9zaGFsbG93IGNsb25lCiAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZEh5cG90aGVzaXMgPSBPYmplY3QuYXNzaWduKHt9LCBoeXBPYmplY3QpOwogICAgICAgICAgICAgIHZhciBtZW1iZXJzID0gW107CiAgICAgICAgICAgICAgdmFyIHJvbGVzID0gW107IC8vY29sbGVjdGluZyBhbmQgZm9ybWF0dGluZyBtZW1iZXJzIHRvIHBlcmZvcm0gYSBkZWVwIGNsb25lCgogICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaHlwT2JqZWN0Lm1lbWJlcnMpLAogICAgICAgICAgICAgICAgICBfc3RlcDQ7CgogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykgewogICAgICAgICAgICAgICAgICB2YXIgbWVtYmVyID0gX3N0ZXA0LnZhbHVlOwoKICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBhcmUgbm8gYXJndW1lbnRzIHRoZW4gdGhlcmUgaXMgbm8gbmVlZCB0byBzaG93IHRoZSBtZW1iZXIKICAgICAgICAgICAgICAgICAgaWYgKGh0ID09PSByZW1vdmVQcmVmaXgobWVtYmVyLnR5cGUsIFBSRUZJWFRZUEVTLmhhc2gpICYmIG1lbWJlci5yb2xlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgbWVtYmVycy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG1lbWJlci5ub2RlLAogICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IG1lbWJlci5jYXRlZ29yeSwKICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1lbWJlci50eXBlLAogICAgICAgICAgICAgICAgICAgICAgcm9sZXM6IF90b0NvbnN1bWFibGVBcnJheShtZW1iZXIucm9sZXMpCiAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobWVtYmVyLnJvbGVzKSwKICAgICAgICAgICAgICAgICAgICAgICAgX3N0ZXA1OwoKICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvbGUgPSBfc3RlcDUudmFsdWU7CiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGVzLnB1c2gocmVtb3ZlUHJlZml4KHJvbGUucm9sZSwgUFJFRklYVFlQRVMudW5kZXJzY29yZSkpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7CiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjUuZigpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSAvL2lmIHRoaXMgaHlwb3RoZXNpcyBoYXMgbWVtYmVycyBvZiB0aGlzIHR5cGUgdGhlbiBjb250aW51ZSBmb3JtYXR0aW5nIGRhdGEKCiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTsKICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBpZiAobWVtYmVycy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRIeXBvdGhlc2lzLm1lbWJlcnMgPSBtZW1iZXJzOwogICAgICAgICAgICAgICAgZm9ybWF0dGVkSHlwb3RoZXNpcy5yb2xlcyA9IF90b0NvbnN1bWFibGVBcnJheShuZXcgTWFwKHJvbGVzLm1hcChmdW5jdGlvbiAocm9sZSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gW3JvbGUsIHJvbGVdOwogICAgICAgICAgICAgICAgfSkpLnZhbHVlcygpKS5zb3J0KCk7CiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRIeXBvdGhlc2lzLmNhdGVnb3J5ID0gcmVtb3ZlUHJlZml4KG1lbWJlcnNbMF0uY2F0ZWdvcnksIFBSRUZJWFRZUEVTLmhhc2gpOwogICAgICAgICAgICAgICAgZm9ybWF0dGVkSHlwb3RoZXNpcyA9IGZvcm1hdFNpbnNDb21wYXJpc29uKGZvcm1hdHRlZEh5cG90aGVzaXMsIERBVEFUWVBFUy5zaW4uaWQsIGh0KTsKICAgICAgICAgICAgICAgIHZhciBoeXBEYXRhID0gewogICAgICAgICAgICAgICAgICB0eXBlOiBodCwKICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybWF0dGVkSHlwb3RoZXNpcwogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIGh5cG90aGVzaXNCeU1lbWJlclR5cGUuc2V0KGh0LCBoeXBEYXRhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gLy9hZGQgbmV3bHkgZm9ybWF0dGVkIGh5cG90aGVzaXMgdG8gaHlwb3RoZXNlcyBhcnJheQoKICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTsKICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjMuZigpOwogICAgICAgICAgfQoKICAgICAgICAgIGh5cG90aGVzZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGh5cG90aGVzZXMpLCBfdG9Db25zdW1hYmxlQXJyYXkoaHlwb3RoZXNpc0J5TWVtYmVyVHlwZS52YWx1ZXMoKSkpOwogICAgICAgIH0gLy9ncm91cHMgaHlwb3RoZXNlcyBkYXRhIGJ5IG1lbWJlciB0eXBlCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IyLmYoKTsKICAgICAgfQoKICAgICAgdmFyIGh5cG90aGVzZXNSZWR1Y2UgPSBoeXBvdGhlc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBvYmopIHsKICAgICAgICB2YXIga2V5ID0gb2JqLnR5cGU7CgogICAgICAgIGlmICghYWNjW2tleV0pIHsKICAgICAgICAgIGFjY1trZXldID0gW107CiAgICAgICAgfSAvLyBBZGQgb2JqZWN0IGRhdGEgdG8gbGlzdCBpbiB0aGUgZ2l2ZW4ga2V5IHBvc2l0aW9uCgoKICAgICAgICBhY2Nba2V5XS5wdXNoKG9iai5kYXRhKTsKICAgICAgICByZXR1cm4gYWNjOwogICAgICB9LCB7fSk7CiAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlOyAvL3VwZGF0ZXMgdGhlIHNpbiBkYXRhIGFuZCBzaW4gdHlwZXMKCiAgICAgIHRoaXMuc2luSHlwb3RoZXNlcyA9IGh5cG90aGVzZXNSZWR1Y2U7CiAgICAgIHRoaXMuc2luVHlwZXMgPSBPYmplY3Qua2V5cyhoeXBvdGhlc2VzUmVkdWNlKS5zb3J0KCk7CiAgICB9LAogICAgdXBkYXRlRm9udHNBbmRCYWNrZ3JvdW5kczogZnVuY3Rpb24gdXBkYXRlRm9udHNBbmRCYWNrZ3JvdW5kcyhoeXBvdGhlc2lzLCB0eXBlLCBpZCwgY29tcGFyZU9uKSB7CiAgICAgIGh5cG90aGVzaXNbVEFCTEVGSUVMRE1BUFBJTkcuY29tcGFyZV0gPSBjb21wYXJlT247CiAgICAgIGh5cG90aGVzaXNbVEFCTEVGSUVMRE1BUFBJTkcuaGlnaGxpZ2h0XSA9IGNvbXBhcmVPbjsKCiAgICAgIGlmICghY29tcGFyZU9uKSB7CiAgICAgICAgdGhpcy5yZXNldENvbG9yVGV4dEFuZFBlcmNlbnRhZ2UodHlwZSk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBoeXBvdGhlc2lzW1RBQkxFRklFTERNQVBQSU5HLnBlcmNlbnRhZ2VdID0gMTAwOyAvLyBjb2xsZWN0IHRoZSBlbnRpdGllcyBvZiByZWZlcmVuY2UgaHlwb3RoZXNpcwoKICAgICAgdmFyIHJlZmVyZW5jZUVudGl0aWVzID0gbmV3IFNldCh0aGlzLmdldEVudGl0aWVzKGh5cG90aGVzaXMpKTsKICAgICAgdmFyIHJlZmVyZW5jZVN0cmluZ3MgPSBuZXcgU2V0KHRoaXMuZ2V0RW50aXR5U3RyaW5ncyhoeXBvdGhlc2lzKSk7IC8vIGl0ZXJhdGUgb3ZlciBvdGhlciBoeXBvdGhlc2VzIGFuZCBzZXQgY29sb3JUZXh0IGZvciBmYWxzZSBwb3NpdGl2ZXMKCiAgICAgIHZhciBjb21wYXJlSHlwb3RoZXNlcyA9IHRoaXMuc2luRGF0YVt0eXBlXS5maWx0ZXIoZnVuY3Rpb24gKGgpIHsKICAgICAgICByZXR1cm4gaFtUQUJMRUZJRUxETUFQUElORy5pZFVyaV0gIT09IGlkOwogICAgICB9KTsKCiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY29tcGFyZUh5cG90aGVzZXMpLAogICAgICAgICAgX3N0ZXA2OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGNvbXBhcmlzb24gPSBfc3RlcDYudmFsdWU7CiAgICAgICAgICB2YXIgY29tcGFyZUVudGl0aWVzID0gbmV3IFNldCh0aGlzLmdldEVudGl0aWVzKGNvbXBhcmlzb24pKTsKICAgICAgICAgIHZhciBjb21wYXJlU3RyaW5ncyA9IG5ldyBTZXQodGhpcy5nZXRFbnRpdHlTdHJpbmdzKGNvbXBhcmlzb24pKTsKICAgICAgICAgIHZhciBhbGxFbnRpdGllcyA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZWZlcmVuY2VFbnRpdGllcyksIF90b0NvbnN1bWFibGVBcnJheShjb21wYXJlRW50aXRpZXMpKSk7CiAgICAgICAgICB2YXIgZmFsc2VQb3NpdGl2ZSA9IDA7CiAgICAgICAgICB2YXIgZmFsc2VOZWdhdGl2ZSA9IDA7CiAgICAgICAgICB2YXIgdHJ1ZVBvc2l0aXZlID0gMDsKCiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFsbEVudGl0aWVzKSwKICAgICAgICAgICAgICBfc3RlcDc7CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICB2YXIgdGVzdEVudGl0eSA9IF9zdGVwNy52YWx1ZTsKICAgICAgICAgICAgICB2YXIgdGVzdFN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKHRlc3RFbnRpdHkpOwogICAgICAgICAgICAgIHZhciBpblJlZiA9IHJlZmVyZW5jZVN0cmluZ3MuaGFzKHRlc3RTdHJpbmcpOwogICAgICAgICAgICAgIHZhciBpbkNvbXAgPSBjb21wYXJlU3RyaW5ncy5oYXModGVzdFN0cmluZyk7IC8vIGluUmVmIFhPUiBpbkNvbXAKCiAgICAgICAgICAgICAgaWYgKGluUmVmICE9IGluQ29tcCkgewogICAgICAgICAgICAgICAgaWYgKGluUmVmKSB7CiAgICAgICAgICAgICAgICAgIGZhbHNlTmVnYXRpdmUrKzsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGZhbHNlUG9zaXRpdmUrKzsKICAgICAgICAgICAgICAgICAgdGVzdEVudGl0eVtUQUJMRUZJRUxETUFQUElORy5jb2xvclRleHRdID0gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgLy8gbXVzdCBiZSB0cnVlIHBvc2l0aXZlCiAgICAgICAgICAgICAgICB0cnVlUG9zaXRpdmUrKzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTsKICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjcuZigpOwogICAgICAgICAgfQoKICAgICAgICAgIHZhciBmID0gdHJ1ZVBvc2l0aXZlIC8gKHRydWVQb3NpdGl2ZSArIC41ICogKGZhbHNlUG9zaXRpdmUgKyBmYWxzZU5lZ2F0aXZlKSk7CiAgICAgICAgICBjb21wYXJpc29uW1RBQkxFRklFTERNQVBQSU5HLnBlcmNlbnRhZ2VdID0gTWF0aC5jZWlsKGYgKiAxMDApOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7CiAgICAgIH0KICAgIH0sCiAgICByZXNldENvbG9yVGV4dEFuZFBlcmNlbnRhZ2U6IGZ1bmN0aW9uIHJlc2V0Q29sb3JUZXh0QW5kUGVyY2VudGFnZSh0eXBlKSB7CiAgICAgIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5zaW5EYXRhW3R5cGVdKSwKICAgICAgICAgIF9zdGVwODsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBoID0gX3N0ZXA4LnZhbHVlOwogICAgICAgICAgZGVsZXRlIGhbVEFCTEVGSUVMRE1BUFBJTkcucGVyY2VudGFnZV07CgogICAgICAgICAgdmFyIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmdldEVudGl0aWVzKGgpKSwKICAgICAgICAgICAgICBfc3RlcDk7CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I5LnMoKTsgIShfc3RlcDkgPSBfaXRlcmF0b3I5Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICB2YXIgZW50aXR5ID0gX3N0ZXA5LnZhbHVlOwogICAgICAgICAgICAgIGVudGl0eVtUQUJMRUZJRUxETUFQUElORy5jb2xvclRleHRdID0gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBfaXRlcmF0b3I5LmUoZXJyKTsKICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjkuZigpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yOC5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yOC5mKCk7CiAgICAgIH0KICAgIH0sCiAgICBnZXRTdHJpbmc6IGZ1bmN0aW9uIGdldFN0cmluZyhlKSB7CiAgICAgIHJldHVybiBlW1RBQkxFRklFTERNQVBQSU5HLnJvbGVzXVswXSArICcgLSAnICsgZVtUQUJMRUZJRUxETUFQUElORy5oZWFkbGluZV0gKyAnIC0gJyArIGVbVEFCTEVGSUVMRE1BUFBJTkcudHlwZXNdLmpvaW4oJywnKTsKICAgIH0sCiAgICBnZXRFbnRpdHlTdHJpbmdzOiBmdW5jdGlvbiBnZXRFbnRpdHlTdHJpbmdzKGh5cG90aGVzaXMpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0RW50aXRpZXMoaHlwb3RoZXNpcykubWFwKHRoaXMuZ2V0U3RyaW5nKTsKICAgIH0sCiAgICBnZXRFbnRpdGllczogZnVuY3Rpb24gZ2V0RW50aXRpZXMoaHlwb3RoZXNpcykgewogICAgICByZXR1cm4gaHlwb3RoZXNpc1tUQUJMRUZJRUxETUFQUElORy5jbHVzdGVyTGlzdF0uZmxhdE1hcChmdW5jdGlvbiAoYykgewogICAgICAgIHJldHVybiBjW1RBQkxFRklFTERNQVBQSU5HLmVudGl0eUxpc3RdOwogICAgICB9KTsKICAgIH0sCiAgICB1cGRhdGVJdGVtc0ZvckNvbXBhcmlzb246IGZ1bmN0aW9uIHVwZGF0ZUl0ZW1zRm9yQ29tcGFyaXNvbihyb3cpIHsKICAgICAgdmFyIF90aGlzMiA9IHRoaXM7CgogICAgICB2YXIgc2VsZWN0ZWRIeXBvdGhlc2lzID0ge307CiAgICAgIHZhciByZW1vdmVTdHlsaW5nID0gcm93Lml0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuY29tcGFyZV0gPT09IHRydWUgJiYgcm93Lml0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldID09PSB0aGlzLmh5cG90aGVzaXNTZWxlY3Rpb25bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldOwoKICAgICAgZm9yICh2YXIgY2x1c3RlclR5cGUgaW4gdGhpcy5zaW5EYXRhKSB7CiAgICAgICAgaWYgKHRoaXMuc2luRGF0YS5oYXNPd25Qcm9wZXJ0eShjbHVzdGVyVHlwZSkpIHsKICAgICAgICAgIC8vVHVybiBvZmYgY29tcGFyaXNvbiBoaWdobGlnaHRpbmcgZm9yIHByZXZpb3VzbHkgc2VsZWN0ZWQgaHlwb3RoZXNpcwogICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuaHlwb3RoZXNpc1NlbGVjdGlvbikubGVuZ3RoID4gMCkgewogICAgICAgICAgICB2YXIgcHJldmlvdXNIeXBvdGhlc2lzID0gdGhpcy5zaW5EYXRhW2NsdXN0ZXJUeXBlXS5maW5kKGZ1bmN0aW9uIChoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGhbVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldID09PSBfdGhpczIuaHlwb3RoZXNpc1NlbGVjdGlvbltUQUJMRUZJRUxETUFQUElORy5pZFVyaV07CiAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgaWYgKHByZXZpb3VzSHlwb3RoZXNpcykgewogICAgICAgICAgICAgIHRoaXMudXBkYXRlRm9udHNBbmRCYWNrZ3JvdW5kcyhwcmV2aW91c0h5cG90aGVzaXMsIGNsdXN0ZXJUeXBlLCB0aGlzLmh5cG90aGVzaXNTZWxlY3Rpb25bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldLCBmYWxzZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIXJlbW92ZVN0eWxpbmcpIHsKICAgICAgICAgICAgLy9UdXJuIG9uIGNvbXBhcmlzb24gaGlnaGxpZ2h0aW5nIGZvciBjdXJyZW50bHkgc2VsZWN0ZWQgaHlwb3RoZXNpcyBhbmQgc2F2ZSB0byB0aGUgc3RvcmUKICAgICAgICAgICAgdmFyIGh5cG90aGVzaXMgPSB0aGlzLnNpbkRhdGFbY2x1c3RlclR5cGVdLmZpbmQoZnVuY3Rpb24gKGgpIHsKICAgICAgICAgICAgICByZXR1cm4gaFtUQUJMRUZJRUxETUFQUElORy5pZFVyaV0gPT09IHJvdy5pdGVtW1RBQkxFRklFTERNQVBQSU5HLmlkVXJpXTsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICBpZiAoaHlwb3RoZXNpcykgewogICAgICAgICAgICAgIHRoaXMudXBkYXRlRm9udHNBbmRCYWNrZ3JvdW5kcyhoeXBvdGhlc2lzLCBjbHVzdGVyVHlwZSwgcm93Lml0ZW1bVEFCTEVGSUVMRE1BUFBJTkcuaWRVcmldLCB0cnVlKTsKCiAgICAgICAgICAgICAgaWYgKGNsdXN0ZXJUeXBlID09PSByb3cudHlwZSkgewogICAgICAgICAgICAgICAgc2VsZWN0ZWRIeXBvdGhlc2lzID0gaHlwb3RoZXNpczsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMudXBkYXRlSHlwb3RoZXNpc1NlbGVjdGlvbihyZW1vdmVTdHlsaW5nID8ge30gOiBzZWxlY3RlZEh5cG90aGVzaXMpOwogICAgfQogIH0pCn07"},{"version":3,"sources":["HypothesisComparison.vue"],"names":[],"mappings":"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","sourcesContent":["<!--\n  - Copyright 2019 Next Century Corporation/CACI\n  -\n  - Licensed under the Apache License, Version 2.0 (the \"License\");\n  - you may not use this file except in compliance with the License.\n  - You may obtain a copy of the License at\n  -\n  -       http://www.apache.org/licenses/LICENSE-2.0\n  -\n  - Unless required by applicable law or agreed to in writing, software\n  - distributed under the License is distributed on an \"AS IS\" BASIS,\n  - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  - See the License for the specific language governing permissions and\n  - limitations under the License.\n  -\n-->\n\n<template>\n    <div class=\"page-content\">\n        <div class=\"kb-details\">\n            <div class=\"row-width-description-wrapper\">\n                <div class=\"page-header-left\">\n                    <div class=\"kb-heading\">Hypothesis Comparison</div>\n                    <div><span class=\"kb-labels\">SIN ID: </span><span>{{sinId}}</span></div>\n                    <div><span class=\"kb-labels\">Description: </span><span>{{SIN.description}}</span></div>\n                </div>\n                <div class=\"page-header-align-bottom-right\">\n                    <span>Current Reference</span><v-icon>mdi-compare</v-icon>\n                </div>\n            </div>\n        </div>\n        <div v-if=\"loading===true\" class=\"loading-section\">\n            <v-progress-linear indeterminate></v-progress-linear>\n            <div class=\"loading-message-clear\">{{statusMessage}}</div>\n        </div>\n\n        <div v-else>\n            <div v-for=\"(type, index) in types\" :key=\"index\" :class=\"index > 0 ? 'section-space' : ''\">\n                <DataTable\n                    :data=\"sinData[type]\"\n                    :sort=\"sort\"\n                    :loading=\"Object.keys(sinData[type]).length === 0\"\n                    :paging=\"paging\"\n                    :tableConfiguration=\"buildTableConfiguration(type)\"\n                    :statusMessage=\"statusMessage\"\n                    @activateCompare=\"updateItemsForComparison($event)\"\n                    :hideFooter=true\n                    :hideHeader=true\n                ></DataTable>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import DataTable from '@/components/DataTable';\n    import { mapMutations, mapState} from 'vuex';\n    import API from '../../api';\n    import {\n        TABLESELECTIONS,\n        TABLEFIELDMAPPING,\n        DATATYPES,\n        LOADINGMESSAGE,\n        PREFIXTYPES,\n        sortArrayOfObjects,\n        removePrefix,\n        formatSinsComparison,\n        getSinIdFromDataSource,\n        TableSettings,\n        HeaderConfig\n    } from '../../utils';\n\n    export default {\n        name: 'HypothesisComparison',\n        components: {DataTable},\n        data: () => ({\n            sort: {[TABLESELECTIONS.sortBy]: TABLEFIELDMAPPING.id, [TABLESELECTIONS.sortDesc]: false},\n            paging: {[TABLESELECTIONS.itemsPerPage]:'All'},\n            statusMessage: '',\n            sinHypotheses: {},\n            sinTypes: [],\n            sinId : '',\n            SIN: {},\n            loading: false,\n        }),\n        created() {\n            this.TABLEFIELDMAPPING = TABLEFIELDMAPPING;\n            this.DATATYPES = DATATYPES;\n            this.loading  = true;\n            this.statusMessage = LOADINGMESSAGE;\n        },\n        mounted() {\n            this.updateHypothesisSelection({});\n            let dataSource = {['graph'] : this.currentDataSource ? this.currentDataSource : this.defaultHypothesisDataSource};\n            this.sinId = getSinIdFromDataSource(this.currentDataSource);\n            API.getSinQueryResults(this.sinId, dataSource).then(response => {\n                this.SIN = response.data;\n                this.getFormattedData(response.data);\n            });\n        },\n        computed: {\n            ...mapState(['defaultHypothesisDataSource', 'hypothesisSelection','currentDataSource']),\n            types() {\n                return this.sinTypes.length > 0 ? this.sinTypes : null;\n            },\n            sinData() {\n                return Object.keys(this.sinHypotheses).length > 0 ? this.sinHypotheses : null;\n            }\n        },\n        methods: {\n            ...mapMutations(['updateHypothesisSelection']),\n            buildTableConfiguration(type) {\n                const category = this.sinData[type][0][TABLEFIELDMAPPING.clusterCategory];\n                let roleHeaders = new Map();\n                let tableMappings = {\n                    tableSettings: new TableSettings(TABLEFIELDMAPPING.idUri, false, type, category, false, false, false, false, true, 'headline', false),\n                    primaryHeaders: [\n                        new HeaderConfig('Hypothesis', 'start', true, TABLEFIELDMAPPING.headline, false, false)\n                    ]\n                };\n\n                for (const hypothesis of this.sinData[type]) {\n                    roleHeaders = new Map([...roleHeaders, ...new Map(hypothesis[TABLEFIELDMAPPING.roles].map(role =>\n                        [role, new HeaderConfig(role, 'start', true, role, true, true)]\n                    ))]);\n                }\n\n                //sort role headers\n                roleHeaders = new Map([...roleHeaders].sort());\n\n                //combine existing primary headers with role and match percentage headers\n                tableMappings.primaryHeaders = [\n                    ...[...tableMappings.primaryHeaders, ...new Set([...roleHeaders.values()])],\n                    ...[new HeaderConfig('Match %', 'end', true, TABLEFIELDMAPPING.percentage, false, false)]\n                ];\n\n                return tableMappings;\n            },\n            getFormattedData(sin) {\n                let hypotheses = [];\n                sortArrayOfObjects(sin.hypotheses, 'hypothesis');\n\n                for (const hypObject of sin.hypotheses) {\n                    //new map removes duplicate types, added Unknown type to compensate for incomplete member information\n                    const hypTypes = [...new Set(hypObject.types.map(type => removePrefix(type, PREFIXTYPES.hash))), 'Unknown'].sort();\n\n                    let hypothesisByMemberType = new Map();\n                    for (const ht of hypTypes) {\n                        //shallow clone\n                        let formattedHypothesis = Object.assign({}, hypObject);\n\n                        let members = [];\n                        let roles = [];\n                        //collecting and formatting members to perform a deep clone\n                        for (const member of hypObject.members) {\n                            //if there are no arguments then there is no need to show the member\n                            if (ht === removePrefix(member.type, PREFIXTYPES.hash) && member.roles.length > 0) {\n                                members.push({\n                                    node: member.node,\n                                    category: member.category,\n                                    type: member.type,\n                                    roles: [...member.roles],\n                                });\n\n                                for(const role of member.roles) {\n                                    roles.push(removePrefix(role.role, PREFIXTYPES.underscore));\n                                }\n                            }\n                        }\n\n                        //if this hypothesis has members of this type then continue formatting data\n                        if(members.length > 0) {\n                            formattedHypothesis.members = members;\n                            formattedHypothesis.roles = [...new Map(roles.map(role => [role, role])).values()].sort();\n                            formattedHypothesis.category = removePrefix(members[0].category, PREFIXTYPES.hash);\n                            formattedHypothesis = formatSinsComparison(formattedHypothesis, DATATYPES.sin.id, ht);\n\n                            let hypData = {type: ht, data: formattedHypothesis};\n                            hypothesisByMemberType.set(ht, hypData);\n                        }\n                    }\n\n                    //add newly formatted hypothesis to hypotheses array\n                    hypotheses = [...hypotheses, ...hypothesisByMemberType.values()];\n\n                }\n\n                //groups hypotheses data by member type\n                const hypothesesReduce = hypotheses.reduce((acc, obj) => {\n                    const key = obj.type;\n                    if (!acc[key]) {\n                        acc[key] = [];\n                    }\n                    // Add object data to list in the given key position\n                    acc[key].push(obj.data);\n                    return acc;\n                }, {});\n\n                this.loading  = false;\n\n                //updates the sin data and sin types\n                this.sinHypotheses = hypothesesReduce;\n                this.sinTypes = Object.keys(hypothesesReduce).sort();\n            },\n            updateFontsAndBackgrounds(hypothesis, type, id, compareOn) {\n                hypothesis[TABLEFIELDMAPPING.compare] = compareOn;\n                hypothesis[TABLEFIELDMAPPING.highlight] = compareOn;\n\n                if (!compareOn) {\n                    this.resetColorTextAndPercentage(type);\n                    return;\n                }\n\n                hypothesis[TABLEFIELDMAPPING.percentage] = 100;\n                \n                // collect the entities of reference hypothesis\n                const referenceEntities = new Set(this.getEntities(hypothesis));\n                const referenceStrings = new Set(this.getEntityStrings(hypothesis));\n\n                // iterate over other hypotheses and set colorText for false positives\n                const compareHypotheses = this.sinData[type].filter(h => h[TABLEFIELDMAPPING.idUri] !== id);\n                for(const comparison of compareHypotheses) {\n                    const compareEntities = new Set(this.getEntities(comparison));\n                    const compareStrings = new Set(this.getEntityStrings(comparison));\n                    const allEntities = new Set([...referenceEntities, ...compareEntities]);\n    \n                    let falsePositive = 0;\n                    let falseNegative = 0;\n                    let truePositive = 0;\n                    for (const testEntity of allEntities) {\n                        const testString = this.getString(testEntity);\n                        const inRef = referenceStrings.has(testString);\n                        const inComp = compareStrings.has(testString);\n                        // inRef XOR inComp\n                        if (inRef != inComp) {\n                            if (inRef) {\n                                falseNegative++;\n                            } else {\n                                falsePositive++;\n                                testEntity[TABLEFIELDMAPPING.colorText] = true;\n                            }\n                        } else { \n                            // must be true positive\n                            truePositive++;\n                        }\n                    }\n                    const f =  truePositive / (truePositive + .5 * (falsePositive + falseNegative));\n                    comparison[TABLEFIELDMAPPING.percentage] = Math.ceil(f * 100);\n                }\n            },\n            resetColorTextAndPercentage(type) {\n                for (const h of this.sinData[type]) {\n                    delete h[TABLEFIELDMAPPING.percentage];\n                    for (const entity of this.getEntities(h)) {\n                        entity[TABLEFIELDMAPPING.colorText] = false;\n                    }\n                }\n            },\n            getString(e) {\n                return e[TABLEFIELDMAPPING.roles][0] + ' - ' + e[TABLEFIELDMAPPING.headline] + ' - ' + e[TABLEFIELDMAPPING.types].join(',');\n            },\n            getEntityStrings(hypothesis) {\n                return this.getEntities(hypothesis).map(this.getString);\n            },\n            getEntities(hypothesis) {\n                return hypothesis[TABLEFIELDMAPPING.clusterList].flatMap(c => c[TABLEFIELDMAPPING.entityList]);\n            },\n            updateItemsForComparison(row) {\n                let selectedHypothesis = {};\n                let removeStyling = row.item[TABLEFIELDMAPPING.compare] === true &&\n                    row.item[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri];\n\n                for(const clusterType in this.sinData) {\n                    if(this.sinData.hasOwnProperty(clusterType)) {\n                        //Turn off comparison highlighting for previously selected hypothesis\n                        if(Object.keys(this.hypothesisSelection).length > 0) {\n                            let previousHypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === this.hypothesisSelection[TABLEFIELDMAPPING.idUri]);\n                            if(previousHypothesis) {\n                                this.updateFontsAndBackgrounds(previousHypothesis, clusterType, this.hypothesisSelection[TABLEFIELDMAPPING.idUri], false);\n                            }\n                        }\n\n                        if(!removeStyling) {\n                            //Turn on comparison highlighting for currently selected hypothesis and save to the store\n                            let hypothesis = this.sinData[clusterType]\n                                .find(h => h[TABLEFIELDMAPPING.idUri] === row.item[TABLEFIELDMAPPING.idUri]);\n                            if (hypothesis) {\n                                this.updateFontsAndBackgrounds(hypothesis, clusterType, row.item[TABLEFIELDMAPPING.idUri], true);\n\n                                if (clusterType === row.type) {\n                                    selectedHypothesis = hypothesis;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                this.updateHypothesisSelection(removeStyling ? {} : selectedHypothesis);\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n    .loading-section {\n        margin: 48px 0;\n    }\n\n    .loading-message-clear {\n        @include flex-row-nowrap;\n        justify-content: center;\n        height: 60px;\n        padding: 16px;\n    }\n</style>\n\n"],"sourceRoot":"src/views/analyze"}]}